var documenterSearchIndex = {"docs":
[{"location":"ode_extras/02-feagin/#Feagin's-Order-10,-12,-and-14-Methods","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"","category":"section"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"DifferentialEquations.jl includes Feagin's explicit Runge-Kutta methods of orders 10/8, 12/10, and 14/12. These methods have such high order that it's pretty much required that one uses numbers with more precision than Float64. As a prerequisite reference on how to use arbitrary number systems (including higher precision) in the numerical solvers, please see the Solving Equations in With Chosen Number Types notebook.","category":"page"},{"location":"ode_extras/02-feagin/#Investigation-of-the-Method's-Error","page":"Feagin's Order 10, 12, and 14 Methods","title":"Investigation of the Method's Error","text":"","category":"section"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"We can use Feagin's order 16 method as follows. Let's use a two-dimensional linear ODE. Like in the Solving Equations in With Chosen Number Types notebook, we change the initial condition to BigFloats to tell the solver to use BigFloat types.","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"using DifferentialEquations\nconst linear_bigα = big(1.01)\nf(u,p,t) = (linear_bigα*u)\n\n# Add analytical solution so that errors are checked\nf_analytic(u0,p,t) = u0*exp(linear_bigα*t)\nff = ODEFunction(f,analytic=f_analytic)\nprob = ODEProblem(ff,big(0.5),(0.0,1.0))\nsol = solve(prob,Feagin14(),dt=1//16,adaptive=false);","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"println(sol.errors)","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"Dict{Symbol, BigFloat}(:l∞ => 2.1975104034266099178147026326495605606836593\n67683780324635801610297349872909655e-23, :final => 2.1975104034266099178147\n02632649560560683659367683780324635801610297349872909655e-23, :l2 => 1.0615\n01597814768635894514677590712762248364686527596359902826841740549975688161e\n-23)","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"Compare that to machine epsilon for Float64:","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"eps(Float64)","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"2.220446049250313e-16","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"The error for Feagin's method when the stepsize is 1/16 is 8 orders of magnitude below machine epsilon! However, that is dependent on the stepsize. If we instead use adaptive timestepping with the default tolerances, we get","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"sol =solve(prob,Feagin14());\nprintln(sol.errors); print(\"The length was $(length(sol))\")","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"Dict{Symbol, BigFloat}(:l∞ => 1.5457388839431409625465375986097592198164147\n90728029220638828884206395861982752e-09, :final => 1.5457388839431409625465\n37598609759219816414790728029220638828884206395861982752e-09, :l2 => 8.9250\n66870202330409924421192162193462506388332261074725109949218067763405137993e\n-10)\nThe length was 3","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"Notice that when the stepsize is much higher, the error goes up quickly as well. These super high order methods are best when used to gain really accurate approximations (using still modest timesteps). Some examples of where such precision is necessary is astrodynamics where the many-body problem is highly chaotic and thus sensitive to small errors.","category":"page"},{"location":"ode_extras/02-feagin/#Convergence-Test","page":"Feagin's Order 10, 12, and 14 Methods","title":"Convergence Test","text":"","category":"section"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"The Order 14 method is awesome, but we need to make sure it's really that awesome. The following convergence test is used in the package tests in order to make sure the implementation is correct. Note that all methods have such tests in place.","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"using DiffEqDevTools\ndts = 1.0 ./ 2.0 .^(10:-1:4)\nsim = test_convergence(dts,prob,Feagin14())","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"DiffEqDevTools.ConvergenceSimulation{SciMLBase.ODESolution{BigFloat, 1, Vec\ntor{BigFloat}, Vector{BigFloat}, Dict{Symbol, BigFloat}, Vector{Float64}, V\nector{Vector{BigFloat}}, SciMLBase.ODEProblem{BigFloat, Tuple{Float64, Floa\nt64}, false, SciMLBase.NullParameters, SciMLBase.ODEFunction{false, typeof(\nMain.##WeaveSandBox#2261.f), LinearAlgebra.UniformScaling{Bool}, typeof(Mai\nn.##WeaveSandBox#2261.f_analytic), Nothing, Nothing, Nothing, Nothing, Noth\ning, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase\n.DEFAULT_OBSERVED), Nothing}, Base.Iterators.Pairs{Union{}, Union{}, Tuple{\n}, NamedTuple{(), Tuple{}}}, SciMLBase.StandardODEProblem}, OrdinaryDiffEq.\nFeagin14, OrdinaryDiffEq.InterpolationData{SciMLBase.ODEFunction{false, typ\neof(Main.##WeaveSandBox#2261.f), LinearAlgebra.UniformScaling{Bool}, typeof\n(Main.##WeaveSandBox#2261.f_analytic), Nothing, Nothing, Nothing, Nothing, \nNothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciML\nBase.DEFAULT_OBSERVED), Nothing}, Vector{BigFloat}, Vector{Float64}, Vector\n{Vector{BigFloat}}, OrdinaryDiffEq.Feagin14ConstantCache{BigFloat, Float64}\n}, DiffEqBase.DEStats}}(SciMLBase.ODESolution{BigFloat, 1, Vector{BigFloat}\n, Vector{BigFloat}, Dict{Symbol, BigFloat}, Vector{Float64}, Vector{Vector{\nBigFloat}}, SciMLBase.ODEProblem{BigFloat, Tuple{Float64, Float64}, false, \nSciMLBase.NullParameters, SciMLBase.ODEFunction{false, typeof(Main.##WeaveS\nandBox#2261.f), LinearAlgebra.UniformScaling{Bool}, typeof(Main.##WeaveSand\nBox#2261.f_analytic), Nothing, Nothing, Nothing, Nothing, Nothing, Nothing,\n Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSE\nRVED), Nothing}, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple\n{(), Tuple{}}}, SciMLBase.StandardODEProblem}, OrdinaryDiffEq.Feagin14, Ord\ninaryDiffEq.InterpolationData{SciMLBase.ODEFunction{false, typeof(Main.##We\naveSandBox#2261.f), LinearAlgebra.UniformScaling{Bool}, typeof(Main.##Weave\nSandBox#2261.f_analytic), Nothing, Nothing, Nothing, Nothing, Nothing, Noth\ning, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_\nOBSERVED), Nothing}, Vector{BigFloat}, Vector{Float64}, Vector{Vector{BigFl\noat}}, OrdinaryDiffEq.Feagin14ConstantCache{BigFloat, Float64}}, DiffEqBase\n.DEStats}[t: [0.0, 0.0009765625, 0.001953125, 0.0029296875, 0.00390625, 0.0\n048828125, 0.005859375, 0.0068359375, 0.0078125, 0.0087890625  …  0.9912109\n375, 0.9921875, 0.9931640625, 0.994140625, 0.9951171875, 0.99609375, 0.9970\n703125, 0.998046875, 0.9990234375, 1.0]\nu: BigFloat[0.50, 0.5004934073532741442240167407783486492180603021615841294\n52202794115660211219599, 0.500987301608180818440355281223188950584910597683\n3766213492949239260841368026092, 0.5014816832452017142719825709983542121453\n3336316613095293438972188206055292586, 0.5019765527452926697413863031219664\n328338088601822445017121888607974310367490053, 0.50247191058988413716521501\n79563239002143316649080207098547071166987523430816898, 0.502967757260881651\n5106435191675246046427648760687772460544794831604624949834855, 0.5034640932\n406662992139192389830628016370303392435659971381052766108783597241391, 0.50\n396091901209518746154563970525241120918072457951989067083504574325947816539\n15, 0.504458235058501913934559188511648417802868424125759953366000451921798\n6099443769  …  1.3606681506044349509999505354431852352163391999270684367421\n06414044679239515405, 1.362010877946183268827001169225864534157243515073039\n951153177861472631409617242, 1.36335493031101930838372463784595682752195537\n609659291992754149268935330476256, 1.36470030900649533914994667058892723740\n3312989133498476567243275650792209901316, 1.3660470153414539424145962795447\n72708050551524408051147344999020270553111340215, 1.367395050626029284574375\n015655225687307700620914621502414819287823171439227302, 1.36874441617164839\n1688936077411190219324498098498429005876504282210656625474981, 1.3700951132\n91032425293813214601928520794629811024108089775792586183724683573052, 1.371\n447143298197959472340593110913203812626370594321605117950295569839313271375\n, 1.37280050750845825918780601155411735836188549033294491231479506286094526\n5969766], t: [0.0, 0.001953125, 0.00390625, 0.005859375, 0.0078125, 0.00976\n5625, 0.01171875, 0.013671875, 0.015625, 0.017578125  …  0.982421875, 0.984\n375, 0.986328125, 0.98828125, 0.990234375, 0.9921875, 0.994140625, 0.996093\n75, 0.998046875, 1.0]\nu: BigFloat[0.50, 0.5009873016081808184403552812231889505849105976869970947\n216582055241988418330043, 0.50197655274529266974138630312196643283380886018\n94997464536470643897825028575861, 0.502967757260881651510643519167524604642\n764876079681602511069749881119893067103, 0.50396091901209518746154563970525\n24112091807245940877416493974506008240426203329, 0.504956041863697037016356\n8930910938780783930787757357867798953848057143406933377, 0.5059531296880823\n345471746020389471304909424091056168364541340183078255553277085, 0.50695218\n63652926583134503856740792313682294541010285050589346576968266665528748, 0.\n507953215783031129154683858104667438830905843059054531062193869152593801987\n2, 0.5089562218366775389970434828264868922469483072826175429449686273069735\n423750136  …  1.34864301545859247967509602307176367401641641210475048875695\n337449929440786918, 1.35130605029464067315359841454792588096269341231012308\n6924207034022962413754022, 1.3539743435678414104792857791059277027193819496\n29470176176029438646040014028995, 1.356647905661521606100766158464652339627\n531793759463868102607480971985702621672, 1.35932674697951112518845216660562\n3784669936757385516206254234939429597151648064, 1.3620108779461832688270011\n69225864534157243520073188743602186030419166325630835, 1.364700309006495339\n14994667058892723740331299415338282713705459498054912456936, 1.367395050626\n029284574375015655225687307700625954299855029057120653933933847354, 1.37009\n51132910324252938132146019285207946298160836390422151163694340862252063, 1.\n372800507508458259187806011554117358361885495412387216596637263939057644809\n585], t: [0.0, 0.00390625, 0.0078125, 0.01171875, 0.015625, 0.01953125, 0.0\n234375, 0.02734375, 0.03125, 0.03515625  …  0.96484375, 0.96875, 0.97265625\n, 0.9765625, 0.98046875, 0.984375, 0.98828125, 0.9921875, 0.99609375, 1.0]\nu: BigFloat[0.50, 0.5019765527452926697413863031219664328338089596679027919\n888741103974398448576829, 0.50396091901209518746154563970525241120918092433\n73910752677848686355143273445556, 0.505953129688082334547174602038947130490\n9427099049813605553848314515187463009496, 0.5079532157830311291546838581046\n674388309062457103293891502691351497465467261813, 0.50996120842930350923278\n5259415024406524958042349110331141518638069250199676435, 0.5119771388823309\n23641985750275520143854574772980860481510242829813108584126115, 0.514001038\n5211008389138964373154846258498358689286147531125652428267236364526061, 0.5\n160329388486451692230830905819969144868470465940686994015887118451172282452\n837, 0.51807287149253063717412013329248710548519771111335349047947245099497\n99099094199  …  1.324910628454177546699995024759245940440919035869353532178\n274979609386868635781, 1.33014813993405462867526880344471252204348922373995\n5282684225096368730900386558, 1.3354063558493198164900848637876127679604780\n49811958588576423121371759005353977, 1.340685358046790322335041702613370942\n319016635913214729849926370533428936466432, 1.34598522869683246090918314024\n5165332509908446336022662937657343709867017771688, 1.3513060502946406731535\n98414547925880962760896126504201689516014513211559127835, 1.356647905661521\n606100766158464652339627599813198025862866692566448305652099871, 1.36201087\n7946183268827001169225864534157312078314101084876138019637668867105307, 1.3\n673950506260292845743750156552256873077697261945049092191653877874628467060\n66, 1.372800507508458259187806011554117358361955140865683163444664161725836\n562110807], t: [0.0, 0.0078125, 0.015625, 0.0234375, 0.03125, 0.0390625, 0.\n046875, 0.0546875, 0.0625, 0.0703125  …  0.9296875, 0.9375, 0.9453125, 0.95\n3125, 0.9609375, 0.96875, 0.9765625, 0.984375, 0.9921875, 1.0]\nu: BigFloat[0.50, 0.5039609190120951874615456397052524112111879130152678185\n972878772909801438539725, 0.50795321578303112915468385810466743883495202114\n45279229156914347577732228682629, 0.511977138882330923641985750275520143860\n6915110986662360617789298294706379239618, 0.5160329388486451692230830905819\n96914495067305162617236525505000550159426923494, 0.520120868205351073036564\n3024626851557639184785285451286948438374521217071188324, 0.5242411814762751\n337774973218812134360586606206771934231862500076957565363308646, 0.52839413\n52015403769607464142521774116458265525572890561728945609507560270251758, 0.\n532579987953539129415176225095942661306833922007042413660746971902517988027\n2659, 0.5367990003530323275101958345252554486169547480536807778674613463641\n61391270671  …  1.278691378528666663061419567734810219225057268467188197890\n749511286039814682961, 1.28882096451229946257972559447843216250288715170826\n8911920429452719237031672889, 1.2990307954353467102700618873848859068511184\n7286542819859803450631324042075354, 1.3093215069852207083608767825998856173\n05680877664407188219768945081296125363463, 1.319693739885146473355596260460\n075276820407682877165061218322278576772888141989, 1.33014813993405462867526\n8803444712522700344601505102906797926571988117634577709, 1.3406853580467903\n22335041702613370942986414700099829148697106600907447993876335, 1.351306050\n294640673153598414547925881640827460343653263042386265204459670148168, 1.36\n201087794618326882700116922586453484617428790917305214715458105432837901989\n4, 1.3728005075084582591878060115541173590617414861285190771349018784370260\n32283726], t: [0.0, 0.015625, 0.03125, 0.046875, 0.0625, 0.078125, 0.09375,\n 0.109375, 0.125, 0.140625  …  0.859375, 0.875, 0.890625, 0.90625, 0.921875\n, 0.9375, 0.953125, 0.96875, 0.984375, 1.0]\nu: BigFloat[0.50, 0.5079532157830311291546838581046674228648435931525498190\n278213939882467623443407, 0.51603293884864516922308309058199688204679557555\n37640078345474392168602557520595, 0.524241181476275133777497321881213386612\n0487057078897985952628075072800031634668, 0.5325799879535391294151762250959\n425943293258372491737121300708996931105182686892, 0.54105143508537636149437\n50093333620112324860397855474272871650047471573253335466, 0.549657632711281\n6769034687550989237307955190439443562958216377582793355171347836, 0.5584007\n242307674626882271691434832264014636154224009359108553180731368099218107, 0\n.56728288713718376841017722890892910914534927957669258403882463243694705413\n29958, 0.576306333560029601749846103643822584449515926861513757846110140307\n5168130161427  …  1.1910336808448971384801387451313626311041821234303624933\n41676788830879226337858, 1.209978776582131731617051708708410892779229149607\n19360099713235492900284779981, 1.229225221188223144617416241361990712052620\n148424773445644365505495011922745439, 1.24877780804833135875651382983940481\n9440872534223897340978037770853624093056804, 1.2686414067932693723301711234\n73022743877631147466907756310015221824454321458462, 1.288820964512299462579\n725594478429731261988424253379253261167688863620014837669, 1.30932150698522\n0708360876782599883106227194078928307355592757175919985164258564, 1.3301481\n3993405462867526880344470992985954682818207565575624581067560987566062, 1.3\n513060502946406731535984145479232050719649354675944552369964535610982815942\n27, 1.372800507508458259187806011554114596757211232433432893362855858032659\n14211007], t: [0.0, 0.03125, 0.0625, 0.09375, 0.125, 0.15625, 0.1875, 0.218\n75, 0.25, 0.28125  …  0.71875, 0.75, 0.78125, 0.8125, 0.84375, 0.875, 0.906\n25, 0.9375, 0.96875, 1.0]\nu: BigFloat[0.50, 0.5160329388486451692230830905761645510166025236059793420\n81272221990055728561679, 0.532579987953539129415176225083903894641931169817\n6330530726315794171525645034893, 0.5496576327112816769034687550802866340567\n114355433590002071694871709322410405931, 0.56728288713718376841017722888328\n28270073935705216193322632159538121017711969774, 0.585473310815890461621019\n6190827662219055210008829792702890722633372001092380584, 0.6042470263955404\n578588421618108943195685209948140048324759492077870732303989337, 0.62362273\n76428912250695033937265522498285111444862489660878884721013969830771631, 0.\n643619748077397554810697726960708152129622579985972873985637448596666363180\n053, 0.66425798020280820325088307482585132534106704873625388888034286900680\n76152641046  …  1.033333846504426712082580354960107935043970613756493163451\n1294626091384818214, 1.0664686032469082465446852271794933182809166964255378\n32438762276651139095129374, 1.100665855046623660308919551395610359208286716\n684431112070414408183611765253205, 1.13595967174013219044727424686007597453\n6172903481653049159364319427066929995183, 1.1723852156432053491987697297701\n67158307196511889785786439894918782978322870963, 1.209978776582131731617051\n708325497527117244553498434756316642412641437610370797, 1.24877780804833135\n8756513829430099007097842940139504429315922973879445769691784, 1.2888209645\n1229946257972559404143259768018368155787883476891071715795301279543, 1.3301\n48139934054628675268802978666438630864641254421813595879534440847470751688,\n 1.372800507508458259187806011057611283394590006590596578199873499201906331\n611072], t: [0.0, 0.0625, 0.125, 0.1875, 0.25, 0.3125, 0.375, 0.4375, 0.5, \n0.5625, 0.625, 0.6875, 0.75, 0.8125, 0.875, 0.9375, 1.0]\nu: BigFloat[0.50, 0.5325799879535391294151756922663100127575701279367674657\n299889518448727031384926, 0.56728288713718376841017609381133190281668498488\n55565501534311815341659662084392, 0.604247026395540457858840348261076470751\n5845791230606683491210486718827818716904, 0.6436197480773975548106951513331\n34437286938781958375274884622802079377793549762, 0.685557995355440557982096\n349246370736930808950070979750802507189818563351642024, 0.73022893781570593\n36084349405886010308809987247048142151879999305882306169718902, 0.777810637\n810428680311119693945339493753691675945670302006794689942184819812709, 0.82\n849276023042538690428396700476452263279640532871508910845350344109696753782\n66, 0.882477328526228669757698486772395431354193449529466082277853631417758\n5961942936, 0.9399795299915405153402248568618947272920440084137115643604676\n307008419853257788, 1.00122857351893604093217965458142490311824502494352804\n9619445960282439336451516, 1.0664686032469082465446724238467060826602271350\n5450493171046906577618017533485, 1.1359596717401321904472594727959625271540\n69506739201242159983984002811333382739, 1.209978776582131731617034761065124\n311009358614495571372335128166979326800445978, 1.28882096451229946257970625\n3102020998553494397009716401282671347081826473196884, 1.3728005075084582591\n87784036450083092262707343306282981254591926965493411372691]], Dict{Any, An\ny}(:l∞ => BigFloat[3.354354545962993017750167938278129130201240818733894747\n246416797762893693012556e-49, 5.0797777397364385003798873956336475786701551\n6067866884666732578123388975047482e-45, 6.965053307368658446539816666631293\n486902250519752824131061460869466635839790668e-41, 6.9985599579590960027470\n31148778557831077884643242480170494801380170765753974579e-37, 2.76160467425\n7899176583497342905526511107065867988065457455490380825745507598647e-33, 4.\n965060749672954837420128986603252643572639175648660423260171211890675951960\n709e-28, 2.1975104034266099178147026326495605606836593676837803246358016102\n97349872909655e-23], :final => BigFloat[3.354354545962993017750167938278129\n130201240818733894747246416797762893693012556e-49, 5.0797777397364385003798\n8739563364757867015516067866884666732578123388975047482e-45, 6.965053307368\n658446539816666631293486902250519752824131061460869466635839790668e-41, 6.9\n985599579590960027470311487785578310778846432424801704948013801707657539745\n79e-37, 2.76160467425789917658349734290552651110706586798806545745549038082\n5745507598647e-33, 4.965060749672954837420128986603252643572639175648660423\n260171211890675951960709e-28, 2.1975104034266099178147026326495605606836593\n67683780324635801610297349872909655e-23], :l2 => BigFloat[1.557658061895966\n325846207347700821566122250234951867982385249845278493662676944e-49, 2.3604\n11657197547333498547223212880765989953910523198376084992961121455787643313e\n-45, 3.24060760516074676637178554271828070823716806609832930426777898390162\n3487961701e-41, 3.264565979149024498598621687244084221464920048688554495210\n368172485686228822379e-37, 1.2947776667473864852636114197311110560713898649\n84176915402703871046417929063523e-33, 2.35148503019100306142594944698233564\n8801181524332244933545614443786091245762492e-28, 1.061501597814768635894514\n677590712762248364686527596359902826841740549975688161e-23]), 7, Dict(:dts \n=> [0.0009765625, 0.001953125, 0.00390625, 0.0078125, 0.015625, 0.03125, 0.\n0625]), Dict{Any, Any}(:l∞ => 14.293327546103852435000893132848160405565048\n16254374715376150534187461411604701, :final => 14.2933275461038524350008931\n3284816040556504816254374715376150534187461411604701, :l2 => 14.30280974051\n840423232019057634315242594313233119811212889763182960978082577142), [0.000\n9765625, 0.001953125, 0.00390625, 0.0078125, 0.015625, 0.03125, 0.0625])","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"For a view of what's going on, let's plot the simulation results.","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"using Plots\ngr()\nplot(sim)","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"(Image: )","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"This is a clear trend indicating that the convergence is truly Order 14, which is the estimated slope.","category":"page"},{"location":"ode_extras/02-feagin/#Appendix","page":"Feagin's Order 10, 12, and 14 Methods","title":"Appendix","text":"","category":"section"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"tutorials/ode_extras\",\"02-feagin.jmd\")","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"Computer Information:","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"Julia Version 1.6.2\nCommit 1b93d53fc4 (2021-07-14 15:36 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, znver2)\nEnvironment:\n  JULIA_DEPOT_PATH = /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n  JULIA_NUM_THREADS = 16\n","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"Package Information:","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"      Status `/var/lib/buildkite-agent/builds/5-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/ode_extras/Project.toml`\n  [f3b72e0c] DiffEqDevTools v2.27.2\n  [0c46a032] DifferentialEquations v6.17.1\n  [961ee093] ModelingToolkit v5.17.3\n  [76087f3c] NLopt v0.6.2\n  [2774e3e8] NLsolve v4.5.1\n  [429524aa] Optim v1.3.0\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [91a5bcdd] Plots v1.15.2\n  [30cb0354] SciMLTutorials v0.9.0\n  [37e2e46d] LinearAlgebra\n  [2f01184e] SparseArrays","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"And the full manifest:","category":"page"},{"location":"ode_extras/02-feagin/","page":"Feagin's Order 10, 12, and 14 Methods","title":"Feagin's Order 10, 12, and 14 Methods","text":"      Status `/var/lib/buildkite-agent/builds/5-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/ode_extras/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.16.0\n  [1520ce14] AbstractTrees v0.3.4\n  [79e6a3ab] Adapt v3.3.0\n  [ec485272] ArnoldiMethod v0.1.0\n  [4fba245c] ArrayInterface v3.1.15\n  [4c555306] ArrayLayouts v0.7.0\n  [aae01518] BandedMatrices v0.16.9\n  [6e4b80f9] BenchmarkTools v1.0.0\n  [764a87c0] BoundaryValueDiffEq v2.7.1\n  [fa961155] CEnum v0.4.1\n  [00ebfdb7] CSTParser v2.5.0\n  [d360d2e6] ChainRulesCore v0.9.44\n  [b630d9fa] CheapThreads v0.2.5\n  [523fee87] CodecBzip2 v0.7.2\n  [944b1d66] CodecZlib v0.7.0\n  [35d6a980] ColorSchemes v3.12.1\n  [3da002f7] ColorTypes v0.11.0\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [a80b9123] CommonMark v0.8.1\n  [38540f10] CommonSolve v0.2.0\n  [bbf7d656] CommonSubexpressions v0.3.0\n  [34da2185] Compat v3.30.0\n  [8f4d0f93] Conda v1.5.2\n  [187b0558] ConstructionBase v1.2.1\n  [d38c429a] Contour v0.5.7\n  [a8cc5b0e] Crayons v4.0.4\n  [9a962f9c] DataAPI v1.6.0\n  [864edb3b] DataStructures v0.18.9\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [bcd4f6db] DelayDiffEq v5.31.0\n  [2b5f629d] DiffEqBase v6.62.2\n  [459566f4] DiffEqCallbacks v2.16.1\n  [f3b72e0c] DiffEqDevTools v2.27.2\n  [5a0ffddc] DiffEqFinancial v2.4.0\n  [c894b116] DiffEqJump v6.14.2\n  [77a26b50] DiffEqNoiseProcess v5.7.3\n  [055956cb] DiffEqPhysics v3.9.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.0.2\n  [0c46a032] DifferentialEquations v6.17.1\n  [c619ae07] DimensionalPlotRecipes v1.2.0\n  [b4f34e82] Distances v0.10.3\n  [31c24e10] Distributions v0.24.18\n  [ffbed154] DocStringExtensions v0.8.4\n  [e30172f5] Documenter v0.26.3\n  [d4d017d3] ExponentialUtilities v1.8.4\n  [e2ba6199] ExprTools v0.1.3\n  [c87230d0] FFMPEG v0.4.0\n  [7034ab61] FastBroadcast v0.1.8\n  [9aa1b823] FastClosures v0.3.2\n  [1a297f60] FillArrays v0.11.7\n  [6a86dc24] FiniteDiff v2.8.0\n  [53c48c17] FixedPointNumbers v0.8.4\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.18\n  [069b7b12] FunctionWrappers v1.1.2\n  [28b8d3ca] GR v0.57.4\n  [5c1252a2] GeometryBasics v0.3.12\n  [42e2da0e] Grisu v1.0.2\n  [cd3eb016] HTTP v0.9.9\n  [eafb193a] Highlights v0.4.5\n  [0e44f5e4] Hwloc v2.0.0\n  [7073ff75] IJulia v1.23.2\n  [b5f81e59] IOCapture v0.1.1\n  [615f187c] IfElse v0.1.0\n  [d25df0c9] Inflate v0.1.2\n  [83e8ac13] IniFile v0.5.0\n  [c8e1da08] IterTools v1.3.0\n  [42fd0dbc] IterativeSolvers v0.9.1\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.3.0\n  [682c06a0] JSON v0.21.1\n  [7d188eb4] JSONSchema v0.3.3\n  [98e50ef6] JuliaFormatter v0.13.7\n  [b964fa9f] LaTeXStrings v1.2.1\n  [2ee39098] LabelledArrays v1.6.1\n  [23fbe1c1] Latexify v0.15.5\n  [093fc24a] LightGraphs v1.3.5\n  [d3d80556] LineSearches v7.1.1\n  [2ab3a3ac] LogExpFunctions v0.2.4\n  [bdcacae8] LoopVectorization v0.12.23\n  [1914dd2f] MacroTools v0.5.6\n  [b8f27783] MathOptInterface v0.9.22\n  [fdba3010] MathProgBase v0.7.8\n  [739be429] MbedTLS v1.0.3\n  [442fdcdd] Measures v0.3.1\n  [e1d29d7a] Missings v1.0.0\n  [961ee093] ModelingToolkit v5.17.3\n  [46d2c3a1] MuladdMacro v0.2.2\n  [f9640e96] MultiScaleArrays v1.8.1\n  [ffc61752] Mustache v1.0.10\n  [d8a4904e] MutableArithmetics v0.2.19\n  [d41bc354] NLSolversBase v7.8.0\n  [76087f3c] NLopt v0.6.2\n  [2774e3e8] NLsolve v4.5.1\n  [77ba4419] NaNMath v0.3.5\n  [8913a72c] NonlinearSolve v0.3.8\n  [6fe1bfb0] OffsetArrays v1.9.0\n  [429524aa] Optim v1.3.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [90014a1f] PDMats v0.11.0\n  [65888b18] ParameterizedFunctions v5.10.0\n  [d96e819e] Parameters v0.12.2\n  [69de0a69] Parsers v1.1.0\n  [ccf2f8ad] PlotThemes v2.0.1\n  [995b91a9] PlotUtils v1.0.10\n  [91a5bcdd] Plots v1.15.2\n  [e409e4f3] PoissonRandom v0.4.0\n  [f517fe37] Polyester v0.3.1\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [21216c6a] Preferences v1.2.2\n  [1fd47b50] QuadGK v2.4.1\n  [74087812] Random123 v1.3.1\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.4.0\n  [3cdcf5f2] RecipesBase v1.1.1\n  [01d81517] RecipesPipeline v0.3.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [f2c3362d] RecursiveFactorization v0.1.12\n  [189a3867] Reexport v1.0.0\n  [ae029012] Requires v1.1.3\n  [ae5879a3] ResettableStacks v1.1.0\n  [79098fc4] Rmath v0.7.0\n  [47965b36] RootedTrees v1.0.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.2\n  [476501e8] SLEEFPirates v0.6.20\n  [1bc83da4] SafeTestsets v0.0.1\n  [0bca4576] SciMLBase v1.13.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [6c6a2e73] Scratch v1.0.3\n  [efcf1570] Setfield v0.7.0\n  [992d4aef] Showoff v1.0.3\n  [699a6c99] SimpleTraits v0.9.3\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.0\n  [47a9eef4] SparseDiffTools v1.13.2\n  [276daf66] SpecialFunctions v1.4.1\n  [aedffcd0] Static v0.2.4\n  [90137ffa] StaticArrays v1.2.0\n  [82ae8749] StatsAPI v1.0.0\n  [2913bbd2] StatsBase v0.33.8\n  [4c63d2b9] StatsFuns v0.9.8\n  [9672c7b4] SteadyStateDiffEq v1.6.2\n  [789caeaf] StochasticDiffEq v6.34.1\n  [7792a7ef] StrideArraysCore v0.1.11\n  [09ab397b] StructArrays v0.5.1\n  [c3572dad] Sundials v4.4.3\n  [d1185830] SymbolicUtils v0.11.2\n  [0c5d862f] Symbolics v0.1.25\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.4.2\n  [8290d209] ThreadingUtilities v0.4.4\n  [a759f4b9] TimerOutputs v0.5.9\n  [0796e94c] Tokenize v0.5.16\n  [3bb67fe8] TranscodingStreams v0.9.5\n  [a2a6695c] TreeViews v0.3.0\n  [5c2747f8] URIs v1.3.0\n  [3a884ed6] UnPack v1.0.2\n  [1986cc42] Unitful v1.7.0\n  [3d5dd08c] VectorizationBase v0.20.11\n  [81def892] VersionParsing v1.2.0\n  [19fa3120] VertexSafeGraphs v0.1.2\n  [44d3d7a6] Weave v0.10.8\n  [ddb6d928] YAML v0.4.6\n  [c2297ded] ZMQ v1.2.1\n  [a5390f91] ZipFile v0.9.3\n  [700de1a5] ZygoteRules v0.2.1\n  [6e34b625] Bzip2_jll v1.0.6+5\n  [83423d85] Cairo_jll v1.16.0+6\n  [5ae413db] EarCut_jll v2.1.5+1\n  [2e619515] Expat_jll v2.2.10+0\n  [b22a6f82] FFMPEG_jll v4.3.1+4\n  [a3f928ae] Fontconfig_jll v2.13.1+14\n  [d7e528f0] FreeType2_jll v2.10.1+5\n  [559328eb] FriBidi_jll v1.0.5+6\n  [0656b61e] GLFW_jll v3.3.4+0\n  [d2c73de3] GR_jll v0.57.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.1+0\n  [e33a78d0] Hwloc_jll v2.4.1+0\n  [aacddb02] JpegTurbo_jll v2.0.1+3\n  [c1c5ebd0] LAME_jll v3.100.0+3\n  [dd4b983a] LZO_jll v2.10.1+0\n  [dd192d2f] LibVPX_jll v1.9.0+1\n  [e9f186c6] Libffi_jll v3.2.2+0\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+0\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.1.0+2\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [079eb43e] NLopt_jll v2.7.0+0\n  [e7412a2a] Ogg_jll v1.3.4+2\n  [458c3c95] OpenSSL_jll v1.1.1+6\n  [efe28fd5] OpenSpecFun_jll v0.5.4+0\n  [91d4177d] Opus_jll v1.3.1+3\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.2+0\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.0+1\n  [a2964d1f] Wayland_jll v1.17.0+4\n  [2381bf8a] Wayland_protocols_jll v1.18.0+4\n  [02c8fc9c] XML2_jll v2.9.12+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.2+6\n  [3161d3a3] Zstd_jll v1.5.0+0\n  [0ac62f75] libass_jll v0.14.0+4\n  [f638f0a6] libfdk_aac_jll v0.1.6+4\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.6+6\n  [1270edf5] x264_jll v2020.7.14+2\n  [dfaa095f] x265_jll v3.0.0+3\n  [d8fb68d0] xkbcommon_jll v0.9.1+5\n  [0dad84c5] ArgTools\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [b27032c2] LibCURL\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions\n  [44cfe95a] Pkg\n  [de0858da] Printf\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML\n  [a4e569a6] Tar\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll\n  [deac9b47] LibCURL_jll\n  [29816b5a] LibSSH2_jll\n  [c8ffd9c3] MbedTLS_jll\n  [14a3606d] MozillaCACerts_jll\n  [4536629a] OpenBLAS_jll\n  [bea87d4a] SuiteSparse_jll\n  [83775a58] Zlib_jll\n  [8e850ede] nghttp2_jll\n  [3f19e933] p7zip_jll","category":"page"},{"location":"type_handling/03-unitful/#Unit-Checked-Arithmetic-via-Unitful.jl","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"","category":"section"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Units and dimensional analysis are standard tools across the sciences for checking the correctness of your equation. However, most ODE solvers only allow for the equation to be in dimensionless form, leaving it up to the user to both convert the equation to a dimensionless form, punch in the equations, and hopefully not make an error along the way.","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"DifferentialEquations.jl allows for one to use Unitful.jl to have unit-checked arithmetic natively in the solvers. Given the dispatch implementation of the Unitful, this has little overhead.","category":"page"},{"location":"type_handling/03-unitful/#Using-Unitful","page":"Unit Checked Arithmetic via Unitful.jl","title":"Using Unitful","text":"","category":"section"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"To use Unitful, you need to have the package installed. Then you can add units to your variables. For example:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"using Unitful\nt = 1.0u\"s\"","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"1.0 s","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Notice that t is a variable with units in seconds. If we make another value with seconds, they can add","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"t2 = 1.02u\"s\"\nt+t2","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"2.02 s","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"and they can multiply:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"t*t2","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"1.02 s^2","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"You can even do rational roots:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"sqrt(t)","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"1.0 s^1/2","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Many operations work. These operations will check to make sure units are correct, and will throw an error for incorrect operations:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"t + sqrt(t)","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Error: DimensionError: 1.0 s and 1.0 s^1/2 are not dimensionally compatible.","category":"page"},{"location":"type_handling/03-unitful/#Using-Unitful-with-DifferentialEquations.jl","page":"Unit Checked Arithmetic via Unitful.jl","title":"Using Unitful with DifferentialEquations.jl","text":"","category":"section"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Just like with other number systems, you can choose the units for your numbers by simply specifying the units of the initial condition and the timestep. For example, to solve the linear ODE where the variable has units of Newton's and t is in Seconds, we would use:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"using DifferentialEquations\nf = (y,p,t) -> 0.5*y\nu0 = 1.5u\"N\"\nprob = ODEProblem(f,u0,(0.0u\"s\",1.0u\"s\"))\nsol = solve(prob,Tsit5())","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Error: DimensionError: N s^-1 and 0.75 N are not dimensionally compatible.","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Notice that we recieved a unit mismatch error. This is correctly so! Remember that for an ODE:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"fracdydt = f(ty)","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"we must have that f is a rate, i.e. f is a change in y per unit time. So we need to fix the units of f in our example to be N/s. Notice that we then do not receive an error if we do the following:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"f = (y,p,t) -> 0.5*y/3.0u\"s\"\nprob = ODEProblem(f,u0,(0.0u\"s\",1.0u\"s\"))\nsol = solve(prob,Tsit5())","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"retcode: Success\nInterpolation: specialized 4th order \"free\" interpolation\nt: 3-element Array{Unitful.Quantity{Float64,𝐓,Unitful.FreeUnits{(s,),𝐓,nothing}},1}:\n                 0.0 s\n 0.14311598261241779 s\n                 1.0 s\nu: 3-element Array{Unitful.Quantity{Float64,𝐋 𝐌 𝐓^-2,Unitful.FreeUnits{(N,),𝐋 𝐌 𝐓^-2,nothing}},1}:\n                1.5 N\n 1.5362091208988309 N\n 1.7720406194871123 N","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"This gives a a normal solution object. Notice that the values are all with the correct units:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"print(sol[:])","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Unitful.Quantity{Float64,𝐋 𝐌 𝐓^-2,Unitful.FreeUnits{(N,),𝐋 𝐌 𝐓^-2,nothing}}[1.5 N, 1.5362091208988309 N, 1.7720406194871123 N]","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"We can plot the solution by removing the units:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"using Plots\ngr()\nplot(ustrip(sol.t),ustrip(sol[:]),lw=3)","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"(Image: )","category":"page"},{"location":"type_handling/03-unitful/#Appendix","page":"Unit Checked Arithmetic via Unitful.jl","title":"Appendix","text":"","category":"section"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"This tutorial is part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl.  For more information on doing scientific machine learning (SciML) with open source software, check out https://sciml.ai/.","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"type_handling\",\"03-unitful.jmd\")","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Computer Information:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Julia Version 1.4.2\nCommit 44fa15b150* (2020-05-23 18:35 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Core(TM) i7-9700K CPU @ 3.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-8.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_LOAD_PATH = /builds/JuliaGPU/DiffEqTutorials.jl:\n  JULIA_DEPOT_PATH = /builds/JuliaGPU/DiffEqTutorials.jl/.julia\n  JULIA_CUDA_MEMORY_LIMIT = 2147483648\n  JULIA_NUM_THREADS = 8\n","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Package Information:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Status `/builds/JuliaGPU/DiffEqTutorials.jl/tutorials/type_handling/Project.toml`\n[7e558dbc-694d-5a72-987c-6f4ebed21442] ArbNumerics 1.2.1\n[55939f99-70c6-5e9b-8bb0-5071ed7d61fd] DecFP 1.0.0\n[abce61dc-4473-55a0-ba07-351d65e31d42] Decimals 0.4.1\n[0c46a032-eb83-5123-abaf-570d42b7fbaa] DifferentialEquations 6.15.0\n[497a8b3b-efae-58df-a0af-a86822472b78] DoubleFloats 1.1.13\n[eff96d63-e80a-5855-80a2-b1b0885c5ab7] Measurements 2.3.0\n[1dea7af3-3e70-54e6-95c3-0bf5283fa5ed] OrdinaryDiffEq 5.43.0\n[91a5bcdd-55d7-5caf-9e0b-520d859cae80] Plots 1.6.12\n[1986cc42-f94f-5a68-af5c-568840ba703d] Unitful 1.5.0","category":"page"},{"location":"introduction/04-callbacks_and_events/#Callbacks-and-Events","page":"Callbacks and Events","title":"Callbacks and Events","text":"","category":"section"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"In working with a differential equation, our system will evolve through many states. Particular states of the system may be of interest to us, and we say that an ***\"event\"*** is triggered when our system reaches these states. For example, events may include the moment when our system reaches a particular temperature or velocity. We ***handle*** these events with ***callbacks***, which tell us what to do once an event has been triggered.","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"These callbacks allow for a lot more than event handling, however. For example, we can use callbacks to achieve high-level behavior like exactly preserve conservation laws and save the trace of a matrix at pre-defined time points. This extra functionality allows us to use the callback system as a modding system for the DiffEq ecosystem's solvers.","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"This tutorial is an introduction to the callback and event handling system in DifferentialEquations.jl, documented in the Event Handling and Callback Functions page of the documentation. We will also introduce you to some of the most widely used callbacks in the Callback Library, which is a library of pre-built mods.","category":"page"},{"location":"introduction/04-callbacks_and_events/#Events-and-Continuous-Callbacks","page":"Callbacks and Events","title":"Events and Continuous Callbacks","text":"","category":"section"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Event handling is done through continuous callbacks. Callbacks take a function, condition, which triggers an affect! when condition == 0. These callbacks are called \"continuous\" because they will utilize rootfinding on the interpolation to find the \"exact\" time point at which the condition takes place and apply the affect! at that time point.","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"***Let's use a bouncing ball as a simple system to explain events and callbacks.*** Let's take Newton's model of a ball falling towards the Earth's surface via a gravitational constant g. In this case, the velocity is changing via -g, and position is changing via the velocity. Therefore we receive the system of ODEs:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"using DifferentialEquations, ParameterizedFunctions\nball! = @ode_def BallBounce begin\n  dy =  v\n  dv = -g\nend g","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"(::Main.##WeaveSandBox#432.BallBounce{Main.##WeaveSandBox#432.var\"###Parame\nterizedDiffEqFunction#452\",Main.##WeaveSandBox#432.var\"###ParameterizedTGra\ndFunction#453\",Main.##WeaveSandBox#432.var\"###ParameterizedJacobianFunction\n#454\",Nothing,Nothing,ModelingToolkit.ODESystem}) (generic function with 1 \nmethod)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"We want the callback to trigger when y=0 since that's when the ball will hit the Earth's surface (our event). We do this with the condition:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"function condition(u,t,integrator)\n  u[1]\nend","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"condition (generic function with 1 method)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Recall that the condition will trigger when it evaluates to zero, and here it will evaluate to zero when u[1] == 0, which occurs when v == 0. Now we have to say what we want the callback to do. Callbacks make use of the Integrator Interface. Instead of giving a full description, a quick and usable rundown is:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Values are strored in integrator.u\nTimes are stored in integrator.t\nThe parameters are stored in integrator.p\nintegrator(t) performs an interpolation in the current interval between integrator.tprev and integrator.t (and allows extrapolation)\nUser-defined options (tolerances, etc.) are stored in integrator.opts\nintegrator.sol is the current solution object. Note that integrator.sol.prob is the current problem","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"While there's a lot more on the integrator interface page, that's a working knowledge of what's there.","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"What we want to do with our affect! is to \"make the ball bounce\". Mathematically speaking, the ball bounces when the sign of the velocity flips. As an added behavior, let's also use a small friction constant to dampen the ball's velocity. This way only a percentage of the velocity will be retained when the event is triggered and the callback is used.  We'll define this behavior in the affect! function:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"function affect!(integrator)\n    integrator.u[2] = -integrator.p[2] * integrator.u[2]\nend","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"affect! (generic function with 1 method)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"integrator.u[2] is the second value of our model, which is v or velocity, and integrator.p[2], is our friction coefficient.","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Therefore affect! can be read as follows: affect! will take the current value of velocity, and multiply it -1 multiplied by our friction coefficient. Therefore the ball will change direction and its velocity will dampen when affect! is called.","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Now let's build the ContinuousCallback:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"bounce_cb = ContinuousCallback(condition,affect!)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"DiffEqBase.ContinuousCallback{typeof(Main.##WeaveSandBox#432.condition),typ\neof(Main.##WeaveSandBox#432.affect!),typeof(Main.##WeaveSandBox#432.affect!\n),typeof(DiffEqBase.INITIALIZE_DEFAULT),Float64,Int64,Nothing,Int64}(Main.#\n#WeaveSandBox#432.condition, Main.##WeaveSandBox#432.affect!, Main.##WeaveS\nandBox#432.affect!, DiffEqBase.INITIALIZE_DEFAULT, nothing, true, 10, Bool[\n1, 1], 1, 2.220446049250313e-15, 0)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Now let's make an ODEProblem which has our callback:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"u0 = [50.0,0.0]\ntspan = (0.0,15.0)\np = (9.8,0.9)\nprob = ODEProblem(ball!,u0,tspan,p,callback=bounce_cb)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"ODEProblem with uType Array{Float64,1} and tType Float64. In-place: true\ntimespan: (0.0, 15.0)\nu0: [50.0, 0.0]","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Notice that we chose a friction constant of 0.9. Now we can solve the problem and plot the solution as we normally would:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"sol = solve(prob,Tsit5())\nusing Plots; gr()\nplot(sol)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"(Image: )","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"and tada, the ball bounces! Notice that the ContinuousCallback is using the interpolation to apply the effect \"exactly\" when v == 0. This is crucial for model correctness, and thus when this property is needed a ContinuousCallback should be used.","category":"page"},{"location":"introduction/04-callbacks_and_events/#Exercise-1","page":"Callbacks and Events","title":"Exercise 1","text":"","category":"section"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"In our example we used a constant coefficient of friction, but if we are bouncing the ball in the same place we may be smoothing the surface (say, squishing the grass), causing there to be less friction after each bounce. In this more advanced model, we want the friction coefficient at the next bounce to be sqrt(friction) from the previous bounce (since friction < 1, sqrt(friction) > friction and sqrt(friction) < 1).","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Hint: there are many ways to implement this. One way to do it is to make p a Vector and mutate the friction coefficient in the affect!.","category":"page"},{"location":"introduction/04-callbacks_and_events/#Discrete-Callbacks","page":"Callbacks and Events","title":"Discrete Callbacks","text":"","category":"section"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"A discrete callback checks a condition after every integration step and, if true, it will apply an affect!. For example, let's say that at time t=2 we want to include that a kid kicked the ball, adding 20 to the current velocity. This kind of situation, where we want to add a specific behavior which does not require rootfinding, is a good candidate for a DiscreteCallback. In this case, the condition is a boolean for whether to apply the affect!, so:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"function condition_kick(u,t,integrator)\n    t == 2\nend","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"condition_kick (generic function with 1 method)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"We want the kick to occur at t=2, so we check for that time point. When we are at this time point, we want to do:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"function affect_kick!(integrator)\n    integrator.u[2] += 50\nend","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"affect_kick! (generic function with 1 method)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Now we build the problem as before:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"kick_cb = DiscreteCallback(condition_kick,affect_kick!)\nu0 = [50.0,0.0]\ntspan = (0.0,10.0)\np = (9.8,0.9)\nprob = ODEProblem(ball!,u0,tspan,p,callback=kick_cb)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"ODEProblem with uType Array{Float64,1} and tType Float64. In-place: true\ntimespan: (0.0, 10.0)\nu0: [50.0, 0.0]","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Note that, since we are requiring our effect at exactly the time t=2, we need to tell the integration scheme to step at exactly t=2 to apply this callback. This is done via the option tstops, which is like saveat but means \"stop at these values\".","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"sol = solve(prob,Tsit5(),tstops=[2.0])\nplot(sol)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"(Image: )","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Note that this example could've been done with a ContinuousCallback by checking the condition t-2.","category":"page"},{"location":"introduction/04-callbacks_and_events/#Merging-Callbacks-with-Callback-Sets","page":"Callbacks and Events","title":"Merging Callbacks with Callback Sets","text":"","category":"section"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"In some cases you may want to merge callbacks to build up more complex behavior. In our previous result, notice that the model is unphysical because the ball goes below zero! What we really need to do is add the bounce callback together with the kick. This can be achieved through the CallbackSet.","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"cb = CallbackSet(bounce_cb,kick_cb)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"DiffEqBase.CallbackSet{Tuple{DiffEqBase.ContinuousCallback{typeof(Main.##We\naveSandBox#432.condition),typeof(Main.##WeaveSandBox#432.affect!),typeof(Ma\nin.##WeaveSandBox#432.affect!),typeof(DiffEqBase.INITIALIZE_DEFAULT),Float6\n4,Int64,Nothing,Int64}},Tuple{DiffEqBase.DiscreteCallback{typeof(Main.##Wea\nveSandBox#432.condition_kick),typeof(Main.##WeaveSandBox#432.affect_kick!),\ntypeof(DiffEqBase.INITIALIZE_DEFAULT)}}}((DiffEqBase.ContinuousCallback{typ\neof(Main.##WeaveSandBox#432.condition),typeof(Main.##WeaveSandBox#432.affec\nt!),typeof(Main.##WeaveSandBox#432.affect!),typeof(DiffEqBase.INITIALIZE_DE\nFAULT),Float64,Int64,Nothing,Int64}(Main.##WeaveSandBox#432.condition, Main\n.##WeaveSandBox#432.affect!, Main.##WeaveSandBox#432.affect!, DiffEqBase.IN\nITIALIZE_DEFAULT, nothing, true, 10, Bool[1, 1], 1, 2.220446049250313e-15, \n0),), (DiffEqBase.DiscreteCallback{typeof(Main.##WeaveSandBox#432.condition\n_kick),typeof(Main.##WeaveSandBox#432.affect_kick!),typeof(DiffEqBase.INITI\nALIZE_DEFAULT)}(Main.##WeaveSandBox#432.condition_kick, Main.##WeaveSandBox\n#432.affect_kick!, DiffEqBase.INITIALIZE_DEFAULT, Bool[1, 1]),))","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"A CallbackSet merges their behavior together. The logic is as follows. In a given interval, if there are multiple continuous callbacks that would trigger, only the one that triggers at the earliest time is used. The time is pulled back to where that continuous callback is triggered, and then the DiscreteCallbacks in the callback set are called in order.","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"u0 = [50.0,0.0]\ntspan = (0.0,15.0)\np = (9.8,0.9)\nprob = ODEProblem(ball!,u0,tspan,p,callback=cb)\nsol = solve(prob,Tsit5(),tstops=[2.0])\nplot(sol)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"(Image: )","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Notice that we have now merged the behaviors. We can then nest this as deep as we like.","category":"page"},{"location":"introduction/04-callbacks_and_events/#Exercise-2","page":"Callbacks and Events","title":"Exercise 2","text":"","category":"section"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Add to the model a linear wind with resistance that changes the acceleration to -g + k*v after t=10. Do so by adding another parameter and allowing it to be zero until a specific time point where a third callback triggers the change.","category":"page"},{"location":"introduction/04-callbacks_and_events/#Integration-Termination-and-Directional-Handling","page":"Callbacks and Events","title":"Integration Termination and Directional Handling","text":"","category":"section"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Let's look at another model now: the model of the Harmonic Oscillator. We can write this as:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"u0 = [1.,0.]\nharmonic! = @ode_def HarmonicOscillator begin\n   dv = -x\n   dx = v\nend\ntspan = (0.0,10.0)\nprob = ODEProblem(harmonic!,u0,tspan)\nsol = solve(prob)\nplot(sol)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"(Image: )","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Let's instead stop the integration when a condition is met. From the Integrator Interface stepping controls we see that terminate!(integrator) will cause the integration to end. So our new affect! is simply:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"function terminate_affect!(integrator)\n    terminate!(integrator)\nend","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"terminate_affect! (generic function with 1 method)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Let's first stop the integration when the particle moves back to x=0. This means we want to use the condition:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"function terminate_condition(u,t,integrator)\n    u[2]\nend\nterminate_cb = ContinuousCallback(terminate_condition,terminate_affect!)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"DiffEqBase.ContinuousCallback{typeof(Main.##WeaveSandBox#432.terminate_cond\nition),typeof(Main.##WeaveSandBox#432.terminate_affect!),typeof(Main.##Weav\neSandBox#432.terminate_affect!),typeof(DiffEqBase.INITIALIZE_DEFAULT),Float\n64,Int64,Nothing,Int64}(Main.##WeaveSandBox#432.terminate_condition, Main.#\n#WeaveSandBox#432.terminate_affect!, Main.##WeaveSandBox#432.terminate_affe\nct!, DiffEqBase.INITIALIZE_DEFAULT, nothing, true, 10, Bool[1, 1], 1, 2.220\n446049250313e-15, 0)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Note that instead of adding callbacks to the problem, we can also add them to the solve command. This will automatically form a CallbackSet with any problem-related callbacks and naturally allows you to distinguish between model features and integration controls.","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"sol = solve(prob,callback=terminate_cb)\nplot(sol)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"(Image: )","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Notice that the harmonic oscilator's true solution here is sin and cosine, and thus we would expect this return to zero to happen at t=π:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"sol.t[end]","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"3.1415902497630053","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"This is one way to approximate π! Lower tolerances and arbitrary precision numbers can make this more exact, but let's not look at that. Instead, what if we wanted to halt the integration after exactly one cycle? To do so we would need to ignore the first zero-crossing. Luckily in these types of scenarios there's usually a structure to the problem that can be exploited. Here, we only want to trigger the affect! when crossing from positive to negative, and not when crossing from negative to positive. In other words, we want our affect! to only occur on upcrossings.","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"If the ContinuousCallback constructor is given a single affect!, it will occur on both upcrossings and downcrossings. If there are two affect!s given, then the first is for upcrossings and the second is for downcrossings. An affect! can be ignored by using nothing. Together, the \"upcrossing-only\" version of the effect means that the first affect! is what we defined above and the second is nothing. Therefore we want:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"terminate_upcrossing_cb = ContinuousCallback(terminate_condition,terminate_affect!,nothing)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"DiffEqBase.ContinuousCallback{typeof(Main.##WeaveSandBox#432.terminate_cond\nition),typeof(Main.##WeaveSandBox#432.terminate_affect!),Nothing,typeof(Dif\nfEqBase.INITIALIZE_DEFAULT),Float64,Int64,Nothing,Int64}(Main.##WeaveSandBo\nx#432.terminate_condition, Main.##WeaveSandBox#432.terminate_affect!, nothi\nng, DiffEqBase.INITIALIZE_DEFAULT, nothing, true, 10, Bool[1, 1], 1, 2.2204\n46049250313e-15, 0)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Which gives us:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"sol = solve(prob,callback=terminate_upcrossing_cb)\nplot(sol)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"(Image: )","category":"page"},{"location":"introduction/04-callbacks_and_events/#Callback-Library","page":"Callbacks and Events","title":"Callback Library","text":"","category":"section"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"As you can see, callbacks can be very useful and through CallbackSets we can merge together various behaviors. Because of this utility, there is a library of pre-built callbacks known as the Callback Library. We will walk through a few examples where these callbacks can come in handy.","category":"page"},{"location":"introduction/04-callbacks_and_events/#Manifold-Projection","page":"Callbacks and Events","title":"Manifold Projection","text":"","category":"section"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"One callback is the manifold projection callback. Essentially, you can define any manifold g(sol)=0 which the solution must live on, and cause the integration to project to that manifold after every step. As an example, let's see what happens if we naively run the harmonic oscillator for a long time:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"tspan = (0.0,10000.0)\nprob = ODEProblem(harmonic!,u0,tspan)\nsol = solve(prob)\ngr(fmt=:png) # Make it a PNG instead of an SVG since there's a lot of points!\nplot(sol,vars=(1,2))","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"(Image: )","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"plot(sol,vars=(0,1),denseplot=false)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"(Image: )","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Notice that what's going on is that the numerical solution is drifting from the true solution over this long time scale. This is because the integrator is not conserving energy.","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"plot(sol.t,[u[2]^2 + u[1]^2 for u in sol.u]) # Energy ~ x^2 + v^2","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"(Image: )","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Some integration techniques like symplectic integrators are designed to mitigate this issue, but instead let's tackle the problem by enforcing conservation of energy. To do so, we define our manifold as the one where energy equals 1 (since that holds in the initial condition), that is:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"function g(resid,u,p,t)\n  resid[1] = u[2]^2 + u[1]^2 - 1\n  resid[2] = 0\nend","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"g (generic function with 1 method)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Here the residual measures how far from our desired energy we are, and the number of conditions matches the size of our system (we ignored the second one by making the residual 0). Thus we define a ManifoldProjection callback and add that to the solver:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"cb = ManifoldProjection(g)\nsol = solve(prob,callback=cb)\nplot(sol,vars=(1,2))","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"(Image: )","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"plot(sol,vars=(0,1),denseplot=false)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"(Image: )","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Now we have \"perfect\" energy conservation, where if it's ever violated too much the solution will get projected back to energy=1.","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"u1,u2 = sol[500]\nu2^2 + u1^2","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"1.0000426288541124","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"While choosing different integration schemes and using lower tolerances can achieve this effect as well, this can be a nice way to enforce physical constraints and is thus used in many disciplines like molecular dynamics. Another such domain constraining callback is the PositiveCallback() which can be used to enforce positivity of the variables.","category":"page"},{"location":"introduction/04-callbacks_and_events/#SavingCallback","page":"Callbacks and Events","title":"SavingCallback","text":"","category":"section"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"The SavingCallback can be used to allow for special saving behavior. Let's take a linear ODE define on a system of 1000x1000 matrices:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"prob = ODEProblem((du,u,p,t)->du.=u,rand(1000,1000),(0.0,1.0))","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"ODEProblem with uType Array{Float64,2} and tType Float64. In-place: true\ntimespan: (0.0, 1.0)\nu0: [0.9879931455893609 0.8459514795879628 … 0.12437660939897444 0.60144899\n7240285; 0.5075186459948859 0.5570664700161223 … 0.9830110970851273 0.93296\n78540098196; … ; 0.6094372577262306 0.9886923913157719 … 0.6897194729548028\n 0.9010207091690918; 0.4125617049501118 0.04365446235919235 … 0.16143622331\n469043 0.29661794248884554]","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"In fields like quantum mechanics you may only want to know specific properties of the solution such as the trace or the norm of the matrix. Saving all of the 1000x1000 matrices can be a costly way to get this information! Instead, we can use the SavingCallback to save the trace and norm at specified times. To do so, we first define our SavedValues cache. Our time is in terms of Float64, and we want to save tuples of Float64s (one for the trace and one for the norm), and thus we generate the cache as:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"saved_values = SavedValues(Float64, Tuple{Float64,Float64})","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"SavedValues{tType=Float64, savevalType=Tuple{Float64,Float64}}\nt:\nFloat64[]\nsaveval:\nTuple{Float64,Float64}[]","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Now we define the SavingCallback by giving it a function of (u,p,t,integrator) that returns the values to save, and the cache:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"using LinearAlgebra\ncb = SavingCallback((u,t,integrator)->(tr(u),norm(u)), saved_values)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"DiffEqBase.DiscreteCallback{DiffEqCallbacks.var\"#30#31\",DiffEqCallbacks.Sav\ningAffect{Main.##WeaveSandBox#432.var\"#17#18\",Float64,Tuple{Float64,Float64\n},DataStructures.BinaryHeap{Float64,DataStructures.LessThan},Array{Float64,\n1}},typeof(DiffEqCallbacks.saving_initialize)}(DiffEqCallbacks.var\"#30#31\"(\n), DiffEqCallbacks.SavingAffect{Main.##WeaveSandBox#432.var\"#17#18\",Float64\n,Tuple{Float64,Float64},DataStructures.BinaryHeap{Float64,DataStructures.Le\nssThan},Array{Float64,1}}(Main.##WeaveSandBox#432.var\"#17#18\"(), SavedValue\ns{tType=Float64, savevalType=Tuple{Float64,Float64}}\nt:\nFloat64[]\nsaveval:\nTuple{Float64,Float64}[], DataStructures.BinaryHeap{Float64,DataStructures.\nLessThan}(DataStructures.LessThan(), Float64[]), Float64[], true, true, tru\ne, 0), DiffEqCallbacks.saving_initialize, Bool[0, 0])","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Here we take u and save (tr(u),norm(u)). When we solve with this callback:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"sol = solve(prob, Tsit5(), callback=cb, save_everystep=false, save_start=false, save_end = false) # Turn off normal saving","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"retcode: Success\nInterpolation: 1st order linear\nt: 0-element Array{Float64,1}\nu: 0-element Array{Array{Float64,2},1}","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Our values are stored in our saved_values variable:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"saved_values.t","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"5-element Array{Float64,1}:\n 0.0\n 0.10012909234078712\n 0.34839012956458915\n 0.6837368053160041\n 1.0","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"saved_values.saveval","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"5-element Array{Tuple{Float64,Float64},1}:\n (493.8130627293116, 577.574819350342)\n (545.8182923190569, 638.40130077138)\n (699.626875729263, 818.2992651684409)\n (978.375758562294, 1144.3302023748365)\n (1342.3230160768928, 1570.0110670126246)","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"By default this happened only at the solver's steps. But the SavingCallback has similar controls as the integrator. For example, if we want to save at every 0.1 seconds, we do can so using saveat:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"saved_values = SavedValues(Float64, Tuple{Float64,Float64}) # New cache\ncb = SavingCallback((u,t,integrator)->(tr(u),norm(u)), saved_values, saveat = 0.0:0.1:1.0)\nsol = solve(prob, Tsit5(), callback=cb, save_everystep=false, save_start=false, save_end = false) # Turn off normal saving","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"retcode: Success\nInterpolation: 1st order linear\nt: 0-element Array{Float64,1}\nu: 0-element Array{Array{Float64,2},1}","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"saved_values.t","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"11-element Array{Float64,1}:\n 0.0\n 0.1\n 0.2\n 0.3\n 0.4\n 0.5\n 0.6\n 0.7\n 0.8\n 0.9\n 1.0","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"saved_values.saveval","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"11-element Array{Tuple{Float64,Float64},1}:\n (493.8130627293116, 577.574819350342)\n (545.7478359058158, 638.3188933722616)\n (603.1446583851525, 705.4515026061309)\n (666.5778718850487, 779.6444099899865)\n (736.6826568938942, 861.6405368507976)\n (814.1600583919651, 952.2598411005755)\n (899.7857160671499, 1052.4095282922406)\n (994.4173917015307, 1163.0928558195844)\n (1099.001269598267, 1285.4165020376604)\n (1214.5837550613833, 1420.6043660290525)\n (1342.3230160768928, 1570.0110670126246)","category":"page"},{"location":"introduction/04-callbacks_and_events/#Exercise-3","page":"Callbacks and Events","title":"Exercise 3","text":"","category":"section"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Go back to the Harmonic oscillator. Use the SavingCallback to save an array for the energy over time, and do this both with and without the ManifoldProjection. Plot the results to see the difference the projection makes.","category":"page"},{"location":"introduction/04-callbacks_and_events/#Appendix","page":"Callbacks and Events","title":"Appendix","text":"","category":"section"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"This tutorial is part of the DiffEqTutorials.jl repository, found at: https://github.com/JuliaDiffEq/DiffEqTutorials.jl","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"using DiffEqTutorials\nDiffEqTutorials.weave_file(\"introduction\",\"04-callbacks_and_events.jmd\")","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Computer Information:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Julia Version 1.4.2\nCommit 44fa15b150* (2020-05-23 18:35 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Core(TM) i7-9700K CPU @ 3.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-8.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_DEPOT_PATH = /builds/JuliaGPU/DiffEqTutorials.jl/.julia\n  JULIA_CUDA_MEMORY_LIMIT = 536870912\n  JULIA_PROJECT = @.\n  JULIA_NUM_THREADS = 4\n","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Package Information:","category":"page"},{"location":"introduction/04-callbacks_and_events/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Status `/builds/JuliaGPU/DiffEqTutorials.jl/tutorials/introduction/Project.toml`\n[6e4b80f9-dd63-53aa-95a3-0cdb28fa8baf] BenchmarkTools 0.5.0\n[0c46a032-eb83-5123-abaf-570d42b7fbaa] DifferentialEquations 6.14.0\n[65888b18-ceab-5e60-b2b9-181511a3b968] ParameterizedFunctions 5.3.0\n[91a5bcdd-55d7-5caf-9e0b-520d859cae80] Plots 1.4.3\n[90137ffa-7385-5640-81b9-e52037218182] StaticArrays 0.12.3\n[c3572dad-4567-51f8-b174-8c6c989267f4] Sundials 4.2.3\n[37e2e46d-f89d-539d-b4ee-838fcccc9c8e] LinearAlgebra","category":"page"},{"location":"models/07-outer_solar_system/#The-Outer-Solar-System","page":"The Outer Solar System","title":"The Outer Solar System","text":"","category":"section"},{"location":"models/07-outer_solar_system/#Data","page":"The Outer Solar System","title":"Data","text":"","category":"section"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"The chosen units are: masses relative to the sun, so that the sun has mass 1. We have taken m_0 = 100000597682 to take account of the inner planets. Distances are in astronomical units , times in earth days, and the gravitational constant is thus G = 295912208286 cdot 10^-4.","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"planet mass initial position initial velocity\nJupiter m_1 = 0000954786104043 <ul><li>-3.5023653</li><li>-3.8169847</li><li>-1.5507963</li></ul> <ul><li>0.00565429</li><li>-0.00412490</li><li>-0.00190589</li></ul>\nSaturn m_2 = 0000285583733151 <ul><li>9.0755314</li><li>-3.0458353</li><li>-1.6483708</li></ul> <ul><li>0.00168318</li><li>0.00483525</li><li>0.00192462</li></ul>\nUranus m_3 = 00000437273164546 <ul><li>8.3101420</li><li>-16.2901086</li><li>-7.2521278</li></ul> <ul><li>0.00354178</li><li>0.00137102</li><li>0.00055029</li></ul>\nNeptune m_4 = 00000517759138449 <ul><li>11.4707666</li><li>-25.7294829</li><li>-10.8169456</li></ul> <ul><li>0.00288930</li><li>0.00114527</li><li>0.00039677</li></ul>\nPluto $ m_5 = 1/(1.3 \\cdot 10^8 )$ <ul><li>-15.5387357</li><li>-25.2225594</li><li>-3.1902382</li></ul> <ul><li>0.00276725</li><li>-0.00170702</li><li>-0.00136504</li></ul>","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"The data is taken from the book \"Geometric Numerical Integration\" by E. Hairer, C. Lubich and G. Wanner.","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"using Plots, OrdinaryDiffEq, DiffEqPhysics, RecursiveArrayTools\ngr()\n\nG = 2.95912208286e-4\nM = [1.00000597682, 0.000954786104043, 0.000285583733151, 0.0000437273164546, 0.0000517759138449, 1/1.3e8]\nplanets = [\"Sun\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Pluto\"]\n\npos_x = [0.0,-3.5023653,9.0755314,8.3101420,11.4707666,-15.5387357]\npos_y = [0.0,-3.8169847,-3.0458353,-16.2901086,-25.7294829,-25.2225594]\npos_z = [0.0,-1.5507963,-1.6483708,-7.2521278,-10.8169456,-3.1902382]\npos = ArrayPartition(pos_x,pos_y,pos_z)\n\nvel_x = [0.0,0.00565429,0.00168318,0.00354178,0.00288930,0.00276725]\nvel_y = [0.0,-0.00412490,0.00483525,0.00137102,0.00114527,-0.00170702]\nvel_z = [0.0,-0.00190589,0.00192462,0.00055029,0.00039677,-0.00136504]\nvel = ArrayPartition(vel_x,vel_y,vel_z)\n\ntspan = (0.,200_000)","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"(0.0, 200000)","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"The N-body problem's Hamiltonian is","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"H(pq) = frac12sum_i=0^Nfracp_i^Tp_im_i - Gsum_i=1^Nsum_j=0^i-1fracm_im_jleftlVert q_i-q_j rightrVert","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"Here, we want to solve for the motion of the five outer planets relative to the sun, namely, Jupiter, Saturn, Uranus, Neptune and Pluto.","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"const ∑ = sum\nconst N = 6\npotential(p, t, x, y, z, M) = -G*∑(i->∑(j->(M[i]*M[j])/sqrt((x[i]-x[j])^2 + (y[i]-y[j])^2 + (z[i]-z[j])^2), 1:i-1), 2:N)","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"potential (generic function with 1 method)","category":"page"},{"location":"models/07-outer_solar_system/#Hamiltonian-System","page":"The Outer Solar System","title":"Hamiltonian System","text":"","category":"section"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"NBodyProblem constructs a second order ODE problem under the hood. We know that a Hamiltonian system has the form of","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"dotp = -H_q(pq)quad dotq=H_p(pq)","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"For an N-body system, we can symplify this as:","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"dotp = -nablaV(q)quad dotq=M^-1p","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"Thus dotq is defined by the masses. We only need to define dotp, and this is done internally by taking the gradient of V. Therefore, we only need to pass the potential function and the rest is taken care of.","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"nprob = NBodyProblem(potential, M, pos, vel, tspan)\nsol = solve(nprob,Yoshida6(), dt=100);","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"Error: UndefVarError: NBodyProblem not defined","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"orbitplot(sol,body_names=planets)","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"Error: UndefVarError: sol not defined","category":"page"},{"location":"models/07-outer_solar_system/#Appendix","page":"The Outer Solar System","title":"Appendix","text":"","category":"section"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"tutorials/models\",\"07-outer_solar_system.jmd\")","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"Computer Information:","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"Julia Version 1.6.2\nCommit 1b93d53fc4 (2021-07-14 15:36 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, znver2)\nEnvironment:\n  JULIA_DEPOT_PATH = /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n  JULIA_NUM_THREADS = 16\n","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"Package Information:","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"      Status `/var/lib/buildkite-agent/builds/1-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/models/Project.toml`\n  [479239e8] Catalyst v6.12.1\n  [459566f4] DiffEqCallbacks v2.16.1\n  [f3b72e0c] DiffEqDevTools v2.27.2\n  [055956cb] DiffEqPhysics v3.9.0\n  [0c46a032] DifferentialEquations v6.17.1\n  [31c24e10] Distributions v0.24.18\n  [587475ba] Flux v0.12.1\n  [f6369f11] ForwardDiff v0.10.18\n  [23fbe1c1] Latexify v0.15.5\n  [961ee093] ModelingToolkit v5.17.3\n  [2774e3e8] NLsolve v4.5.1\n  [315f7962] NeuralPDE v3.10.1\n  [429524aa] Optim v1.3.0\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [91a5bcdd] Plots v1.15.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [789caeaf] StochasticDiffEq v6.34.1\n  [37e2e46d] LinearAlgebra\n  [2f01184e] SparseArrays","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"And the full manifest:","category":"page"},{"location":"models/07-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"      Status `/var/lib/buildkite-agent/builds/1-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/models/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.16.0\n  [621f4979] AbstractFFTs v1.0.1\n  [1520ce14] AbstractTrees v0.3.4\n  [79e6a3ab] Adapt v3.3.0\n  [ec485272] ArnoldiMethod v0.1.0\n  [4fba245c] ArrayInterface v3.1.15\n  [4c555306] ArrayLayouts v0.7.0\n  [13072b0f] AxisAlgorithms v1.0.0\n  [ab4f0b2a] BFloat16s v0.1.0\n  [aae01518] BandedMatrices v0.16.9\n  [764a87c0] BoundaryValueDiffEq v2.7.1\n  [fa961155] CEnum v0.4.1\n  [00ebfdb7] CSTParser v2.5.0\n  [052768ef] CUDA v2.6.3\n  [479239e8] Catalyst v6.12.1\n  [082447d4] ChainRules v0.7.65\n  [d360d2e6] ChainRulesCore v0.9.44\n  [b630d9fa] CheapThreads v0.2.5\n  [944b1d66] CodecZlib v0.7.0\n  [35d6a980] ColorSchemes v3.12.1\n  [3da002f7] ColorTypes v0.11.0\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [a80b9123] CommonMark v0.8.1\n  [38540f10] CommonSolve v0.2.0\n  [bbf7d656] CommonSubexpressions v0.3.0\n  [34da2185] Compat v3.30.0\n  [8f4d0f93] Conda v1.5.2\n  [88cd18e8] ConsoleProgressMonitor v0.1.2\n  [187b0558] ConstructionBase v1.2.1\n  [d38c429a] Contour v0.5.7\n  [a8cc5b0e] Crayons v4.0.4\n  [8a292aeb] Cuba v2.2.0\n  [667455a9] Cubature v1.5.1\n  [9a962f9c] DataAPI v1.6.0\n  [82cc6244] DataInterpolations v3.3.1\n  [864edb3b] DataStructures v0.18.9\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [bcd4f6db] DelayDiffEq v5.31.0\n  [2b5f629d] DiffEqBase v6.62.2\n  [459566f4] DiffEqCallbacks v2.16.1\n  [f3b72e0c] DiffEqDevTools v2.27.2\n  [5a0ffddc] DiffEqFinancial v2.4.0\n  [aae7a2af] DiffEqFlux v1.37.0\n  [c894b116] DiffEqJump v6.14.2\n  [77a26b50] DiffEqNoiseProcess v5.7.3\n  [055956cb] DiffEqPhysics v3.9.0\n  [41bf760c] DiffEqSensitivity v6.45.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.0.2\n  [0c46a032] DifferentialEquations v6.17.1\n  [c619ae07] DimensionalPlotRecipes v1.2.0\n  [b4f34e82] Distances v0.10.3\n  [31c24e10] Distributions v0.24.18\n  [ced4e74d] DistributionsAD v0.6.26\n  [ffbed154] DocStringExtensions v0.8.4\n  [e30172f5] Documenter v0.26.3\n  [d4d017d3] ExponentialUtilities v1.8.4\n  [e2ba6199] ExprTools v0.1.3\n  [c87230d0] FFMPEG v0.4.0\n  [7a1cc6ca] FFTW v1.4.1\n  [7034ab61] FastBroadcast v0.1.8\n  [9aa1b823] FastClosures v0.3.2\n  [1a297f60] FillArrays v0.11.7\n  [6a86dc24] FiniteDiff v2.8.0\n  [53c48c17] FixedPointNumbers v0.8.4\n  [587475ba] Flux v0.12.1\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.18\n  [069b7b12] FunctionWrappers v1.1.2\n  [d9f16b24] Functors v0.2.1\n  [0c68f7d7] GPUArrays v6.4.1\n  [61eb1bfa] GPUCompiler v0.10.0\n  [28b8d3ca] GR v0.57.4\n  [a75be94c] GalacticOptim v1.2.0\n  [5c1252a2] GeometryBasics v0.3.12\n  [af5da776] GlobalSensitivity v1.0.0\n  [42e2da0e] Grisu v1.0.2\n  [19dc6840] HCubature v1.5.0\n  [cd3eb016] HTTP v0.9.9\n  [eafb193a] Highlights v0.4.5\n  [0e44f5e4] Hwloc v2.0.0\n  [7073ff75] IJulia v1.23.2\n  [b5f81e59] IOCapture v0.1.1\n  [7869d1d1] IRTools v0.4.2\n  [615f187c] IfElse v0.1.0\n  [d25df0c9] Inflate v0.1.2\n  [83e8ac13] IniFile v0.5.0\n  [a98d9a8b] Interpolations v0.13.2\n  [c8e1da08] IterTools v1.3.0\n  [42fd0dbc] IterativeSolvers v0.9.1\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.3.0\n  [682c06a0] JSON v0.21.1\n  [98e50ef6] JuliaFormatter v0.13.7\n  [e5e0dc1b] Juno v0.8.4\n  [5ab0869b] KernelDensity v0.6.3\n  [929cbde3] LLVM v3.7.1\n  [b964fa9f] LaTeXStrings v1.2.1\n  [2ee39098] LabelledArrays v1.6.1\n  [23fbe1c1] Latexify v0.15.5\n  [a5e1c1ea] LatinHypercubeSampling v1.8.0\n  [73f95e8e] LatticeRules v0.0.1\n  [1d6d02ad] LeftChildRightSiblingTrees v0.1.2\n  [093fc24a] LightGraphs v1.3.5\n  [d3d80556] LineSearches v7.1.1\n  [2ab3a3ac] LogExpFunctions v0.2.4\n  [e6f89c97] LoggingExtras v0.4.6\n  [bdcacae8] LoopVectorization v0.12.23\n  [1914dd2f] MacroTools v0.5.6\n  [739be429] MbedTLS v1.0.3\n  [442fdcdd] Measures v0.3.1\n  [e89f7d12] Media v0.5.0\n  [c03570c3] Memoize v0.4.4\n  [e1d29d7a] Missings v1.0.0\n  [961ee093] ModelingToolkit v5.17.3\n  [4886b29c] MonteCarloIntegration v0.0.2\n  [46d2c3a1] MuladdMacro v0.2.2\n  [f9640e96] MultiScaleArrays v1.8.1\n  [ffc61752] Mustache v1.0.10\n  [d41bc354] NLSolversBase v7.8.0\n  [2774e3e8] NLsolve v4.5.1\n  [872c559c] NNlib v0.7.19\n  [77ba4419] NaNMath v0.3.5\n  [315f7962] NeuralPDE v3.10.1\n  [8913a72c] NonlinearSolve v0.3.8\n  [6fe1bfb0] OffsetArrays v1.9.0\n  [429524aa] Optim v1.3.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [90014a1f] PDMats v0.11.0\n  [65888b18] ParameterizedFunctions v5.10.0\n  [d96e819e] Parameters v0.12.2\n  [69de0a69] Parsers v1.1.0\n  [ccf2f8ad] PlotThemes v2.0.1\n  [995b91a9] PlotUtils v1.0.10\n  [91a5bcdd] Plots v1.15.2\n  [e409e4f3] PoissonRandom v0.4.0\n  [f517fe37] Polyester v0.3.1\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [21216c6a] Preferences v1.2.2\n  [33c8b6b6] ProgressLogging v0.1.4\n  [92933f4c] ProgressMeter v1.6.2\n  [1fd47b50] QuadGK v2.4.1\n  [67601950] Quadrature v1.8.1\n  [8a4e6c94] QuasiMonteCarlo v0.2.2\n  [74087812] Random123 v1.3.1\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.4.0\n  [c84ed2f1] Ratios v0.4.0\n  [3cdcf5f2] RecipesBase v1.1.1\n  [01d81517] RecipesPipeline v0.3.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [f2c3362d] RecursiveFactorization v0.1.12\n  [189a3867] Reexport v1.0.0\n  [ae029012] Requires v1.1.3\n  [ae5879a3] ResettableStacks v1.1.0\n  [37e2e3b7] ReverseDiff v1.9.0\n  [79098fc4] Rmath v0.7.0\n  [47965b36] RootedTrees v1.0.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.2\n  [476501e8] SLEEFPirates v0.6.20\n  [1bc83da4] SafeTestsets v0.0.1\n  [0bca4576] SciMLBase v1.13.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [6c6a2e73] Scratch v1.0.3\n  [efcf1570] Setfield v0.7.0\n  [992d4aef] Showoff v1.0.3\n  [699a6c99] SimpleTraits v0.9.3\n  [ed01d8cd] Sobol v1.5.0\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.0\n  [47a9eef4] SparseDiffTools v1.13.2\n  [276daf66] SpecialFunctions v1.4.1\n  [860ef19b] StableRNGs v1.0.0\n  [aedffcd0] Static v0.2.4\n  [90137ffa] StaticArrays v1.2.0\n  [82ae8749] StatsAPI v1.0.0\n  [2913bbd2] StatsBase v0.33.8\n  [4c63d2b9] StatsFuns v0.9.8\n  [9672c7b4] SteadyStateDiffEq v1.6.2\n  [789caeaf] StochasticDiffEq v6.34.1\n  [7792a7ef] StrideArraysCore v0.1.11\n  [09ab397b] StructArrays v0.5.1\n  [c3572dad] Sundials v4.4.3\n  [d1185830] SymbolicUtils v0.11.2\n  [0c5d862f] Symbolics v0.1.25\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.4.2\n  [5d786b92] TerminalLoggers v0.1.3\n  [8290d209] ThreadingUtilities v0.4.4\n  [a759f4b9] TimerOutputs v0.5.9\n  [0796e94c] Tokenize v0.5.16\n  [9f7883ad] Tracker v0.2.16\n  [3bb67fe8] TranscodingStreams v0.9.5\n  [592b5752] Trapz v2.0.2\n  [a2a6695c] TreeViews v0.3.0\n  [5c2747f8] URIs v1.3.0\n  [3a884ed6] UnPack v1.0.2\n  [1986cc42] Unitful v1.7.0\n  [3d5dd08c] VectorizationBase v0.20.11\n  [81def892] VersionParsing v1.2.0\n  [19fa3120] VertexSafeGraphs v0.1.2\n  [44d3d7a6] Weave v0.10.8\n  [efce3f68] WoodburyMatrices v0.5.3\n  [ddb6d928] YAML v0.4.6\n  [c2297ded] ZMQ v1.2.1\n  [a5390f91] ZipFile v0.9.3\n  [e88e6eb3] Zygote v0.6.11\n  [700de1a5] ZygoteRules v0.2.1\n  [6e34b625] Bzip2_jll v1.0.6+5\n  [83423d85] Cairo_jll v1.16.0+6\n  [3bed1096] Cuba_jll v4.2.1+0\n  [7bc98958] Cubature_jll v1.0.4+0\n  [5ae413db] EarCut_jll v2.1.5+1\n  [2e619515] Expat_jll v2.2.10+0\n  [b22a6f82] FFMPEG_jll v4.3.1+4\n  [f5851436] FFTW_jll v3.3.9+7\n  [a3f928ae] Fontconfig_jll v2.13.1+14\n  [d7e528f0] FreeType2_jll v2.10.1+5\n  [559328eb] FriBidi_jll v1.0.5+6\n  [0656b61e] GLFW_jll v3.3.4+0\n  [d2c73de3] GR_jll v0.57.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.1+0\n  [e33a78d0] Hwloc_jll v2.4.1+0\n  [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2\n  [aacddb02] JpegTurbo_jll v2.0.1+3\n  [c1c5ebd0] LAME_jll v3.100.0+3\n  [dd4b983a] LZO_jll v2.10.1+0\n  [dd192d2f] LibVPX_jll v1.9.0+1\n  [e9f186c6] Libffi_jll v3.2.2+0\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+0\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.1.0+2\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [856f044c] MKL_jll v2021.1.1+1\n  [e7412a2a] Ogg_jll v1.3.4+2\n  [458c3c95] OpenSSL_jll v1.1.1+6\n  [efe28fd5] OpenSpecFun_jll v0.5.4+0\n  [91d4177d] Opus_jll v1.3.1+3\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.2+0\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.0+1\n  [a2964d1f] Wayland_jll v1.17.0+4\n  [2381bf8a] Wayland_protocols_jll v1.18.0+4\n  [02c8fc9c] XML2_jll v2.9.12+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.2+6\n  [3161d3a3] Zstd_jll v1.5.0+0\n  [0ac62f75] libass_jll v0.14.0+4\n  [f638f0a6] libfdk_aac_jll v0.1.6+4\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.6+6\n  [1270edf5] x264_jll v2020.7.14+2\n  [dfaa095f] x265_jll v3.0.0+3\n  [d8fb68d0] xkbcommon_jll v0.9.1+5\n  [0dad84c5] ArgTools\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [4af54fe1] LazyArtifacts\n  [b27032c2] LibCURL\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions\n  [44cfe95a] Pkg\n  [de0858da] Printf\n  [9abbd945] Profile\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML\n  [a4e569a6] Tar\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll\n  [deac9b47] LibCURL_jll\n  [29816b5a] LibSSH2_jll\n  [c8ffd9c3] MbedTLS_jll\n  [14a3606d] MozillaCACerts_jll\n  [4536629a] OpenBLAS_jll\n  [bea87d4a] SuiteSparse_jll\n  [83775a58] Zlib_jll\n  [8e850ede] nghttp2_jll\n  [3f19e933] p7zip_jll","category":"page"},{"location":"advanced/02-advanced_ODE_solving/#Solving-Stiff-Equations","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"","category":"section"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"This tutorial is for getting into the extra features for solving stiff ordinary differential equations in an efficient manner. Solving stiff ordinary differential equations requires specializing the linear solver on properties of the Jacobian in order to cut down on the O(n^3) linear solve and the O(n^2) back-solves. Note that these same functions and controls also extend to stiff SDEs, DDEs, DAEs, etc.","category":"page"},{"location":"advanced/02-advanced_ODE_solving/#Code-Optimization-for-Differential-Equations","page":"Solving Stiff Equations","title":"Code Optimization for Differential Equations","text":"","category":"section"},{"location":"advanced/02-advanced_ODE_solving/#Writing-Efficient-Code","page":"Solving Stiff Equations","title":"Writing Efficient Code","text":"","category":"section"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"For a detailed tutorial on how to optimize one's DifferentialEquations.jl code, please see the Optimizing DiffEq Code tutorial.","category":"page"},{"location":"advanced/02-advanced_ODE_solving/#Choosing-a-Good-Solver","page":"Solving Stiff Equations","title":"Choosing a Good Solver","text":"","category":"section"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Choosing a good solver is required for getting top notch speed. General recommendations can be found on the solver page (for example, the ODE Solver Recommendations). The current recommendations can be simplified to a Rosenbrock method (Rosenbrock23 or Rodas5) for smaller (<50 ODEs) problems, ESDIRK methods for slightly larger (TRBDF2 or KenCarp4 for <2000 ODEs), and Sundials CVODE_BDF for even larger problems. lsoda from LSODA.jl is generally worth a try.","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"More details on the solver to choose can be found by benchmarking. See the DiffEqBenchmarks to compare many solvers on many problems.","category":"page"},{"location":"advanced/02-advanced_ODE_solving/#Check-Out-the-Speed-FAQ","page":"Solving Stiff Equations","title":"Check Out the Speed FAQ","text":"","category":"section"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"See this FAQ for information on common pitfalls and how to improve performance.","category":"page"},{"location":"advanced/02-advanced_ODE_solving/#Setting-Up-Your-Julia-Installation-for-Speed","page":"Solving Stiff Equations","title":"Setting Up Your Julia Installation for Speed","text":"","category":"section"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Julia uses an underlying BLAS implementation for its matrix multiplications and factorizations. This library is automatically multithreaded and accelerates the internal linear algebra of DifferentialEquations.jl. However, for optimality, you should make sure that the number of BLAS threads that you are using matches the number of physical cores and not the number of logical cores. See this issue for more details.","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"To check the number of BLAS threads, use:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"using LinearAlgebra\nLinearAlgebra.BLAS.get_num_threads()","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"4","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"If I want to set this directly to 4 threads, I would use:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"using LinearAlgebra\nLinearAlgebra.BLAS.set_num_threads(4)","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Additionally, in some cases Intel's MKL might be a faster BLAS than the standard BLAS that ships with Julia (OpenBLAS). To switch your BLAS implementation, you can use MKL.jl which will accelerate the linear algebra routines. Please see the package for the limitations.","category":"page"},{"location":"advanced/02-advanced_ODE_solving/#Use-Accelerator-Hardware","page":"Solving Stiff Equations","title":"Use Accelerator Hardware","text":"","category":"section"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"When possible, use GPUs. If your ODE system is small and you need to solve it with very many different parameters, see the ensembles interface and DiffEqGPU.jl. If your problem is large, consider using a CuArray for the state to allow for GPU-parallelism of the internal linear algebra.","category":"page"},{"location":"advanced/02-advanced_ODE_solving/#Speeding-Up-Jacobian-Calculations","page":"Solving Stiff Equations","title":"Speeding Up Jacobian Calculations","text":"","category":"section"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"When one is using an implicit or semi-implicit differential equation solver, the Jacobian must be built at many iterations and this can be one of the most expensive steps. There are two pieces that must be optimized in order to reach maximal efficiency when solving stiff equations: the sparsity pattern and the construction of the Jacobian. The construction is filling the matrix J with values, while the sparsity pattern is what J to use.","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"The sparsity pattern is given by a prototype matrix, the jac_prototype, which will be copied to be used as J. The default is for J to be a Matrix, i.e. a dense matrix. However, if you know the sparsity of your problem, then you can pass a different matrix type. For example, a SparseMatrixCSC will give a sparse matrix. Additionally, structured matrix types like Tridiagonal, BandedMatrix (from BandedMatrices.jl), BlockBandedMatrix (from BlockBandedMatrices.jl), and more can be given. DifferentialEquations.jl will internally use this matrix type, making the factorizations faster by utilizing the specialized forms.","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"For the construction, there are 3 ways to fill J:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"The default, which uses normal finite/automatic differentiation\nA function jac(J,u,p,t) which directly computes the values of J\nA colorvec which defines a sparse differentiation scheme.","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"We will now showcase how to make use of this functionality with growing complexity.","category":"page"},{"location":"advanced/02-advanced_ODE_solving/#Declaring-Jacobian-Functions","page":"Solving Stiff Equations","title":"Declaring Jacobian Functions","text":"","category":"section"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Let's solve the Rosenbrock equations:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"beginalign\ndy_1 = -004y₁ + 10^4 y_2 y_3 \ndy_2 = 004 y_1 - 10^4 y_2 y_3 - 3*10^7 y_2^2 \ndy_3 = 3*10^7 y_3^2 \nendalign","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"In order to reduce the Jacobian construction cost, one can describe a Jacobian function by using the jac argument for the ODEFunction. First, let's do a standard ODEProblem:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"using DifferentialEquations\nfunction rober(du,u,p,t)\n  y₁,y₂,y₃ = u\n  k₁,k₂,k₃ = p\n  du[1] = -k₁*y₁+k₃*y₂*y₃\n  du[2] =  k₁*y₁-k₂*y₂^2-k₃*y₂*y₃\n  du[3] =  k₂*y₂^2\n  nothing\nend\nprob = ODEProblem(rober,[1.0,0.0,0.0],(0.0,1e5),(0.04,3e7,1e4))\nsol = solve(prob,Rosenbrock23())\n\nusing Plots\nplot(sol, xscale=:log10, tspan=(1e-6, 1e5), layout=(3,1))","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"(Image: )","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"using BenchmarkTools\n@btime solve(prob)","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"563.855 μs (2561 allocations: 186.89 KiB)\nretcode: Success\nInterpolation: automatic order switching interpolation\nt: 115-element Vector{Float64}:\n      0.0\n      0.0014148468219250373\n      0.0020449182545311173\n      0.0031082402716566307\n      0.004077787050059496\n      0.005515332443361059\n      0.007190040962774541\n      0.009125372578778032\n      0.011053912492732977\n      0.012779077276958607\n      ⋮\n  47335.55742427336\n  52732.00629853751\n  58693.72275675742\n  65277.99247104326\n  72548.193682209\n  80574.55524404174\n  89435.04313420167\n  99216.40190401232\n 100000.0\nu: 115-element Vector{Vector{Float64}}:\n [1.0, 0.0, 0.0]\n [0.9999434113193613, 3.283958829839966e-5, 2.374909234028646e-5]\n [0.9999182177783585, 3.5542680136344576e-5, 4.6239541505020636e-5]\n [0.999875715036629, 3.630246933484973e-5, 8.798249403609502e-5]\n [0.9998369766077329, 3.646280308115454e-5, 0.00012656058918590176]\n [0.9997795672444667, 3.6466430856422276e-5, 0.00018396632467683696]\n [0.9997127287139348, 3.644727999289594e-5, 0.0002508240060722832]\n [0.9996355450022019, 3.6366816179962554e-5, 0.0003280881816181881]\n [0.9995586925734838, 3.6018927453310745e-5, 0.00040528849906290245]\n [0.9994899965196854, 3.468694637784628e-5, 0.00047531653393682193]\n ⋮\n [0.03394368533138813, 1.4047985954839008e-7, 0.9660561741887524]\n [0.031028978802635446, 1.280360882615162e-7, 0.9689708931612764]\n [0.02835436649772506, 1.1668210763639173e-7, 0.971645516820168]\n [0.02590132862868119, 1.0632277796078e-7, 0.9740985650485414]\n [0.023652547707489525, 9.687113505658095e-8, 0.9763473554213756]\n [0.021591864255513585, 8.824768851310993e-8, 0.9784080474967981]\n [0.01970422745458613, 8.037977845291491e-8, 0.9802956921656356]\n [0.017975643191251073, 7.320098956514714e-8, 0.9820242836077591]\n [0.01785056623499974, 7.26838436117136e-8, 0.9821493610811564]","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Now we want to add the Jacobian. First we have to derive the Jacobian fracdf_idu_j which is J[i,j]. From this we get:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"function rober_jac(J,u,p,t)\n  y₁,y₂,y₃ = u\n  k₁,k₂,k₃ = p\n  J[1,1] = k₁ * -1\n  J[2,1] = k₁\n  J[3,1] = 0\n  J[1,2] = y₃ * k₃\n  J[2,2] = y₂ * k₂ * -2 + y₃ * k₃ * -1\n  J[3,2] = y₂ * 2 * k₂\n  J[1,3] = k₃ * y₂\n  J[2,3] = k₃ * y₂ * -1\n  J[3,3] = 0\n  nothing\nend\nf = ODEFunction(rober, jac=rober_jac)\nprob_jac = ODEProblem(f,[1.0,0.0,0.0],(0.0,1e5),(0.04,3e7,1e4))\n\n@btime solve(prob_jac)","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"354.177 μs (2002 allocations: 126.28 KiB)\nretcode: Success\nInterpolation: automatic order switching interpolation\nt: 115-element Vector{Float64}:\n      0.0\n      0.0014148468219250373\n      0.0020449182545311173\n      0.0031082402716566307\n      0.004077787050059496\n      0.005515332443361059\n      0.007190040962774541\n      0.009125372578778032\n      0.011053912492732977\n      0.012779077276958607\n      ⋮\n  45964.060340548356\n  51219.40381376205\n  57025.01899700374\n  63436.021374561584\n  70513.1073617524\n  78323.14229130604\n  86939.82338876331\n  96444.41085674686\n 100000.0\nu: 115-element Vector{Vector{Float64}}:\n [1.0, 0.0, 0.0]\n [0.9999434113193613, 3.283958829839966e-5, 2.374909234028646e-5]\n [0.9999182177783585, 3.5542680136344576e-5, 4.6239541505020636e-5]\n [0.999875715036629, 3.630246933484973e-5, 8.798249403609502e-5]\n [0.9998369766077329, 3.646280308115454e-5, 0.00012656058918590176]\n [0.9997795672444667, 3.6466430856422276e-5, 0.00018396632467683696]\n [0.9997127287139348, 3.644727999289594e-5, 0.0002508240060722832]\n [0.9996355450022019, 3.6366816179962554e-5, 0.0003280881816181881]\n [0.9995586925734838, 3.6018927453310745e-5, 0.00040528849906290245]\n [0.9994899965196854, 3.468694637784628e-5, 0.00047531653393682193]\n ⋮\n [0.03478048133177493, 1.4406682005231008e-7, 0.9652193746014031]\n [0.03179591062189176, 1.313038656880417e-7, 0.9682039580742408]\n [0.029057356622057315, 1.1966100432939363e-7, 0.9709425237169371]\n [0.02654597011713668, 1.0904070990251299e-7, 0.9734539208421517]\n [0.024244118287194777, 9.935385522693504e-8, 0.9757557823589477]\n [0.022135344621501105, 9.05190025093182e-8, 0.9778645648594945]\n [0.02020432071854, 8.246174295748071e-8, 0.9797955968197154]\n [0.018436796681356796, 7.511410189106845e-8, 0.9815631282045397]\n [0.01785426048218692, 7.269900678199638e-8, 0.9821456668188047]","category":"page"},{"location":"advanced/02-advanced_ODE_solving/#Automatic-Derivation-of-Jacobian-Functions","page":"Solving Stiff Equations","title":"Automatic Derivation of Jacobian Functions","text":"","category":"section"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"But that was hard! If you want to take the symbolic Jacobian of numerical code, we can make use of ModelingToolkit.jl to symbolicify the numerical code and do the symbolic calculation and return the Julia code for this.","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"using ModelingToolkit\nde = modelingtoolkitize(prob)\nModelingToolkit.generate_jacobian(de)[2] # Second is in-place","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":":(function (var\"##out#5956\", var\"##arg#5954\", var\"##arg#5955\", t)\n      #= /cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa5\n7c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:282 =#\n      #= /cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa5\n7c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:283 =#\n      let var\"x₁(t)\" = #= /cache/julia-buildkite-plugin/depots/a6029d3a-f78\nb-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @i\nnbounds(var\"##arg#5954\"[1]), var\"x₂(t)\" = #= /cache/julia-buildkite-plugin/\ndepots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/sr\nc/code.jl:169 =# @inbounds(var\"##arg#5954\"[2]), var\"x₃(t)\" = #= /cache/juli\na-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/Sym\nbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg#5954\"[3]), α₁ = #= \n/cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/p\nackages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg#5955\"[1]\n), α₂ = #= /cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28a\na57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##a\nrg#5955\"[2]), α₃ = #= /cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41\nea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbou\nnds(var\"##arg#5955\"[3])\n          #= /cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-2\n8aa57c6c6ea/packages/Symbolics/h8kPL/src/build_function.jl:331 =#\n          #= /cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-2\n8aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:329 =# @inbounds begin\n                  #= /cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41e\na-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:325 =#\n                  var\"##out#5956\"[1] = (*)(-1, α₁)\n                  var\"##out#5956\"[2] = α₁\n                  var\"##out#5956\"[3] = 0\n                  var\"##out#5956\"[4] = (*)(α₃, var\"x₃(t)\")\n                  var\"##out#5956\"[5] = (+)((*)(-2, α₂, var\"x₂(t)\"), (*)(-1,\n α₃, var\"x₃(t)\"))\n                  var\"##out#5956\"[6] = (*)(2, α₂, var\"x₂(t)\")\n                  var\"##out#5956\"[7] = (*)(α₃, var\"x₂(t)\")\n                  var\"##out#5956\"[8] = (*)(-1, α₃, var\"x₂(t)\")\n                  var\"##out#5956\"[9] = 0\n                  #= /cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41e\na-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:327 =#\n                  nothing\n              end\n      end\n  end)","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"which outputs:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":":((##MTIIPVar#376, u, p, t)->begin\n          #= C:\\Users\\accou\\.julia\\packages\\ModelingToolkit\\czHtj\\src\\utils.jl:65 =#\n          #= C:\\Users\\accou\\.julia\\packages\\ModelingToolkit\\czHtj\\src\\utils.jl:66 =#\n          let (x₁, x₂, x₃, α₁, α₂, α₃) = (u[1], u[2], u[3], p[1], p[2], p[3])\n              ##MTIIPVar#376[1] = α₁ * -1\n              ##MTIIPVar#376[2] = α₁\n              ##MTIIPVar#376[3] = 0\n              ##MTIIPVar#376[4] = x₃ * α₃\n              ##MTIIPVar#376[5] = x₂ * α₂ * -2 + x₃ * α₃ * -1\n              ##MTIIPVar#376[6] = x₂ * 2 * α₂\n              ##MTIIPVar#376[7] = α₃ * x₂\n              ##MTIIPVar#376[8] = α₃ * x₂ * -1\n              ##MTIIPVar#376[9] = 0\n          end\n          #= C:\\Users\\accou\\.julia\\packages\\ModelingToolkit\\czHtj\\src\\utils.jl:67 =#\n          nothing\n      end)","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Now let's use that to give the analytical solution Jacobian:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"jac = eval(ModelingToolkit.generate_jacobian(de)[2])\nf = ODEFunction(rober, jac=jac)\nprob_jac = ODEProblem(f,[1.0,0.0,0.0],(0.0,1e5),(0.04,3e7,1e4))","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"ODEProblem with uType Vector{Float64} and tType Float64. In-place: true\ntimespan: (0.0, 100000.0)\nu0: 3-element Vector{Float64}:\n 1.0\n 0.0\n 0.0","category":"page"},{"location":"advanced/02-advanced_ODE_solving/#Declaring-a-Sparse-Jacobian","page":"Solving Stiff Equations","title":"Declaring a Sparse Jacobian","text":"","category":"section"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Jacobian sparsity is declared by the jac_prototype argument in the ODEFunction. Note that you should only do this if the sparsity is high, for example, 0.1% of the matrix is non-zeros, otherwise the overhead of sparse matrices can be higher than the gains from sparse differentiation!","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"But as a demonstration, let's build a sparse matrix for the Rober problem. We can do this by gathering the I and J pairs for the non-zero components, like:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"I = [1,2,1,2,3,1,2]\nJ = [1,1,2,2,2,3,3]\nusing SparseArrays\njac_prototype = sparse(I,J,1.0)","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 7 stored entries:\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n  ⋅   1.0   ⋅","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Now this is the sparse matrix prototype that we want to use in our solver, which we then pass like:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"f = ODEFunction(rober, jac=jac, jac_prototype=jac_prototype)\nprob_jac = ODEProblem(f,[1.0,0.0,0.0],(0.0,1e5),(0.04,3e7,1e4))","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"ODEProblem with uType Vector{Float64} and tType Float64. In-place: true\ntimespan: (0.0, 100000.0)\nu0: 3-element Vector{Float64}:\n 1.0\n 0.0\n 0.0","category":"page"},{"location":"advanced/02-advanced_ODE_solving/#Automatic-Sparsity-Detection","page":"Solving Stiff Equations","title":"Automatic Sparsity Detection","text":"","category":"section"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"One of the useful companion tools for DifferentialEquations.jl is SparsityDetection.jl. This allows for automatic declaration of Jacobian sparsity types. To see this in action, let's look at the 2-dimensional Brusselator equation:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"const N = 32\nconst xyd_brusselator = range(0,stop=1,length=N)\nbrusselator_f(x, y, t) = (((x-0.3)^2 + (y-0.6)^2) <= 0.1^2) * (t >= 1.1) * 5.\nlimit(a, N) = a == N+1 ? 1 : a == 0 ? N : a\nfunction brusselator_2d_loop(du, u, p, t)\n  A, B, alpha, dx = p\n  alpha = alpha/dx^2\n  @inbounds for I in CartesianIndices((N, N))\n    i, j = Tuple(I)\n    x, y = xyd_brusselator[I[1]], xyd_brusselator[I[2]]\n    ip1, im1, jp1, jm1 = limit(i+1, N), limit(i-1, N), limit(j+1, N), limit(j-1, N)\n    du[i,j,1] = alpha*(u[im1,j,1] + u[ip1,j,1] + u[i,jp1,1] + u[i,jm1,1] - 4u[i,j,1]) +\n                B + u[i,j,1]^2*u[i,j,2] - (A + 1)*u[i,j,1] + brusselator_f(x, y, t)\n    du[i,j,2] = alpha*(u[im1,j,2] + u[ip1,j,2] + u[i,jp1,2] + u[i,jm1,2] - 4u[i,j,2]) +\n                A*u[i,j,1] - u[i,j,1]^2*u[i,j,2]\n    end\nend\np = (3.4, 1., 10., step(xyd_brusselator))","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"(3.4, 1.0, 10.0, 0.03225806451612903)","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Given this setup, we can give and example input and output and call sparsity! on our function with the example arguments and it will kick out a sparse matrix with our pattern, that we can turn into our jac_prototype.","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"using SparsityDetection, SparseArrays\ninput = rand(32,32,2)\noutput = similar(input)\nsparsity_pattern = jacobian_sparsity(brusselator_2d_loop,output,input,p,0.0)\njac_sparsity = Float64.(sparse(sparsity_pattern))","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Explored path: SparsityDetection.Path(Bool[], 1)\n2048×2048 SparseArrays.SparseMatrixCSC{Float64, Int64} with 12288 stored en\ntries:\n⢿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠙⢿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠙⢿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠙⢿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠙⢿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀\n⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄\n⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙\n⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣷⣄⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣷⣄⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣷⣄⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣷⣄⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣷","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Let's double check what our sparsity pattern looks like:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"using Plots\nspy(jac_sparsity,markersize=1,colorbar=false,color=:deep)","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"(Image: )","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"That's neat, and would be tedius to build by hand! Now we just pass it to the ODEFunction like as before:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"f = ODEFunction(brusselator_2d_loop;jac_prototype=jac_sparsity)","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"(::SciMLBase.ODEFunction{true, typeof(Main.##WeaveSandBox#5548.brusselator_\n2d_loop), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, No\nthing, Nothing, SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.\nSparseMatrixCSC{Float64, Int64}, Nothing, Nothing, Nothing, Nothing, Nothin\ng, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing}) (generic function with 7 m\nethods)","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Build the ODEProblem:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"function init_brusselator_2d(xyd)\n  N = length(xyd)\n  u = zeros(N, N, 2)\n  for I in CartesianIndices((N, N))\n    x = xyd[I[1]]\n    y = xyd[I[2]]\n    u[I,1] = 22*(y*(1-y))^(3/2)\n    u[I,2] = 27*(x*(1-x))^(3/2)\n  end\n  u\nend\nu0 = init_brusselator_2d(xyd_brusselator)\nprob_ode_brusselator_2d = ODEProblem(brusselator_2d_loop,\n                                     u0,(0.,11.5),p)\n\nprob_ode_brusselator_2d_sparse = ODEProblem(f,\n                                     u0,(0.,11.5),p)","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"ODEProblem with uType Array{Float64, 3} and tType Float64. In-place: true\ntimespan: (0.0, 11.5)\nu0: 32×32×2 Array{Float64, 3}:\n[:, :, 1] =\n 0.0  0.121344  0.326197  0.568534  …  0.568534  0.326197  0.121344  0.0\n 0.0  0.121344  0.326197  0.568534     0.568534  0.326197  0.121344  0.0\n 0.0  0.121344  0.326197  0.568534     0.568534  0.326197  0.121344  0.0\n 0.0  0.121344  0.326197  0.568534     0.568534  0.326197  0.121344  0.0\n 0.0  0.121344  0.326197  0.568534     0.568534  0.326197  0.121344  0.0\n 0.0  0.121344  0.326197  0.568534  …  0.568534  0.326197  0.121344  0.0\n 0.0  0.121344  0.326197  0.568534     0.568534  0.326197  0.121344  0.0\n 0.0  0.121344  0.326197  0.568534     0.568534  0.326197  0.121344  0.0\n 0.0  0.121344  0.326197  0.568534     0.568534  0.326197  0.121344  0.0\n 0.0  0.121344  0.326197  0.568534     0.568534  0.326197  0.121344  0.0\n ⋮                                  ⋱                      ⋮         \n 0.0  0.121344  0.326197  0.568534     0.568534  0.326197  0.121344  0.0\n 0.0  0.121344  0.326197  0.568534     0.568534  0.326197  0.121344  0.0\n 0.0  0.121344  0.326197  0.568534  …  0.568534  0.326197  0.121344  0.0\n 0.0  0.121344  0.326197  0.568534     0.568534  0.326197  0.121344  0.0\n 0.0  0.121344  0.326197  0.568534     0.568534  0.326197  0.121344  0.0\n 0.0  0.121344  0.326197  0.568534     0.568534  0.326197  0.121344  0.0\n 0.0  0.121344  0.326197  0.568534     0.568534  0.326197  0.121344  0.0\n 0.0  0.121344  0.326197  0.568534  …  0.568534  0.326197  0.121344  0.0\n 0.0  0.121344  0.326197  0.568534     0.568534  0.326197  0.121344  0.0\n\n[:, :, 2] =\n 0.0       0.0       0.0       0.0       …  0.0       0.0       0.0\n 0.148923  0.148923  0.148923  0.148923     0.148923  0.148923  0.148923\n 0.400332  0.400332  0.400332  0.400332     0.400332  0.400332  0.400332\n 0.697746  0.697746  0.697746  0.697746     0.697746  0.697746  0.697746\n 1.01722   1.01722   1.01722   1.01722      1.01722   1.01722   1.01722\n 1.34336   1.34336   1.34336   1.34336   …  1.34336   1.34336   1.34336\n 1.66501   1.66501   1.66501   1.66501      1.66501   1.66501   1.66501\n 1.97352   1.97352   1.97352   1.97352      1.97352   1.97352   1.97352\n 2.26207   2.26207   2.26207   2.26207      2.26207   2.26207   2.26207\n 2.52509   2.52509   2.52509   2.52509      2.52509   2.52509   2.52509\n ⋮                                       ⋱            ⋮         \n 2.26207   2.26207   2.26207   2.26207      2.26207   2.26207   2.26207\n 1.97352   1.97352   1.97352   1.97352      1.97352   1.97352   1.97352\n 1.66501   1.66501   1.66501   1.66501   …  1.66501   1.66501   1.66501\n 1.34336   1.34336   1.34336   1.34336      1.34336   1.34336   1.34336\n 1.01722   1.01722   1.01722   1.01722      1.01722   1.01722   1.01722\n 0.697746  0.697746  0.697746  0.697746     0.697746  0.697746  0.697746\n 0.400332  0.400332  0.400332  0.400332     0.400332  0.400332  0.400332\n 0.148923  0.148923  0.148923  0.148923  …  0.148923  0.148923  0.148923\n 0.0       0.0       0.0       0.0          0.0       0.0       0.0","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Now let's see how the version with sparsity compares to the version without:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"@btime solve(prob_ode_brusselator_2d,save_everystep=false)\n@btime solve(prob_ode_brusselator_2d_sparse,save_everystep=false)","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"4.100 s (3332 allocations: 65.33 MiB)\n  542.630 ms (40171 allocations: 276.18 MiB)\nretcode: Success\nInterpolation: 1st order linear\nt: 2-element Vector{Float64}:\n  0.0\n 11.5\nu: 2-element Vector{Array{Float64, 3}}:\n [0.0 0.12134432813715876 … 0.1213443281371586 0.0; 0.0 0.12134432813715876\n … 0.1213443281371586 0.0; … ; 0.0 0.12134432813715876 … 0.1213443281371586\n 0.0; 0.0 0.12134432813715876 … 0.1213443281371586 0.0]\n\n[0.0 0.0 … 0.0 0.0; 0.14892258453196755 0.14892258453196755 … 0.14892258453\n196755 0.14892258453196755; … ; 0.14892258453196738 0.14892258453196738 … 0\n.14892258453196738 0.14892258453196738; 0.0 0.0 … 0.0 0.0]\n [3.8715710568026327 3.871544263496401 … 3.871660597887853 3.87161004723348\n5; 3.8716190219250093 3.871588988900678 … 3.871720060854604 3.8716628901712\n69; … ; 3.8714871831703883 3.8714656453085934 … 3.8715582925263354 3.871518\n307861871; 3.871526626222637 3.8715026809065862 … 3.871606147539579 3.87156\n13475793575]\n\n[1.5025267482810192 1.5025277497723653 … 1.5025234812450186 1.5025253112096\n277; 1.5025247560530617 1.502525831533873 … 1.502521238116099 1.50252321042\n43587; … ; 1.5025302969061514 1.5025311733894735 … 1.5025274521973424 1.502\n5290429883629; 1.502528617794096 1.5025295523513722 … 1.502525577078082 1.5\n025272788129502]","category":"page"},{"location":"advanced/02-advanced_ODE_solving/#Declaring-Color-Vectors-for-Fast-Construction","page":"Solving Stiff Equations","title":"Declaring Color Vectors for Fast Construction","text":"","category":"section"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"If you cannot directly define a Jacobian function, you can use the colorvec to speed up the Jacobian construction. What the colorvec does is allows for calculating multiple columns of a Jacobian simultaniously by using the sparsity pattern. An explanation of matrix coloring can be found in the MIT 18.337 Lecture Notes.","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"To perform general matrix coloring, we can use SparseDiffTools.jl. For example, for the Brusselator equation:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"using SparseDiffTools\ncolorvec = matrix_colors(jac_sparsity)\n@show maximum(colorvec)","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"maximum(colorvec) = 12\n12","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"This means that we can now calculate the Jacobian in 12 function calls. This is a nice reduction from 2048 using only automated tooling! To now make use of this inside of the ODE solver, you simply need to declare the colorvec:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"f = ODEFunction(brusselator_2d_loop;jac_prototype=jac_sparsity,\n                                    colorvec=colorvec)\nprob_ode_brusselator_2d_sparse = ODEProblem(f,\n                                     init_brusselator_2d(xyd_brusselator),\n                                     (0.,11.5),p)\n@btime solve(prob_ode_brusselator_2d_sparse,save_everystep=false)","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"541.163 ms (7386 allocations: 272.21 MiB)\nretcode: Success\nInterpolation: 1st order linear\nt: 2-element Vector{Float64}:\n  0.0\n 11.5\nu: 2-element Vector{Array{Float64, 3}}:\n [0.0 0.12134432813715876 … 0.1213443281371586 0.0; 0.0 0.12134432813715876\n … 0.1213443281371586 0.0; … ; 0.0 0.12134432813715876 … 0.1213443281371586\n 0.0; 0.0 0.12134432813715876 … 0.1213443281371586 0.0]\n\n[0.0 0.0 … 0.0 0.0; 0.14892258453196755 0.14892258453196755 … 0.14892258453\n196755 0.14892258453196755; … ; 0.14892258453196738 0.14892258453196738 … 0\n.14892258453196738 0.14892258453196738; 0.0 0.0 … 0.0 0.0]\n [3.8715710568026327 3.871544263496401 … 3.871660597887853 3.87161004723348\n5; 3.8716190219250093 3.871588988900678 … 3.871720060854604 3.8716628901712\n69; … ; 3.8714871831703883 3.8714656453085934 … 3.8715582925263354 3.871518\n307861871; 3.871526626222637 3.8715026809065862 … 3.871606147539579 3.87156\n13475793575]\n\n[1.5025267482810192 1.5025277497723653 … 1.5025234812450186 1.5025253112096\n277; 1.5025247560530617 1.502525831533873 … 1.502521238116099 1.50252321042\n43587; … ; 1.5025302969061514 1.5025311733894735 … 1.5025274521973424 1.502\n5290429883629; 1.502528617794096 1.5025295523513722 … 1.502525577078082 1.5\n025272788129502]","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Notice the massive speed enhancement!","category":"page"},{"location":"advanced/02-advanced_ODE_solving/#Defining-Linear-Solver-Routines-and-Jacobian-Free-Newton-Krylov","page":"Solving Stiff Equations","title":"Defining Linear Solver Routines and Jacobian-Free Newton-Krylov","text":"","category":"section"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"A completely different way to optimize the linear solvers for large sparse matrices is to use a Krylov subpsace method. This requires choosing a linear solver for changing to a Krylov method. Optionally, one can use a Jacobian-free operator to reduce the memory requirements.","category":"page"},{"location":"advanced/02-advanced_ODE_solving/#Declaring-a-Jacobian-Free-Newton-Krylov-Implementation","page":"Solving Stiff Equations","title":"Declaring a Jacobian-Free Newton-Krylov Implementation","text":"","category":"section"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"To swap the linear solver out, we use the linsolve command and choose the GMRES linear solver.","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"@btime solve(prob_ode_brusselator_2d,TRBDF2(linsolve=LinSolveGMRES()),save_everystep=false)\n@btime solve(prob_ode_brusselator_2d_sparse,TRBDF2(linsolve=LinSolveGMRES()),save_everystep=false)","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"40.444 s (1440760 allocations: 148.08 MiB)\n  1.898 s (487052 allocations: 19.49 MiB)\nretcode: Success\nInterpolation: 1st order linear\nt: 2-element Vector{Float64}:\n  0.0\n 11.5\nu: 2-element Vector{Array{Float64, 3}}:\n [0.0 0.12134432813715876 … 0.1213443281371586 0.0; 0.0 0.12134432813715876\n … 0.1213443281371586 0.0; … ; 0.0 0.12134432813715876 … 0.1213443281371586\n 0.0; 0.0 0.12134432813715876 … 0.1213443281371586 0.0]\n\n[0.0 0.0 … 0.0 0.0; 0.14892258453196755 0.14892258453196755 … 0.14892258453\n196755 0.14892258453196755; … ; 0.14892258453196738 0.14892258453196738 … 0\n.14892258453196738 0.14892258453196738; 0.0 0.0 … 0.0 0.0]\n [1.4496467189952293 1.4496188458395953 … 1.449739625696683 1.4496857634543\n15; 1.4496924266563709 1.4496627513504483 … 1.4497954395000603 1.4497385989\n710139; … ; 1.4495499647945365 1.4495293829622544 … 1.4496249819457812 1.44\n95821445340045; 1.4495986625150836 1.4495728479552343 … 1.449681691859659 1\n.4496342425553288]\n\n[4.555791737526942 4.555792854178718 … 4.555785210283977 4.555788777078638;\n 4.555787105443905 4.555788047943169 … 4.555781401248265 4.5557847763611905\n; … ; 4.5558058525318765 4.555807862015024 … 4.5558015022696345 4.555804088\n530327; 4.555797778755576 4.555798553618496 … 4.5557925979760325 4.55579571\n470298]","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"For more information on linear solver choices, see the linear solver documentation.","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"On this problem, handling the sparsity correctly seemed to give much more of a speedup than going to a Krylov approach, but that can be dependent on the problem (and whether a good preconditioner is found).","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"We can also enhance this by using a Jacobian-Free implementation of f'(x)*v. To define the Jacobian-Free operator, we can use DiffEqOperators.jl to generate an operator JacVecOperator such that Jv*v performs f'(x)*v without building the Jacobian matrix.","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"using DiffEqOperators\nJv = JacVecOperator(brusselator_2d_loop,u0,p,0.0)","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"DiffEqOperators.JacVecOperator{Float64, typeof(Main.##WeaveSandBox#5548.bru\nsselator_2d_loop), Array{ForwardDiff.Dual{DiffEqOperators.JacVecTag, Float6\n4, 1}, 3}, Array{ForwardDiff.Dual{DiffEqOperators.JacVecTag, Float64, 1}, 3\n}, Array{Float64, 3}, NTuple{4, Float64}, Float64, Bool}(Main.##WeaveSandBo\nx#5548.brusselator_2d_loop, ForwardDiff.Dual{DiffEqOperators.JacVecTag, Flo\nat64, 1}[Dual{DiffEqOperators.JacVecTag}(0.0,0.0) Dual{DiffEqOperators.JacV\necTag}(0.12134432813715876,0.12134432813715876) … Dual{DiffEqOperators.JacV\necTag}(0.1213443281371586,0.1213443281371586) Dual{DiffEqOperators.JacVecTa\ng}(0.0,0.0); Dual{DiffEqOperators.JacVecTag}(0.0,0.0) Dual{DiffEqOperators.\nJacVecTag}(0.12134432813715876,0.12134432813715876) … Dual{DiffEqOperators.\nJacVecTag}(0.1213443281371586,0.1213443281371586) Dual{DiffEqOperators.JacV\necTag}(0.0,0.0); … ; Dual{DiffEqOperators.JacVecTag}(0.0,0.0) Dual{DiffEqOp\nerators.JacVecTag}(0.12134432813715876,0.12134432813715876) … Dual{DiffEqOp\nerators.JacVecTag}(0.1213443281371586,0.1213443281371586) Dual{DiffEqOperat\nors.JacVecTag}(0.0,0.0); Dual{DiffEqOperators.JacVecTag}(0.0,0.0) Dual{Diff\nEqOperators.JacVecTag}(0.12134432813715876,0.12134432813715876) … Dual{Diff\nEqOperators.JacVecTag}(0.1213443281371586,0.1213443281371586) Dual{DiffEqOp\nerators.JacVecTag}(0.0,0.0)]\n\nForwardDiff.Dual{DiffEqOperators.JacVecTag, Float64, 1}[Dual{DiffEqOperator\ns.JacVecTag}(0.0,0.0) Dual{DiffEqOperators.JacVecTag}(0.0,0.0) … Dual{DiffE\nqOperators.JacVecTag}(0.0,0.0) Dual{DiffEqOperators.JacVecTag}(0.0,0.0); Du\nal{DiffEqOperators.JacVecTag}(0.14892258453196755,0.14892258453196755) Dual\n{DiffEqOperators.JacVecTag}(0.14892258453196755,0.14892258453196755) … Dual\n{DiffEqOperators.JacVecTag}(0.14892258453196755,0.14892258453196755) Dual{D\niffEqOperators.JacVecTag}(0.14892258453196755,0.14892258453196755); … ; Dua\nl{DiffEqOperators.JacVecTag}(0.14892258453196738,0.14892258453196738) Dual{\nDiffEqOperators.JacVecTag}(0.14892258453196738,0.14892258453196738) … Dual{\nDiffEqOperators.JacVecTag}(0.14892258453196738,0.14892258453196738) Dual{Di\nffEqOperators.JacVecTag}(0.14892258453196738,0.14892258453196738); Dual{Dif\nfEqOperators.JacVecTag}(0.0,0.0) Dual{DiffEqOperators.JacVecTag}(0.0,0.0) …\n Dual{DiffEqOperators.JacVecTag}(0.0,0.0) Dual{DiffEqOperators.JacVecTag}(0\n.0,0.0)], ForwardDiff.Dual{DiffEqOperators.JacVecTag, Float64, 1}[Dual{Diff\nEqOperators.JacVecTag}(0.0,0.0) Dual{DiffEqOperators.JacVecTag}(0.121344328\n13715876,0.12134432813715876) … Dual{DiffEqOperators.JacVecTag}(0.121344328\n1371586,0.1213443281371586) Dual{DiffEqOperators.JacVecTag}(0.0,0.0); Dual{\nDiffEqOperators.JacVecTag}(0.0,0.0) Dual{DiffEqOperators.JacVecTag}(0.12134\n432813715876,0.12134432813715876) … Dual{DiffEqOperators.JacVecTag}(0.12134\n43281371586,0.1213443281371586) Dual{DiffEqOperators.JacVecTag}(0.0,0.0); …\n ; Dual{DiffEqOperators.JacVecTag}(0.0,0.0) Dual{DiffEqOperators.JacVecTag}\n(0.12134432813715876,0.12134432813715876) … Dual{DiffEqOperators.JacVecTag}\n(0.1213443281371586,0.1213443281371586) Dual{DiffEqOperators.JacVecTag}(0.0\n,0.0); Dual{DiffEqOperators.JacVecTag}(0.0,0.0) Dual{DiffEqOperators.JacVec\nTag}(0.12134432813715876,0.12134432813715876) … Dual{DiffEqOperators.JacVec\nTag}(0.1213443281371586,0.1213443281371586) Dual{DiffEqOperators.JacVecTag}\n(0.0,0.0)]\n\nForwardDiff.Dual{DiffEqOperators.JacVecTag, Float64, 1}[Dual{DiffEqOperator\ns.JacVecTag}(0.0,0.0) Dual{DiffEqOperators.JacVecTag}(0.0,0.0) … Dual{DiffE\nqOperators.JacVecTag}(0.0,0.0) Dual{DiffEqOperators.JacVecTag}(0.0,0.0); Du\nal{DiffEqOperators.JacVecTag}(0.14892258453196755,0.14892258453196755) Dual\n{DiffEqOperators.JacVecTag}(0.14892258453196755,0.14892258453196755) … Dual\n{DiffEqOperators.JacVecTag}(0.14892258453196755,0.14892258453196755) Dual{D\niffEqOperators.JacVecTag}(0.14892258453196755,0.14892258453196755); … ; Dua\nl{DiffEqOperators.JacVecTag}(0.14892258453196738,0.14892258453196738) Dual{\nDiffEqOperators.JacVecTag}(0.14892258453196738,0.14892258453196738) … Dual{\nDiffEqOperators.JacVecTag}(0.14892258453196738,0.14892258453196738) Dual{Di\nffEqOperators.JacVecTag}(0.14892258453196738,0.14892258453196738); Dual{Dif\nfEqOperators.JacVecTag}(0.0,0.0) Dual{DiffEqOperators.JacVecTag}(0.0,0.0) …\n Dual{DiffEqOperators.JacVecTag}(0.0,0.0) Dual{DiffEqOperators.JacVecTag}(0\n.0,0.0)], [0.0 0.12134432813715876 … 0.1213443281371586 0.0; 0.0 0.12134432\n813715876 … 0.1213443281371586 0.0; … ; 0.0 0.12134432813715876 … 0.1213443\n281371586 0.0; 0.0 0.12134432813715876 … 0.1213443281371586 0.0]\n\n[0.0 0.0 … 0.0 0.0; 0.14892258453196755 0.14892258453196755 … 0.14892258453\n196755 0.14892258453196755; … ; 0.14892258453196738 0.14892258453196738 … 0\n.14892258453196738 0.14892258453196738; 0.0 0.0 … 0.0 0.0], (3.4, 1.0, 10.0\n, 0.03225806451612903), 0.0, true, false, true)","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"and then we can use this by making it our jac_prototype:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"f = ODEFunction(brusselator_2d_loop;jac_prototype=Jv)\nprob_ode_brusselator_2d_jacfree = ODEProblem(f,u0,(0.,11.5),p)\n@btime solve(prob_ode_brusselator_2d_jacfree,TRBDF2(linsolve=LinSolveGMRES()),save_everystep=false)","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"2.014 s (942433 allocations: 1.05 GiB)\nretcode: Success\nInterpolation: 1st order linear\nt: 2-element Vector{Float64}:\n  0.0\n 11.5\nu: 2-element Vector{Array{Float64, 3}}:\n [0.0 0.12134432813715876 … 0.1213443281371586 0.0; 0.0 0.12134432813715876\n … 0.1213443281371586 0.0; … ; 0.0 0.12134432813715876 … 0.1213443281371586\n 0.0; 0.0 0.12134432813715876 … 0.1213443281371586 0.0]\n\n[0.0 0.0 … 0.0 0.0; 0.14892258453196755 0.14892258453196755 … 0.14892258453\n196755 0.14892258453196755; … ; 0.14892258453196738 0.14892258453196738 … 0\n.14892258453196738 0.14892258453196738; 0.0 0.0 … 0.0 0.0]\n [1.328086637873347 1.328059197713509 … 1.3281748347697229 1.32812606585897\n29; 1.328130848643362 1.3280992632574358 … 1.3282306297437354 1.32817542936\n69061; … ; 1.3280077761453217 1.3279862091179504 … 1.3280777261839196 1.328\n0384277888153; 1.3280454775601096 1.3280204995302134 … 1.328123305013178 1.\n3280799053895886]\n\n[4.6985106146296785 4.698511510656312 … 4.698506092751332 4.698508731423445\n; 4.698506492475369 4.698507558534346 … 4.698502182960649 4.698504769487088\n; … ; 4.698517566578984 4.698518821016911 … 4.698513034821239 4.69851561364\n0851; 4.698514120257303 4.698515413421847 … 4.698509865089128 4.69851240717\n4246]","category":"page"},{"location":"advanced/02-advanced_ODE_solving/#Adding-a-Preconditioner","page":"Solving Stiff Equations","title":"Adding a Preconditioner","text":"","category":"section"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"The linear solver documentation shows how you can add a preconditioner to the GMRES. For example, you can use packages like AlgebraicMultigrid.jl to add an algebraic multigrid (AMG) or IncompleteLU.jl for an incomplete LU-factorization (iLU).","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"using AlgebraicMultigrid\npc = aspreconditioner(ruge_stuben(jac_sparsity))\n@btime solve(prob_ode_brusselator_2d_jacfree,TRBDF2(linsolve=LinSolveGMRES(Pl=pc)),save_everystep=false)","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"44.779 ms (2126 allocations: 4.62 MiB)\nretcode: Success\nInterpolation: 1st order linear\nt: 2-element Vector{Float64}:\n  0.0\n 11.5\nu: 2-element Vector{Array{Float64, 3}}:\n [0.0 0.12134432813715876 … 0.1213443281371586 0.0; 0.0 0.12134432813715876\n … 0.1213443281371586 0.0; … ; 0.0 0.12134432813715876 … 0.1213443281371586\n 0.0; 0.0 0.12134432813715876 … 0.1213443281371586 0.0]\n\n[0.0 0.0 … 0.0 0.0; 0.14892258453196755 0.14892258453196755 … 0.14892258453\n196755 0.14892258453196755; … ; 0.14892258453196738 0.14892258453196738 … 0\n.14892258453196738 0.14892258453196738; 0.0 0.0 … 0.0 0.0]\n [10517.228691133823 10903.17821877683 … 9234.374974925357 13421.8684240780\n77; 14610.689352333644 8520.29499343432 … 9234.400192154684 13421.868424078\n073; … ; 13421.868424078082 9234.400192154602 … 9234.40019215468 13421.8684\n24078077; 13421.86842407808 9234.37497492528 … 9234.374974925358 13421.8684\n24078077]\n\n[16505.210468729245 16435.39296876962 … 16462.923992780543 16458.1794295503\n68; 11307.018407220907 11343.187214827063 … 11331.237752550098 11326.518406\n549272; … ; 11326.518406549352 11331.23775255019 … 11331.237752550187 11326\n.518406549356; 16458.179429550346 16462.923992780536 … 16462.923992780536 1\n6458.179429550346]","category":"page"},{"location":"advanced/02-advanced_ODE_solving/#Using-Structured-Matrix-Types","page":"Solving Stiff Equations","title":"Using Structured Matrix Types","text":"","category":"section"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"If your sparsity pattern follows a specific structure, for example a banded matrix, then you can declare jac_prototype to be of that structure and then additional optimizations will come for free. Note that in this case, it is not necessary to provide a colorvec since the color vector will be analytically derived from the structure of the matrix.","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"The matrices which are allowed are those which satisfy the ArrayInterface.jl interface for automatically-colorable matrices. These include:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Bidiagonal\nTridiagonal\nSymTridiagonal\nBandedMatrix (BandedMatrices.jl)\nBlockBandedMatrix (BlockBandedMatrices.jl)","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Matrices which do not satisfy this interface can still be used, but the matrix coloring will not be automatic, and an appropriate linear solver may need to be given (otherwise it will default to attempting an LU-decomposition).","category":"page"},{"location":"advanced/02-advanced_ODE_solving/#Sundials-Specific-Handling","page":"Solving Stiff Equations","title":"Sundials-Specific Handling","text":"","category":"section"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"While much of the setup makes the transition to using Sundials automatic, there are some differences between the pure Julia implementations and the Sundials implementations which must be taken note of. These are all detailed in the Sundials solver documentation, but here we will highlight the main details which one should make note of.","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Defining a sparse matrix and a Jacobian for Sundials works just like any other package. The core difference is in the choice of the linear solver. With Sundials, the linear solver choice is done with a Symbol in the linear_solver from a preset list. Particular choices of note are :Band for a banded matrix and :GMRES for using GMRES. If you are using Sundials, :GMRES will not require defining the JacVecOperator, and instead will always make use of a Jacobian-Free Newton Krylov (with numerical differentiation). Thus on this problem we could do:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"using Sundials\n# Sparse Version\n@btime solve(prob_ode_brusselator_2d_sparse,CVODE_BDF(),save_everystep=false)\n# GMRES Version: Doesn't require any extra stuff!\n@btime solve(prob_ode_brusselator_2d,CVODE_BDF(linear_solver=:GMRES),save_everystep=false)","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"14.773 s (51406 allocations: 3.40 MiB)\n  328.528 ms (61034 allocations: 3.62 MiB)\nretcode: Success\nInterpolation: 1st order linear\nt: 2-element Vector{Float64}:\n  0.0\n 11.5\nu: 2-element Vector{Array{Float64, 3}}:\n [0.0 0.12134432813715876 … 0.1213443281371586 0.0; 0.0 0.12134432813715876\n … 0.1213443281371586 0.0; … ; 0.0 0.12134432813715876 … 0.1213443281371586\n 0.0; 0.0 0.12134432813715876 … 0.1213443281371586 0.0]\n\n[0.0 0.0 … 0.0 0.0; 0.14892258453196755 0.14892258453196755 … 0.14892258453\n196755 0.14892258453196755; … ; 0.14892258453196738 0.14892258453196738 … 0\n.14892258453196738 0.14892258453196738; 0.0 0.0 … 0.0 0.0]\n [0.45369441125092624 0.45367162922766396 … 0.45377307354145824 0.453728249\n24331306; 0.45372813444006976 0.45370139820263283 … 0.45382031508907966 0.4\n537681622154197; … ; 0.4536347409999057 0.4536184243336325 … 0.453690734603\n503 0.4536589378647838; 0.4536631791063342 0.4536436405637919 … 0.453729310\n5001047 0.45369169445940305]\n\n[5.023428953606044 5.023425514309876 … 5.02343972583798 5.0234337753788845;\n 5.023442660236476 5.023439873077652 … 5.02345101637559 5.023446317614284; \n… ; 5.023404093671991 5.023399216246354 … 5.023419229667771 5.0234107290209\n42; 5.023415926060523 5.023411776722086 … 5.02342895844194 5.02342180621704\n3]","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Details for setting up a preconditioner with Sundials can be found at the Sundials solver page.","category":"page"},{"location":"advanced/02-advanced_ODE_solving/#Handling-Mass-Matrices","page":"Solving Stiff Equations","title":"Handling Mass Matrices","text":"","category":"section"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Instead of just defining an ODE as u = f(upt), it can be common to express the differential equation in the form with a mass matrix:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Mu = f(upt)","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"where M is known as the mass matrix. Let's solve the Robertson equation. At the top we wrote this equation as:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"beginalign\ndy_1 = -004y₁ + 10^4 y_2 y_3 \ndy_2 = 004 y_1 - 10^4 y_2 y_3 - 3*10^7 y_2^2 \ndy_3 = 3*10^7 y_3^2 \nendalign","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"But we can instead write this with a conservation relation:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"beginalign\ndy_1 = -004y₁ + 10^4 y_2 y_3 \ndy_2 = 004 y_1 - 10^4 y_2 y_3 - 3*10^7 y_2^2 \n1 =  y_1 + y_2 + y_3 \nendalign","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"In this form, we can write this as a mass matrix ODE where M is singular (this is another form of a differential-algebraic equation (DAE)). Here, the last row of M is just zero. We can implement this form as:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"using DifferentialEquations\nfunction rober(du,u,p,t)\n  y₁,y₂,y₃ = u\n  k₁,k₂,k₃ = p\n  du[1] = -k₁*y₁+k₃*y₂*y₃\n  du[2] =  k₁*y₁-k₂*y₂^2-k₃*y₂*y₃\n  du[3] =  y₁ + y₂ + y₃ - 1\n  nothing\nend\nM = [1. 0  0\n     0  1. 0\n     0  0  0]\nf = ODEFunction(rober,mass_matrix=M)\nprob_mm = ODEProblem(f,[1.0,0.0,0.0],(0.0,1e5),(0.04,3e7,1e4))\nsol = solve(prob_mm,Rodas5())\n\nplot(sol, xscale=:log10, tspan=(1e-6, 1e5), layout=(3,1))","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"(Image: )","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Note that if your mass matrix is singular, i.e. your system is a DAE, then you need to make sure you choose a solver that is compatible with DAEs","category":"page"},{"location":"advanced/02-advanced_ODE_solving/#Appendix","page":"Solving Stiff Equations","title":"Appendix","text":"","category":"section"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"advanced\",\"02-advanced_ODE_solving.jmd\")","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Computer Information:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Julia Version 1.6.5\nCommit 9058264a69 (2021-12-19 12:30 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, znver2)\nEnvironment:\n  JULIA_CPU_THREADS = 16\n  BUILDKITE_PLUGIN_JULIA_CACHE_DIR = /cache/julia-buildkite-plugin\n  JULIA_DEPOT_PATH = /cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"Package Information:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"      Status `/cache/build/default-amdci4-2/julialang/scimltutorials-dot-jl/tutorials/advanced/Project.toml`\n  [2169fc97] AlgebraicMultigrid v0.4.0\n  [6e4b80f9] BenchmarkTools v1.0.0\n  [052768ef] CUDA v2.6.3\n  [2b5f629d] DiffEqBase v6.62.2\n  [9fdde737] DiffEqOperators v4.26.0\n  [0c46a032] DifferentialEquations v6.17.1\n  [587475ba] Flux v0.12.1\n  [961ee093] ModelingToolkit v5.17.3\n  [2774e3e8] NLsolve v4.5.1\n  [315f7962] NeuralPDE v3.10.1\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [91a5bcdd] Plots v1.15.2\n  [0bca4576] SciMLBase v1.13.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [47a9eef4] SparseDiffTools v1.13.2\n  [684fba80] SparsityDetection v0.3.4\n  [789caeaf] StochasticDiffEq v6.34.1\n  [c3572dad] Sundials v4.4.3\n  [37e2e46d] LinearAlgebra\n  [2f01184e] SparseArrays","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"And the full manifest:","category":"page"},{"location":"advanced/02-advanced_ODE_solving/","page":"Solving Stiff Equations","title":"Solving Stiff Equations","text":"      Status `/cache/build/default-amdci4-2/julialang/scimltutorials-dot-jl/tutorials/advanced/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.16.0\n  [621f4979] AbstractFFTs v1.0.1\n  [1520ce14] AbstractTrees v0.3.4\n  [79e6a3ab] Adapt v3.3.0\n  [2169fc97] AlgebraicMultigrid v0.4.0\n  [ec485272] ArnoldiMethod v0.1.0\n  [4fba245c] ArrayInterface v3.1.15\n  [4c555306] ArrayLayouts v0.7.0\n  [13072b0f] AxisAlgorithms v1.0.0\n  [ab4f0b2a] BFloat16s v0.1.0\n  [aae01518] BandedMatrices v0.16.9\n  [6e4b80f9] BenchmarkTools v1.0.0\n  [8e7c35d0] BlockArrays v0.15.3\n  [ffab5731] BlockBandedMatrices v0.10.6\n  [764a87c0] BoundaryValueDiffEq v2.7.1\n  [fa961155] CEnum v0.4.1\n  [00ebfdb7] CSTParser v2.5.0\n  [052768ef] CUDA v2.6.3\n  [7057c7e9] Cassette v0.3.6\n  [082447d4] ChainRules v0.7.65\n  [d360d2e6] ChainRulesCore v0.9.44\n  [b630d9fa] CheapThreads v0.2.5\n  [944b1d66] CodecZlib v0.7.0\n  [35d6a980] ColorSchemes v3.12.1\n  [3da002f7] ColorTypes v0.11.0\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [a80b9123] CommonMark v0.8.1\n  [38540f10] CommonSolve v0.2.0\n  [bbf7d656] CommonSubexpressions v0.3.0\n  [34da2185] Compat v3.30.0\n  [aa819f21] CompatHelper v1.18.6\n  [8f4d0f93] Conda v1.5.2\n  [88cd18e8] ConsoleProgressMonitor v0.1.2\n  [187b0558] ConstructionBase v1.2.1\n  [d38c429a] Contour v0.5.7\n  [a8cc5b0e] Crayons v4.0.4\n  [8a292aeb] Cuba v2.2.0\n  [667455a9] Cubature v1.5.1\n  [9a962f9c] DataAPI v1.6.0\n  [82cc6244] DataInterpolations v3.3.1\n  [864edb3b] DataStructures v0.18.9\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [bcd4f6db] DelayDiffEq v5.31.0\n  [2b5f629d] DiffEqBase v6.62.2\n  [459566f4] DiffEqCallbacks v2.16.1\n  [5a0ffddc] DiffEqFinancial v2.4.0\n  [aae7a2af] DiffEqFlux v1.37.0\n  [c894b116] DiffEqJump v6.14.2\n  [77a26b50] DiffEqNoiseProcess v5.7.3\n  [9fdde737] DiffEqOperators v4.26.0\n  [055956cb] DiffEqPhysics v3.9.0\n  [41bf760c] DiffEqSensitivity v6.45.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.0.2\n  [0c46a032] DifferentialEquations v6.17.1\n  [c619ae07] DimensionalPlotRecipes v1.2.0\n  [b4f34e82] Distances v0.10.3\n  [31c24e10] Distributions v0.24.18\n  [ced4e74d] DistributionsAD v0.6.26\n  [ffbed154] DocStringExtensions v0.8.4\n  [e30172f5] Documenter v0.26.3\n  [d4d017d3] ExponentialUtilities v1.8.4\n  [e2ba6199] ExprTools v0.1.3\n  [8f5d6c58] EzXML v1.1.0\n  [c87230d0] FFMPEG v0.4.0\n  [7a1cc6ca] FFTW v1.4.1\n  [7034ab61] FastBroadcast v0.1.8\n  [9aa1b823] FastClosures v0.3.2\n  [1a297f60] FillArrays v0.11.7\n  [6a86dc24] FiniteDiff v2.8.0\n  [53c48c17] FixedPointNumbers v0.8.4\n  [587475ba] Flux v0.12.1\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.18\n  [069b7b12] FunctionWrappers v1.1.2\n  [d9f16b24] Functors v0.2.1\n  [0c68f7d7] GPUArrays v6.4.1\n  [61eb1bfa] GPUCompiler v0.10.0\n  [28b8d3ca] GR v0.57.4\n  [a75be94c] GalacticOptim v1.2.0\n  [5c1252a2] GeometryBasics v0.3.12\n  [bc5e4493] GitHub v5.4.0\n  [af5da776] GlobalSensitivity v1.0.0\n  [42e2da0e] Grisu v1.0.2\n  [19dc6840] HCubature v1.5.0\n  [cd3eb016] HTTP v0.9.9\n  [eafb193a] Highlights v0.4.5\n  [0e44f5e4] Hwloc v2.0.0\n  [7073ff75] IJulia v1.23.2\n  [b5f81e59] IOCapture v0.1.1\n  [7869d1d1] IRTools v0.4.2\n  [615f187c] IfElse v0.1.0\n  [d25df0c9] Inflate v0.1.2\n  [83e8ac13] IniFile v0.5.0\n  [a98d9a8b] Interpolations v0.13.2\n  [c8e1da08] IterTools v1.3.0\n  [42fd0dbc] IterativeSolvers v0.9.1\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.3.0\n  [682c06a0] JSON v0.21.1\n  [98e50ef6] JuliaFormatter v0.13.7\n  [e5e0dc1b] Juno v0.8.4\n  [5ab0869b] KernelDensity v0.6.3\n  [929cbde3] LLVM v3.7.1\n  [b964fa9f] LaTeXStrings v1.2.1\n  [2ee39098] LabelledArrays v1.6.1\n  [23fbe1c1] Latexify v0.15.5\n  [a5e1c1ea] LatinHypercubeSampling v1.8.0\n  [73f95e8e] LatticeRules v0.0.1\n  [5078a376] LazyArrays v0.21.4\n  [d7e5e226] LazyBandedMatrices v0.5.7\n  [1d6d02ad] LeftChildRightSiblingTrees v0.1.2\n  [093fc24a] LightGraphs v1.3.5\n  [d3d80556] LineSearches v7.1.1\n  [2ab3a3ac] LogExpFunctions v0.2.4\n  [e6f89c97] LoggingExtras v0.4.6\n  [bdcacae8] LoopVectorization v0.12.23\n  [1914dd2f] MacroTools v0.5.6\n  [a3b82374] MatrixFactorizations v0.8.3\n  [739be429] MbedTLS v1.0.3\n  [442fdcdd] Measures v0.3.1\n  [e89f7d12] Media v0.5.0\n  [c03570c3] Memoize v0.4.4\n  [e1d29d7a] Missings v1.0.0\n  [78c3b35d] Mocking v0.7.1\n  [961ee093] ModelingToolkit v5.17.3\n  [4886b29c] MonteCarloIntegration v0.0.2\n  [46d2c3a1] MuladdMacro v0.2.2\n  [f9640e96] MultiScaleArrays v1.8.1\n  [ffc61752] Mustache v1.0.10\n  [d41bc354] NLSolversBase v7.8.0\n  [2774e3e8] NLsolve v4.5.1\n  [872c559c] NNlib v0.7.19\n  [77ba4419] NaNMath v0.3.5\n  [315f7962] NeuralPDE v3.10.1\n  [8913a72c] NonlinearSolve v0.3.8\n  [6fe1bfb0] OffsetArrays v1.9.0\n  [429524aa] Optim v1.3.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [90014a1f] PDMats v0.11.0\n  [65888b18] ParameterizedFunctions v5.10.0\n  [d96e819e] Parameters v0.12.2\n  [69de0a69] Parsers v1.1.0\n  [ccf2f8ad] PlotThemes v2.0.1\n  [995b91a9] PlotUtils v1.0.10\n  [91a5bcdd] Plots v1.15.2\n  [e409e4f3] PoissonRandom v0.4.0\n  [f517fe37] Polyester v0.3.1\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [21216c6a] Preferences v1.2.2\n  [33c8b6b6] ProgressLogging v0.1.4\n  [92933f4c] ProgressMeter v1.6.2\n  [1fd47b50] QuadGK v2.4.1\n  [67601950] Quadrature v1.8.1\n  [8a4e6c94] QuasiMonteCarlo v0.2.2\n  [74087812] Random123 v1.3.1\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.4.0\n  [c84ed2f1] Ratios v0.4.0\n  [3cdcf5f2] RecipesBase v1.1.1\n  [01d81517] RecipesPipeline v0.3.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [f2c3362d] RecursiveFactorization v0.1.12\n  [189a3867] Reexport v1.0.0\n  [ae029012] Requires v1.1.3\n  [ae5879a3] ResettableStacks v1.1.0\n  [37e2e3b7] ReverseDiff v1.9.0\n  [79098fc4] Rmath v0.7.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.2\n  [476501e8] SLEEFPirates v0.6.20\n  [1bc83da4] SafeTestsets v0.0.1\n  [0bca4576] SciMLBase v1.13.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [6c6a2e73] Scratch v1.0.3\n  [efcf1570] Setfield v0.7.0\n  [992d4aef] Showoff v1.0.3\n  [699a6c99] SimpleTraits v0.9.3\n  [ed01d8cd] Sobol v1.5.0\n  [2133526b] SodiumSeal v0.1.1\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.0\n  [47a9eef4] SparseDiffTools v1.13.2\n  [684fba80] SparsityDetection v0.3.4\n  [276daf66] SpecialFunctions v1.4.1\n  [860ef19b] StableRNGs v1.0.0\n  [aedffcd0] Static v0.2.4\n  [90137ffa] StaticArrays v1.2.0\n  [82ae8749] StatsAPI v1.0.0\n  [2913bbd2] StatsBase v0.33.8\n  [4c63d2b9] StatsFuns v0.9.8\n  [9672c7b4] SteadyStateDiffEq v1.6.2\n  [789caeaf] StochasticDiffEq v6.34.1\n  [7792a7ef] StrideArraysCore v0.1.11\n  [09ab397b] StructArrays v0.5.1\n  [c3572dad] Sundials v4.4.3\n  [d1185830] SymbolicUtils v0.11.2\n  [0c5d862f] Symbolics v0.1.25\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.4.2\n  [5d786b92] TerminalLoggers v0.1.3\n  [8290d209] ThreadingUtilities v0.4.4\n  [f269a46b] TimeZones v1.5.5\n  [a759f4b9] TimerOutputs v0.5.9\n  [0796e94c] Tokenize v0.5.16\n  [9f7883ad] Tracker v0.2.16\n  [3bb67fe8] TranscodingStreams v0.9.5\n  [592b5752] Trapz v2.0.2\n  [a2a6695c] TreeViews v0.3.0\n  [5c2747f8] URIs v1.3.0\n  [3a884ed6] UnPack v1.0.2\n  [1986cc42] Unitful v1.7.0\n  [3d5dd08c] VectorizationBase v0.20.11\n  [81def892] VersionParsing v1.2.0\n  [19fa3120] VertexSafeGraphs v0.1.2\n  [44d3d7a6] Weave v0.10.8\n  [efce3f68] WoodburyMatrices v0.5.3\n  [ddb6d928] YAML v0.4.6\n  [c2297ded] ZMQ v1.2.1\n  [a5390f91] ZipFile v0.9.3\n  [e88e6eb3] Zygote v0.6.11\n  [700de1a5] ZygoteRules v0.2.1\n  [6e34b625] Bzip2_jll v1.0.6+5\n  [83423d85] Cairo_jll v1.16.0+6\n  [3bed1096] Cuba_jll v4.2.1+0\n  [7bc98958] Cubature_jll v1.0.4+0\n  [5ae413db] EarCut_jll v2.1.5+1\n  [2e619515] Expat_jll v2.2.10+0\n  [b22a6f82] FFMPEG_jll v4.3.1+4\n  [f5851436] FFTW_jll v3.3.9+7\n  [a3f928ae] Fontconfig_jll v2.13.1+14\n  [d7e528f0] FreeType2_jll v2.10.1+5\n  [559328eb] FriBidi_jll v1.0.5+6\n  [0656b61e] GLFW_jll v3.3.4+0\n  [d2c73de3] GR_jll v0.57.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.1+0\n  [e33a78d0] Hwloc_jll v2.4.1+0\n  [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2\n  [aacddb02] JpegTurbo_jll v2.0.1+3\n  [c1c5ebd0] LAME_jll v3.100.0+3\n  [dd4b983a] LZO_jll v2.10.1+0\n  [dd192d2f] LibVPX_jll v1.9.0+1\n  [e9f186c6] Libffi_jll v3.2.2+0\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+0\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.1.0+2\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [856f044c] MKL_jll v2021.1.1+1\n  [e7412a2a] Ogg_jll v1.3.4+2\n  [458c3c95] OpenSSL_jll v1.1.1+6\n  [efe28fd5] OpenSpecFun_jll v0.5.4+0\n  [91d4177d] Opus_jll v1.3.1+3\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.2+0\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.0+1\n  [a2964d1f] Wayland_jll v1.17.0+4\n  [2381bf8a] Wayland_protocols_jll v1.18.0+4\n  [02c8fc9c] XML2_jll v2.9.12+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.2+6\n  [3161d3a3] Zstd_jll v1.5.0+0\n  [0ac62f75] libass_jll v0.14.0+4\n  [f638f0a6] libfdk_aac_jll v0.1.6+4\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.6+6\n  [1270edf5] x264_jll v2020.7.14+2\n  [dfaa095f] x265_jll v3.0.0+3\n  [d8fb68d0] xkbcommon_jll v0.9.1+5\n  [0dad84c5] ArgTools\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [4af54fe1] LazyArtifacts\n  [b27032c2] LibCURL\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions\n  [44cfe95a] Pkg\n  [de0858da] Printf\n  [9abbd945] Profile\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML\n  [a4e569a6] Tar\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll\n  [deac9b47] LibCURL_jll\n  [29816b5a] LibSSH2_jll\n  [c8ffd9c3] MbedTLS_jll\n  [14a3606d] MozillaCACerts_jll\n  [4536629a] OpenBLAS_jll\n  [bea87d4a] SuiteSparse_jll\n  [83775a58] Zlib_jll\n  [8e850ede] nghttp2_jll\n  [3f19e933] p7zip_jll","category":"page"},{"location":"exercises/01-workshop_exercises/#SciML-Workshop-Exercises","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"These exercises teach common workflows which involve SciML's tools like DifferentialEquations.jl, DiffEqFlux.jl, and the connections to parts like stochastic differential equations and Bayesian estimation. The designation (B) is for \"Beginner\", meaning that a user new to the package should feel comfortable trying this exercise. An exercise designated (I) is for \"Intermediate\", meaning the user may want to have some previous background in DifferentialEquations.jl or try some (B) exercises first. The additional (E) designation is for \"Experienced\", which are portions of exercises which may take some work.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"The exercises are described as follows:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Exercise 1 takes the user through solving a stiff ordinary differential equation and using the ModelingToolkit.jl to automatically convert the function to a symbolic form to derive the analytical Jacobian to speed up the solver. The same biological system is then solved with stochasticity, utilizing EnsembleProblems to understand 95% bounds on the solution. Finally, probabilistic programming is employed to perform Bayesian parameter estimation of the parameters against data.\nExercise 2 takes the user through defining hybrid delay differential equation, that is a differential equation with events, and using differentiable programming techniques (automatic differentiation) to to perform gradient-based parameter estimation.\nExercise 3 takes the user through differential-algebraic equation (DAE) modeling, the concept of index, and using both mass-matrix and implicit ODE representations. This will require doing a bit of math, but the student will understand how to change their equations to make their DAE numerically easier for the integrators.\nExercise 4 takes the user through optimizing a PDE solver, utilizing automatic sparsity pattern recognition, automatic conversion of numerical codes to symbolic codes for analytical construction of the Jacobian, preconditioned GMRES, and setting up a solver for IMEX and GPUs, and compute adjoints of PDEs.\nExercise 5 focuses on a chaotic orbit, utilizing parallel ensembles across supercomputers and GPUs to quickly describe phase space.\nExercise 6 takes the user through training a neural stochastic differential equation, using GPU-accleration and adjoints through Flux.jl's neural network framework to build efficient training codes.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"This exercise worksheet is meant to be a living document leading new users through a deep dive of the DifferentialEquations.jl feature set. If you further suggestions or want to contribute new problems, please open an issue or PR at the SciMLTutorials.jl repository.","category":"page"},{"location":"exercises/01-workshop_exercises/#Problem-1:-Investigating-Sources-of-Randomness-and-Uncertainty-in-a-Stiff-Biological-System-(B)","page":"SciML Workshop Exercises","title":"Problem 1: Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"In this problem we will walk through the basics of simulating models with DifferentialEquations.jl. Let's take the Oregonator model of the Belousov-Zhabotinskii chemical reaction system. This system describes a classical example in non-equilibrium thermodynmics and is a well-known natural chemical oscillator.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-1:-Simulating-the-Oregonator-ODE-model","page":"SciML Workshop Exercises","title":"Part 1: Simulating the Oregonator ODE model","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"When modeling, usually one starts off by investigating the deterministic model. The deterministic ODE formulation of the Oregonator is given by the equations","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"beginalign\nfracdxdt = s(y-xy + x - qx^2)\nfracdydt = (-y - xy + z)s\nfracdzdt = w(x - z)endalign","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"with parameter values s=7727, w=0161, and q=8375 times 10^-6, and initial conditions x(0)=1, y(0)=2, and z(0)=3. Use the tutorial on solving ODEs to solve this differential equation on the timespan of tin0360 with the default ODE solver. To investigate the result, plot the solution of all components over time, and plot the phase space plot of the solution (hint: use vars=(1,2,3)). What shape is being drawn in phase space?","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-2:-Investigating-Stiffness","page":"SciML Workshop Exercises","title":"Part 2: Investigating Stiffness","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Because the reaction rates of q vs s is very large, this model has a \"fast\" system and a \"slow\" system. This is typical of ODEs which exhibit a property known as stiffness. Stiffness changes the ODE solvers which can handle the equation well. Take a look at the ODE solver page and investigate solving the equation using methods for non-stiff equations (ex: Tsit5) and stiff equations (ex: Rodas5).","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Benchmark using tin050 using @btime from BenchmarkTools.jl. What happens when you increase the timespan?","category":"page"},{"location":"exercises/01-workshop_exercises/#(Optional)-Part-3:-Specifying-Analytical-Jacobians-(I)","page":"SciML Workshop Exercises","title":"(Optional) Part 3: Specifying Analytical Jacobians (I)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Stiff ODE solvers internally utilize the Jacobian of the ODE system in order to improve the stepsizes in the solution. However, computing and factorizing the Jacobian is costly, and thus it can be beneficial to provide the analytical solution.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the ODEFunction definition page to define an ODEFunction which holds both the OREGO ODE and its Jacobian, and solve using Rodas5.","category":"page"},{"location":"exercises/01-workshop_exercises/#(Optional)-Part-4:-Automatic-Symbolicification-and-Analytical-Jacobian-Calculations","page":"SciML Workshop Exercises","title":"(Optional) Part 4: Automatic Symbolicification and Analytical Jacobian Calculations","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Deriving Jacobians by hand is tedious. Thankfully symbolic mathematical systems can do the work for you. And thankfully, DifferentialEquations.jl has tools to automatically convert numerical problems into symbolic problems to perform the analysis on!","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"follow the ModelingToolkit.jl README to automatically convert your ODE definition to its symbolic form using modelingtoolkitize and calculate the analytical Jacobian. Use the compilation functions to build the ODEFunction with the embedded analytical solution.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-5:-Adding-stochasticity-with-stochastic-differential-equations","page":"SciML Workshop Exercises","title":"Part 5: Adding stochasticity with stochastic differential equations","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"How does this system react in the presense of stochasticity? We can investigate this question by using stochastic differential equations. A stochastic differential equation formulation of this model is known as the multiplicative noise model, is created with:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"beginalign\ndx = s(y-xy + x - qx^2)dt + sigma_1 x dW_1\ndy = frac-y - xy + zsdt + sigma_2 y dW_2\ndz = w(x - z)dt + sigma_3 z dW_3endalign","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"with sigma_i = 01 where the dW terms describe a Brownian motion, a continuous random process with normally distributed increments. Use the tutorial on solving SDEs to solve simulate this model. Then, use the EnsembleProblem to generate and plot 100 trajectories of the stochastic model, and use EnsembleSummary to plot the mean and 5%-95% region over time.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Try solving with the ImplicitRKMil and SOSRI methods. Notice that it isn't stiff every single time!","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"(For fun, see if you can make the Euler-Maruyama EM() method solve this equation. This requires a choice of dt small enough to be stable. This is the \"standard\" method!)","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-6:-Gillespie-jump-models-of-discrete-stochasticity","page":"SciML Workshop Exercises","title":"Part 6: Gillespie jump models of discrete stochasticity","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"When biological models have very few particles, continuous models no longer make sense, and instead using the full discrete formulation can be required to accuracy describe the dynamics. A discrete differential equation, or Gillespie model, is a continuous-time Markov chain with Poisson-distributed jumps. A discrete description of the Oregonator model is given by a chemical reaction systems:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"\nA+Y -> X+P\nX+Y -> 2P\nA+X -> 2X + 2Z\n2X  -> A + P (note: this has rate kX^2!)\nB + Z -> Y","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"where reactions take place at a rate which is propoertional to its components, i.e. the first reaction has a rate k*A*Y for some k. Use the tutorial on Gillespie SSA models to implement the JumpProblem for this model, and use the EnsembleProblem and EnsembleSummary to characterize the stochastic trajectories.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"For what rate constants does the model give the oscillatory dynamics for the ODE approximation? For information on the true reaction rates, consult the original paper.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-7:-Probabilistic-Programming-/-Bayesian-Parameter-Estimation-with-DiffEqBayes.jl-Turing.jl-(I)","page":"SciML Workshop Exercises","title":"Part 7: Probabilistic Programming / Bayesian Parameter Estimation with DiffEqBayes.jl + Turing.jl (I)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"In many casees, one comes to understand the proper values for their model's parameters by utilizing data fitting techniques. In this case, we will use the DiffEqBayes.jl library to perform a Bayesian estimation of the parameters. For our data we will the following potential output:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"\nt = 0.0:1.0:30.0\ndata = [1.0 2.05224 2.11422 2.1857 2.26827 2.3641 2.47618 2.60869 2.7677 2.96232 3.20711 3.52709 3.97005 4.64319 5.86202 9.29322 536.068 82388.9 57868.4 1.00399 1.00169 1.00117 1.00094 1.00082 1.00075 1.0007 1.00068 1.00066 1.00065 1.00065 1.00065\n        2.0 1.9494 1.89645 1.84227 1.78727 1.73178 1.67601 1.62008 1.56402 1.50772 1.45094 1.39322 1.33366 1.2705 1.19958 1.10651 0.57194 0.180316 0.431409 251.774 591.754 857.464 1062.78 1219.05 1335.56 1419.88 1478.22 1515.63 1536.25 1543.45 1539.98\n        3.0 2.82065 2.68703 2.58974 2.52405 2.48644 2.47449 2.48686 2.52337 2.58526 2.67563 2.80053 2.9713 3.21051 3.5712 4.23706 12.0266 14868.8 24987.8 23453.4 19202.2 15721.6 12872.0 10538.8 8628.66 7064.73 5784.29 4735.96 3877.66 3174.94 2599.6]","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Follow the exmaples on the parameter estimation page to perform a Bayesian parameter estimation. What are the most likely parameters for the model given the posterior parameter distributions?","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the ODEProblem to perform the fit. If you have time, use the EnsembleProblem of SDEProblems to perform a fit over averages of the SDE solutions. Note that the SDE fit will take significantly more computational resources! See the GPU parallelism section for details on how to accelerate this.","category":"page"},{"location":"exercises/01-workshop_exercises/#(Optional)-Part-8:-Using-DiffEqBiological's-Reaction-Network-DSL","page":"SciML Workshop Exercises","title":"(Optional) Part 8: Using DiffEqBiological's Reaction Network DSL","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"DiffEqBiological.jl is a helper library for the DifferentialEquations.jl ecosystem for defining chemical reaction systems at a high leevel for easy simulation in these various forms. Use the descrption from the Chemical Reaction Networks documentation page to build a reaction network and generate the ODE/SDE/jump equations, and compare the result to your handcoded versions.","category":"page"},{"location":"exercises/01-workshop_exercises/#Problem-2:-Fitting-Hybrid-Delay-Pharmacokinetic-Models-with-Automated-Responses-(B)","page":"SciML Workshop Exercises","title":"Problem 2: Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Hybrid differential equations are differential equations with events, where events are some interaction that occurs according to a prespecified condition. For example, the bouncing ball is a classic hybrid differential equation given by an ODE (Newton's Law of Gravity) mixed with the fact that, whenever the ball hits the floor (x=0), then the velocity of the ball flips (v=-v).","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"In addition, many models incorporate delays, that is the driving force of the equation is dependent not on the current values, but values from the past. These delay differential equations model how individuals in the economy act on old information, or that biological processes take time to adapt to a new environment.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"In this equation we will build a hybrid delayed pharmacokinetic model and use the parameter estimation techniques to fit this it to a data.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-1:-Defining-an-ODE-with-Predetermined-Doses","page":"SciML Workshop Exercises","title":"Part 1: Defining an ODE with Predetermined Doses","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"First, let's define the simplest hybrid ordinary differential equation: an ODE where the events take place at fixed times. The ODE we will use is known as the one-compartment model:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"beginalign\nfracdDepotdt = -K_a Depot + R\nfracdCentraldt = K_a Depot - K_e Centralendalign","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"with t in 090, u_0 = 10000, and p=K_aK_e=2268007398.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"With this model, use the event handling documentation page to define a DiscreteCallback which fires at t ∈ [24,48,72] and adds a dose of 100 into [Depot]. (Hint: you'll want to set tstops=[24,48,72] to force the ODE solver to step at these times).","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-2:-Adding-Delays","page":"SciML Workshop Exercises","title":"Part 2: Adding Delays","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Now let's assume that instead of there being one compartment, there are many transit compartment that the drug must move through in order to reach the central compartment. This effectively delays the effect of the transition from [Depot] to [Central]. To model this effect, we will use the delay differential equation which utilizes a fixed time delay tau:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"beginalign\nfracdDepotdt = -K_a Depot(t)\nfracdCentraldt = K_a Depot(t-tau) - K_e Centralendalign","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"where the parameter τ = 60. Use the DDE tutorial to define and solve this delayed version of the hybrid model.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-3:-Automatic-Differentiation-(AD)-for-Optimization-(I)","page":"SciML Workshop Exercises","title":"Part 3: Automatic Differentiation (AD) for Optimization (I)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"In order to fit parameters (K_aK_etau) we will want to be able to calculate the gradient of the solution with respect to the initial conditions. One way to do this is via Automatic Differentition (AD). For small numbers of parameters (<100), it is fastest to use Forward-Mode Automatic Differentition (even faster than using adjoint sensitivity analysis!). Thus for this problem we will make use of ForwardDiff.jl to use Dual number arithmetic to retrive both the solution and its derivative w.r.t. parameters in a single solve.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the information from the page on local sensitvity analysis to define the input dual numbers, solve the equation, and plot both the solution over time and the derivative of the solution w.r.t. the parameters.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-4:-Fitting-Known-Quantities-with-DiffEqParamEstim.jl-Optim.jl","page":"SciML Workshop Exercises","title":"Part 4: Fitting Known Quantities with DiffEqParamEstim.jl + Optim.jl","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Now let's fit the delayed model to a dataset. For the data, use the array","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"\nt = 0.0:12.0:90.0\ndata = [100.0 0.246196 0.000597933 0.24547 0.000596251 0.245275 0.000595453 0.245511\n        0.0 53.7939 16.8784 58.7789 18.3777 59.1879 18.5003 59.2611]","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the parameter estimation page to define a loss function with build_loss_objective and optimize the parameters against the data. What parameters were used to generate the data?","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-5:-Implementing-Control-Based-Logic-with-ContinuousCallbacks-(I)","page":"SciML Workshop Exercises","title":"Part 5: Implementing Control-Based Logic with ContinuousCallbacks (I)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Now that we have fit our delay differential equation model to the dataset, we want to start testing out automated treatment strategies. Let's assume that instead of giving doses at fixed time points, we invent a wearable which monitors the patient and administers a dose whenever the internal drug concentration falls below 25. To model this effect, we will need to use ContinuousCallbacks to define a callback that triggers when [Central] falls below the threshold value.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the documentation on the event handling page to define such a callback, and plot the solution over time. How many times does the auto-doser administer a dose? How much does this change as you change the delay time tau?","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-6:-Global-Sensitivity-Analysis-with-the-Morris-and-Sobol-Methods","page":"SciML Workshop Exercises","title":"Part 6: Global Sensitivity Analysis with the Morris and Sobol Methods","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"To understand how the parameters effect the solution in a global sense, one wants to use Global Sensitivity Analysis. Use the GSA documentation page perform global sensitivity analysis and quantify the effect of the various parameters on the solution.","category":"page"},{"location":"exercises/01-workshop_exercises/#Problem-3:-Differential-Algebraic-Equation-Modeling-of-a-Double-Pendulum-(B)","page":"SciML Workshop Exercises","title":"Problem 3: Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Differential-Algebraic Equaton (DAE) systems are like ODEs but allow for adding constraints into the models. This problem will look at solving the double penulum problem with enforcement of the rigid body constraints, requiring that the total distance L is constant throughout the simulation. While these equations can be rewritten in an ODE form, in many cases it can be simpler to solve the equation directly with the constraints. This tutorial will cover both the idea of index, how to manually perform index reduction, and how to make use of mass matrix and implicit ODE solvers to handle these problems.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-1:-Simple-Introduction-to-DAEs:-Mass-Matrix-Robertson-Equations","page":"SciML Workshop Exercises","title":"Part 1: Simple Introduction to DAEs: Mass-Matrix Robertson Equations","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"A mass-matrix ordinary differential equation (ODE) is an ODE where the left-hand side, the derivative side, is multiplied by a matrix known as the mass matrix. This is described as:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Mu = f(upt)","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"where M is the mass matrix. When M is invertible, there is an ODE which is equivalent to this formulation. When M is not invertible, this can have a distinctly different behavior and is as Differential-Algebraic Equation (DAE).","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Solve the Robertson DAE:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"beginalign\nfracdy_1dt = -004y_1 + 10^4 y_2y_3\nfracdy_2dt =  004y_1 - 10^4 y_2y_3 - 3times 10^7 y_2^2\n1 = y_1 + y_2 + y_3endalign","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"with y(0) = 100 and dy(0) = -00400400 using the mass-matrix formulation and Rodas5(). Use the ODEProblem page to find out how to declare a mass matrix.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"(Hint: what if the last row has all zeros?)","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-2:-Solving-the-Implicit-Robertson-Equations-with-IDA","page":"SciML Workshop Exercises","title":"Part 2: Solving the Implicit Robertson Equations with IDA","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the DAE Tutorial to define a DAE in its implicit form and solve the Robertson equation with IDA. Why is differential_vars = [true,true,false]?","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-3:-Manual-Index-Reduction-of-the-Single-Pendulum","page":"SciML Workshop Exercises","title":"Part 3: Manual Index Reduction of the Single Pendulum","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"The index of a DAE is a notion used to measure distance from its related ODE. There are many different definitions of index, but we're going to stick to the idea of differential index: the number of differentiations required to convert a system of DAEs into explicit ODE form. DAEs of high index are usually transformed via a procedure called index reduction. The following example will demonstrate this.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Consider the index 3 DAE system of the cartesian pendulum. After writing down the force equations in both directions, we arrive at the following DAE:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"\nbeginalign\nmddotx = fracxLT \nmddoty = fracyLT - mg \nx^2 + y^2 = L\nendalign\n\n\nNotice that we dont have an equation describing the\nbehaviour of T Let us now perform index reduction to\nextract an equation for T\n\nDifferentiate this third equation twice with respect to time\nto reduce it from index 3 to index 1\n\n Part 4 Single Pendulum Solution with IDA\nWrite these equations in implicit form and solve the system using\nIDA\n\n Part 5 Solving the Double Penulum DAE System\n\nThe following equations describe a double\npendulum system\n\nbeginalign\nm_2ddotx_2 = fracx_2L_2T_2 \nm_2ddoty_2 = fracy_2L_2T_2 - m_2g \nx_2^2 + y_2^2 = L_2 \nm_1ddotx_1 = fracx_1L_1T_1 - fracx_2L_2T_2 \nm_2ddoty_1 = fracy_1L_1T_2 - m_1g - fracy_2L_2T_2 \nx_1^2 + y_1^2 = L_1 \nendalign\n\n\nPerform index reduction and solve it like in the previous example\n\n Problem 4 Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)\n\nThis problem will focus on implementing and optimizing the solution of the\n2-dimensional Brusselator equations The BRUSS equations are a well-known\nhighly stiff oscillatory system of partial differential equations which are\nused in stiff ODE solver benchmarks In this tutorial we will walk first\nthrough a simple implementation then do allocation-free implementations and\nlooking deep into solver options and benchmarking\n\n Part 1 Implementing the BRUSS PDE System as ODEs\n\nThe Brusselator PDE is defined as follows\n\nbeginalign\nfracpartial upartial t = 1 + u^2v - 44u + alpha(fracpartial^2 upartial x^2 + fracpartial^2 upartial y^2) + f(x y t)\nfracpartial vpartial t = 34u - u^2v + alpha(fracpartial^2 upartial x^2 + fracpartial^2 upartial y^2)endalign","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"where","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"f(x y t) = begincases\n5  quad textif  (x-03)^2+(y-06)^2  01^2 text and  t  11 \n0  quad textelseendcases","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"and the initial conditions are","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"beginalign\nu(x y 0) = 22cdot y(1-y)^32 \nv(x y 0) = 27cdot x(1-x)^32endalign","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"with the periodic boundary condition","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"beginalign\nu(x+1yt) = u(xyt) \nu(xy+1t) = u(xyt)endalign","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"on a timespan of t in 022.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"To solve this PDE, we will discretize it into a system of ODEs with the finite difference method. We discretize u and v into arrays of the values at each time point: u[i,j] = u(i*dx,j*dy) for some choice of dx/dy, and same for v. Then our ODE is defined with U[i,j,k] = [u v]. The second derivative operator, the Laplacian, discretizes to become a tridiagonal matrix with [1 -2 1] and a 1 in the top right and bottom left corners. The nonlinear functions are then applied at each point in space (they are broadcast). Use dx=dy=1/32.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"You will know when you have the correct solution when you plot the solution at x=y=0 and see a periodic orbit, e.g., ts=0:0.05:22; plot(ts, sol1.(ts, idxs=1)).","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"If you are not familiar with this process, see the Gierer-Meinhardt example from the SciMLTutorials.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Note: Start by doing the simplest implementation!","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-2:-Optimizing-the-BRUSS-Code","page":"SciML Workshop Exercises","title":"Part 2: Optimizing the BRUSS Code","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"PDEs are expensive to solve, and so we will go nowhere without some code optimizing! Follow the steps described in the the Gierer-Meinhardt example from the SciMLTutorials to optimize your Brusselator code. Try other formulations and see what ends up the fastest! Find a trade-off between performance and simplicity that suits your needs.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-3:-Exploiting-Jacobian-Sparsity-with-Color-Differentiation","page":"SciML Workshop Exercises","title":"Part 3: Exploiting Jacobian Sparsity with Color Differentiation","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the sparsity! function from SparseDiffTools to generate the sparsity pattern for the Jacobian of this problem. Follow the documentations on the DiffEqFunction page to specify the sparsity pattern of the Jacobian. Generate an add the color vector to speed up the computation of the Jacobian.","category":"page"},{"location":"exercises/01-workshop_exercises/#(Optional)-Part-4:-Structured-Jacobians","page":"SciML Workshop Exercises","title":"(Optional) Part 4: Structured Jacobians","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Specify the sparsity pattern using a BlockBandedMatrix from BlockBandedMatrices.jl to accelerate the previous sparsity handling tricks.","category":"page"},{"location":"exercises/01-workshop_exercises/#(Optional)-Part-5:-Automatic-Symbolicification-and-Analytical-Jacobian","page":"SciML Workshop Exercises","title":"(Optional) Part 5: Automatic Symbolicification and Analytical Jacobian","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the modelingtoolkitize function from ModelingToolkit.jl to convert your numerical ODE function into a symbolic ODE function and use that to compute and solve with an analytical sparse Jacobian.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-6:-Utilizing-Preconditioned-GMRES-Linear-Solvers","page":"SciML Workshop Exercises","title":"Part 6: Utilizing Preconditioned-GMRES Linear Solvers","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the linear solver specification page to solve the equation with TRBDF2 with GMRES. Use the Sundials documentation to solve the equation with CVODE_BDF with Sundials' special internal GMRES. To both of these, use the AlgebraicMultigrid.jl to add a preconditioner to the GMRES solver.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-7:-Exploring-IMEX-and-Exponential-Integrator-Techniques-(E)","page":"SciML Workshop Exercises","title":"Part 7: Exploring IMEX and Exponential Integrator Techniques (E)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Instead of using the standard ODEProblem, define a SplitODEProblem to move some of the equation to the \"non-stiff part\". Try different splits and solve with KenCarp4 to see if the solution can be accelerated.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Next, use MatrixFreeOperator and DiffEqArrayOperator to define part of the equation as linear, and use the ETDRK4 exponential integrator to solve the equation. Note that this technique is not appropriate for this equation since it relies on the nonlinear term being non-stiff for best results.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-8:-Work-Precision-Diagrams-for-Benchmarking-Solver-Choices","page":"SciML Workshop Exercises","title":"Part 8: Work-Precision Diagrams for Benchmarking Solver Choices","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the WorkPrecisionSet method from DiffEqDevTools.jl to benchmark multiple different solver methods and find out what combination is most efficient. Take a look at DiffEqBenchmarks.jl for usage examples.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-9:-GPU-Parallelism-for-PDEs-(E)","page":"SciML Workshop Exercises","title":"Part 9: GPU-Parallelism for PDEs (E)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Fully vectorize your implementation of the ODE and use a CuArray from CuArrays.jl as the initial condition to cause the whole solution to be GPU accelerated.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-10:-Adjoint-Sensitivity-Analysis-for-Gradients-of-PDEs","page":"SciML Workshop Exercises","title":"Part 10: Adjoint Sensitivity Analysis for Gradients of PDEs","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"In order to optimize the parameters of a PDE, you need to be able to compute the gradient of the solution with respect to the parameters. This is done through sensitivity analysis. For PDEs, generally the system is at a scale where forward sensitivity analysis (forward-mode automatic differentiation) is no longer suitable, and for these cases one uses adjoint sensitivity analysis.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Rewrite the PDE so the constant terms are parameters, and use the adjoint sensitivity analysis documentation to solve for the solution gradient with a cost function being the L2 distance of the solution from the value 1. Solve with interpolated and checkpointed adjoints. Play with using reverse-mode automatic differentiation vs direct computation of vector-Jacobian products using the autojacvec option of the SensitivityAlg. Find the set of options most suitable for this PDE.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"If you have compute time, use this adjoint to optimize the parameters of the PDE with respect to this cost function.","category":"page"},{"location":"exercises/01-workshop_exercises/#Problem-5:-Global-Parameter-Sensitivity-and-Optimality-with-GPU-and-Distributed-Ensembles-(B)","page":"SciML Workshop Exercises","title":"Problem 5: Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"In this example we will investigate how the parameters \"generally\" effect the solution in the chaotic Henon-Heiles system. By \"generally\" we will use global sensitivity analysis methods to get an average global characterization of the parameters on the solution. In addition to a global sensitivity approach, we will generate large ensembles of solutions with different parameters using a GPU-based parallelism approach.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-1:-Implementing-the-Henon-Heiles-System-(B)","page":"SciML Workshop Exercises","title":"Part 1: Implementing the Henon-Heiles System (B)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"The Henon-Heiles Hamiltonian system is described by the ODEs:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"beginalign\nfracdp_1dt = -q_1 (1 + 2q_2)\nfracdp_2dt = -q_2 - (q_1^2 - q_2^2)\nfracdq_1dt = p_1\nfracdq_2dt = p_2endalign","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"with initial conditions u_0 = 01000005. Solve this system over the timespan tin01000","category":"page"},{"location":"exercises/01-workshop_exercises/#(Optional)-Part-2:-Alternative-Dynamical-Implmentations-of-Henon-Heiles-(B)","page":"SciML Workshop Exercises","title":"(Optional) Part 2: Alternative Dynamical Implmentations of Henon-Heiles (B)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"The Henon-Heiles defines a Hamiltonian system with certain structures which can be utilized for a more efficient solution. Use the Dynamical problems page to define a SecondOrderODEProblem corresponding to the acceleration terms:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"beginalign\nfracd^2q_1dt^2 = -q_1 (1 + 2q_2)\nfracd^2q_2dt^2 = -q_2 - (q_1^2 - q_2^2)endalign","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Solve this with a method that is specific to dynamical problems, like DPRKN6.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"The Hamiltonian can also be directly described:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"H(pq) = frac12(p_1^2 + p_2^2) + frac12(q_1^2+q_2^2+2q_1^2 q_2 - frac23q_2^3)","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Solve this problem using the HamiltonianProblem constructor from DiffEqPhysics.jl.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-3:-Parallelized-Ensemble-Solving","page":"SciML Workshop Exercises","title":"Part 3: Parallelized Ensemble Solving","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"To understand the orbits of the Henon-Heiles system, it can be useful to solve the system with many different initial conditions. Use the ensemble interface to solve with randomized initial conditions in parallel using threads with EnsembleThreads(). Then, use addprocs() to add more cores and solve using EnsembleDistributed(). The former will solve using all of the cores on a single computer, while the latter will use all of the cores on which there are processors, which can include thousands across a supercomputer! See Julia's parallel computing setup page for more details on the setup.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-4:-Parallelized-GPU-Ensemble-Solving","page":"SciML Workshop Exercises","title":"Part 4: Parallelized GPU Ensemble Solving","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Setup the CUDAnative.jl library and use the EnsembleGPUArray() method to parallelize the solution across the thousands of cores of a GPU. Note that this will efficiency solve for hundreds of thousands of trajectores.","category":"page"},{"location":"exercises/01-workshop_exercises/#Problem-6:-Training-Neural-Stochastic-Differential-Equations-with-GPU-acceleration-(I)","page":"SciML Workshop Exercises","title":"Problem 6: Training Neural Stochastic Differential Equations with GPU acceleration (I)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"In the previous models we had to define a model. Now let's shift the burden of model-proofing onto data by utilizing neural differential equations. A neural differential equation is a differential equation where the model equations are replaced, either in full or in part, by a neural network. For example, a neural ordinary differential equation is an equation u^prime = f(upt) where f is a neural network. We can learn this neural network from data using various methods, the easiest of which is known as the single shooting method, where one chooses neural network parameters, solves the equation, and checks the ODE's solution against data as a loss.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"In this example we will define and train various forms of neural differential equations. Note that all of the differential equation types are compatible with neural differential equations, so this is only going to scratch the surface of the possibilites!","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-1:-Constructing-and-Training-a-Basic-Neural-ODE","page":"SciML Workshop Exercises","title":"Part 1: Constructing and Training a Basic Neural ODE","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the DiffEqFlux.jl README to construct a neural ODE to train against the training data:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"\nu0 = Float32[2.; 0.]\ndatasize = 30\ntspan = (0.0f0,1.5f0)\n\nfunction trueODEfunc(du,u,p,t)\n    true_A = [-0.1 2.0; -2.0 -0.1]\n    du .= ((u.^3)'true_A)'\nend\nt = range(tspan[1],tspan[2],length=datasize)\nprob = ODEProblem(trueODEfunc,u0,tspan)\node_data = Array(solve(prob,Tsit5(),saveat=t))","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-2:-GPU-accelerating-the-Neural-ODE-Process","page":"SciML Workshop Exercises","title":"Part 2: GPU-accelerating the Neural ODE Process","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the gpu function from Flux.jl to transform all of the calculations onto the GPU and train the neural ODE using GPU-accelerated Tsit5 with adjoints.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-3:-Defining-and-Training-a-Mixed-Neural-ODE","page":"SciML Workshop Exercises","title":"Part 3: Defining and Training a Mixed Neural ODE","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Gather data from the Lotka-Volterra equation:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"\nfunction lotka_volterra(du,u,p,t)\n  x, y = u\n  α, β, δ, γ = p\n  du[1] = dx = α*x - β*x*y\n  du[2] = dy = -δ*y + γ*x*y\nend\nu0 = [1.0,1.0]\ntspan = (0.0,10.0)\np = [1.5,1.0,3.0,1.0]\nprob = ODEProblem(lotka_volterra,u0,tspan,p)\nsol = Array(solve(prob,Tsit5())(0.0:1.0:10.0))","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Now use the mixed neural section of the documentation to define the mixed neural ODE where the functional form of fracdxdt is known, and try to derive a neural formulation for fracdydt directly from the data.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-4:-Constructing-a-Basic-Neural-SDE","page":"SciML Workshop Exercises","title":"Part 4: Constructing a Basic Neural SDE","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Generate data from the Lotka-Volterra equation with multiplicative noise","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"\nfunction lotka_volterra(du,u,p,t)\n  x, y = u\n  α, β, δ, γ = p\n  du[1] = dx = α*x - β*x*y\n  du[2] = dy = -δ*y + γ*x*y\nend\nfunction lv_noise(du,u,p,t)\n  du[1] = p[5]*u[1]\n  du[2] = p[6]*u[2]\nend\nu0 = [1.0,1.0]\ntspan = (0.0,10.0)\np = [1.5,1.0,3.0,1.0,0.1,0.1]\nprob = SDEProblem(lotka_volterra,lv_noise,u0,tspan,p)\nsol = [Array(solve(prob,SOSRI())(0.0:1.0:10.0)) for i in 1:20] # 20 solution samples","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Train a neural stochastic differential equation dX = f(X)dt + g(X)dW_t where both the drift (f) and the diffusion (g) functions are neural networks. See if constraining g can make the problem easier to fit.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-5:-Optimizing-the-training-behavior-with-minibatching-(E)","page":"SciML Workshop Exercises","title":"Part 5: Optimizing the training behavior with minibatching (E)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use minibatching on the data to improve the training procedure. An example can be found at this PR.","category":"page"},{"location":"models/08-spiking_neural_systems/#Spiking-Neural-Systems","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"","category":"section"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"This is an introduction to spiking neural systems with Julia's DifferentialEquations package. We will cover three different models: leaky integrate-and-fire, Izhikevich, and Hodgkin-Huxley. Finally we will also learn about two mechanisms that simulate synaptic inputs like real neurons receive them. The alpha synapse and the Tsodyks-Markram synapse. Let's get started with the leaky integrate-and-fire (LIF) model.","category":"page"},{"location":"models/08-spiking_neural_systems/#The-Leaky-Integrate-and-Fire-Model","page":"Spiking Neural Systems","title":"The Leaky Integrate-and-Fire Model","text":"","category":"section"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"The LIF model is an extension of the integrate-and-fire (IF) model. While the IF model simply integrates input until it fires, the LIF model integrates input but also decays towards an equilibrium potential. This means that inputs that arrive in quick succession have a much higher chance to make the cell spike as opposed to inputs that are further apart in time. The LIF is a more realistic neuron model than the IF, because it is known from real neurons that the timing of inputs is extremely relevant for their spiking.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"The LIF model has five parameters, gL, EL, C, Vth, I and we define it in the lif(u, p, t) function.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"using DifferentialEquations\nusing Plots\ngr()\n\nfunction lif(u,p,t);\n    gL, EL, C, Vth, I = p\n    (-gL*(u-EL)+I)/C\nend","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"lif (generic function with 1 method)","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Our system is described by one differential equation: (-gL*(u-EL)+I)/C, where u is the voltage, I is the input, gL is the leak conductance, EL is the equilibrium potential of the leak conductance and C is the membrane capacitance. Generally, any change of the voltage is slowed down (filtered) by the membrane capacitance. That's why we divide the whole equation by C. Without any external input, the voltage always converges towards EL. If u is larger than EL, u decreases until it is at EL. If u is smaller than EL, u increases until it is at EL. The only other thing that can change the voltage is the external input I.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Our lif function requires a certain parameter structure because it will need to be compatible with the DifferentialEquations interface. The input signature is lif(u, p, t) where u is the voltage, p is the collection of the parameters that describe the equation and t is time. You might wonder why time does not show up in our equation, although we need to calculate the change in voltage with respect to time. The ODE solver will take care of time for us. One of the advantages of the ODE solver as opposed to calculating the change of u in a for loop is that many ODE solver algorithms can dynamically adjust the time step in a way that is efficient and accurate.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"One crucial thing is still missing however. This is supposed to be a model of neural spiking, right? So we need a mechanism that recognizes the spike and hyperpolarizes u in response. For this purpose we will use callbacks. They can make discontinuous changes to the model when certain conditions are met.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"function thr(u,t,integrator)\n    integrator.u > integrator.p[4]\nend\n\nfunction reset!(integrator)\n    integrator.u = integrator.p[2]\nend\n\nthreshold = DiscreteCallback(thr,reset!)\ncurrent_step= PresetTimeCallback([2,15],integrator -> integrator.p[5] += 210.0)\ncb = CallbackSet(current_step,threshold)","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"DiffEqBase.CallbackSet{Tuple{}, Tuple{DiffEqBase.DiscreteCallback{DiffEqCal\nlbacks.var\"#61#64\"{Vector{Int64}}, DiffEqCallbacks.var\"#62#65\"{Main.##Weave\nSandBox#10480.var\"#1#2\"}, DiffEqCallbacks.var\"#63#66\"{typeof(DiffEqBase.INI\nTIALIZE_DEFAULT), Bool, Vector{Int64}, Main.##WeaveSandBox#10480.var\"#1#2\"}\n, typeof(DiffEqBase.FINALIZE_DEFAULT)}, DiffEqBase.DiscreteCallback{typeof(\nMain.##WeaveSandBox#10480.thr), typeof(Main.##WeaveSandBox#10480.reset!), t\nypeof(DiffEqBase.INITIALIZE_DEFAULT), typeof(DiffEqBase.FINALIZE_DEFAULT)}}\n}((), (DiffEqBase.DiscreteCallback{DiffEqCallbacks.var\"#61#64\"{Vector{Int64\n}}, DiffEqCallbacks.var\"#62#65\"{Main.##WeaveSandBox#10480.var\"#1#2\"}, DiffE\nqCallbacks.var\"#63#66\"{typeof(DiffEqBase.INITIALIZE_DEFAULT), Bool, Vector{\nInt64}, Main.##WeaveSandBox#10480.var\"#1#2\"}, typeof(DiffEqBase.FINALIZE_DE\nFAULT)}(DiffEqCallbacks.var\"#61#64\"{Vector{Int64}}([2, 15]), DiffEqCallback\ns.var\"#62#65\"{Main.##WeaveSandBox#10480.var\"#1#2\"}(Main.##WeaveSandBox#1048\n0.var\"#1#2\"()), DiffEqCallbacks.var\"#63#66\"{typeof(DiffEqBase.INITIALIZE_DE\nFAULT), Bool, Vector{Int64}, Main.##WeaveSandBox#10480.var\"#1#2\"}(DiffEqBas\ne.INITIALIZE_DEFAULT, true, [2, 15], Main.##WeaveSandBox#10480.var\"#1#2\"())\n, DiffEqBase.FINALIZE_DEFAULT, Bool[1, 1]), DiffEqBase.DiscreteCallback{typ\neof(Main.##WeaveSandBox#10480.thr), typeof(Main.##WeaveSandBox#10480.reset!\n), typeof(DiffEqBase.INITIALIZE_DEFAULT), typeof(DiffEqBase.FINALIZE_DEFAUL\nT)}(Main.##WeaveSandBox#10480.thr, Main.##WeaveSandBox#10480.reset!, DiffEq\nBase.INITIALIZE_DEFAULT, DiffEqBase.FINALIZE_DEFAULT, Bool[1, 1])))","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Our condition is thr(u,t,integrator) and the condition kicks in when integrator.u > integrator.p[4] where p[4] is our threshold parameter Vth. Our effect of the condition is reset!(integrator). It sets u back to the equilibrium potential p[2]. We then wrap both the condition and the effect into a DiscreteCallback called threshold. There is one more callback called PresetTimeCallback that is particularly useful. This one increases the input p[5] at t=2 and t=15 by 210.0. Both callbacks are then combined into a CallbackSet. We are almost done to simulate our system we just need to put numbers on our initial voltage and parameters.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"u0 = -75\ntspan = (0.0, 40.0)\n# p = (gL, EL, C, Vth, I)\np = [10.0, -75.0, 5.0, -55.0, 0]\n\nprob = ODEProblem(lif, u0, tspan, p, callback=cb)","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"ODEProblem with uType Int64 and tType Float64. In-place: false\ntimespan: (0.0, 40.0)\nu0: -75","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Our initial voltage is u0 = - 75, which will be the same as our equilibrium potential, so we start at a stable point. Then we define the timespan we want to simulate. The time scale of the LIF as it is defined conforms roughly to milliseconds. Then we define our parameters as p = [10.0, -75.0, 5.0, -55.0, 0]. Remember that gL, EL, C, Vth, I = p. Finally we wrap everything into a call to ODEProblem. Can't forget the CallbackSet. With that our model is defined. Now we just need to solve it with a quick call to solve.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"sol = solve(prob)","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"retcode: Success\nInterpolation: automatic order switching interpolation\nt: 153-element Vector{Float64}:\n  0.0\n  9.999999999999999e-5\n  0.0010999999999999998\n  0.011099999999999997\n  0.11109999999999996\n  1.1110999999999995\n  2.0\n  2.0\n  2.6300346673750097\n  2.9226049547524595\n  ⋮\n 38.34157935968204\n 38.78215179003683\n 38.78215179003683\n 39.222724173706894\n 39.222724173706894\n 39.6632965982261\n 39.6632965982261\n 40.0\n 40.0\nu: 153-element Vector{Float64}:\n -75.0\n -75.0\n -75.0\n -75.0\n -75.0\n -75.0\n -75.0\n -75.0\n -59.978080111690375\n -57.32999167299642\n   ⋮\n -75.0\n -50.40489310815222\n -75.0\n -50.404894730067554\n -75.0\n -50.404893310891545\n -75.0\n -54.419318668318546\n -75.0","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"First of all the solve output tells us if solving the system generally worked. In this case we know it worked because the return code (retcode) says Success. Then we get the numbers for the timestep and the solution to u. The raw numbers are not super interesting to let's plot our solution.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"plot(sol)","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"We see that the model is resting at -75 while there is no input. At t=2 the input increases by 210 and the model starts to spike. Spiking does not start immediately because the input first has to charge the membrane capacitance. Notice how once spiking starts it very quickly becomes extremely regular. Increasing the input again at t=15 increases firing as we would expect but it is still extremely regular. This is one of the features of the LIF. The firing frequency is regular for constant input and a linear function of the input strength. There are ways to make LIF models less regular. For example we could use certain noise types at the input. We could also simulate a large number of LIF models and connect them synaptically. Instead of going into those topics, we will move on to the Izhikevich model, which is known for its ability to generate a large variety of spiking dynamics during constant inputs.","category":"page"},{"location":"models/08-spiking_neural_systems/#The-Izhikevich-Model","page":"Spiking Neural Systems","title":"The Izhikevich Model","text":"","category":"section"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"The Izhikevich model is a two-dimensional model of neuronal spiking. It was derived from a bifurcation analysis of a cortical neuron. Because it is two-dimensional it can generate much more complex spike dynamics than the LIF model. The kind of dynamics depend on the four parameters and the input a, b, c, d, I = p. All the concepts are the same as above, expect for some minor changes to our function definitions to accomodate for the second dimension.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"#Izhikevichch Model\nusing DifferentialEquations\nusing Plots\n\nfunction izh!(du,u,p,t);\n    a, b, c, d, I = p\n\n    du[1] = 0.04*u[1]^2+5*u[1]+140-u[2]+I\n    du[2] = a*(b*u[1]-u[2])\nend","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"izh! (generic function with 1 method)","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"This is our Izhikevich model. There are two important changes here. First of all, note the additional input parameter du. This is a sequence of differences. du[1] corresponds to the voltage (the first dimension of the system) and du[2] corresponds to the second dimension. This second dimension is called u in the original Izhikevich work amnd it makes the notation a little annoying. In this tutorial I will generally stick to Julia and DifferentialEquations conventions as opposed to conventions of the specific models and du is commonly used. We will never define du ourselves outside of the function but the ODE solver will use it internally. The other change here is the ! after our function name. This signifies that du will be preallocated before integration and then updated in-place, which saves a lot of allocation time. Now we just need our callbacks to take care of spikes and increase the input.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"function thr(u,t,integrator)\n    integrator.u[1] >= 30\nend\n\nfunction reset!(integrator)\n    integrator.u[1] = integrator.p[3]\n    integrator.u[2] += integrator.p[4]\nend\n\nthreshold = DiscreteCallback(thr,reset!)\ncurrent_step= PresetTimeCallback(50,integrator -> integrator.p[5] += 10)\ncb = CallbackSet(current_step,threshold)","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"DiffEqBase.CallbackSet{Tuple{}, Tuple{DiffEqBase.DiscreteCallback{DiffEqCal\nlbacks.var\"#61#64\"{Int64}, DiffEqCallbacks.var\"#62#65\"{Main.##WeaveSandBox#\n10480.var\"#3#4\"}, DiffEqCallbacks.var\"#63#66\"{typeof(DiffEqBase.INITIALIZE_\nDEFAULT), Bool, Int64, Main.##WeaveSandBox#10480.var\"#3#4\"}, typeof(DiffEqB\nase.FINALIZE_DEFAULT)}, DiffEqBase.DiscreteCallback{typeof(Main.##WeaveSand\nBox#10480.thr), typeof(Main.##WeaveSandBox#10480.reset!), typeof(DiffEqBase\n.INITIALIZE_DEFAULT), typeof(DiffEqBase.FINALIZE_DEFAULT)}}}((), (DiffEqBas\ne.DiscreteCallback{DiffEqCallbacks.var\"#61#64\"{Int64}, DiffEqCallbacks.var\"\n#62#65\"{Main.##WeaveSandBox#10480.var\"#3#4\"}, DiffEqCallbacks.var\"#63#66\"{t\nypeof(DiffEqBase.INITIALIZE_DEFAULT), Bool, Int64, Main.##WeaveSandBox#1048\n0.var\"#3#4\"}, typeof(DiffEqBase.FINALIZE_DEFAULT)}(DiffEqCallbacks.var\"#61#\n64\"{Int64}(50), DiffEqCallbacks.var\"#62#65\"{Main.##WeaveSandBox#10480.var\"#\n3#4\"}(Main.##WeaveSandBox#10480.var\"#3#4\"()), DiffEqCallbacks.var\"#63#66\"{t\nypeof(DiffEqBase.INITIALIZE_DEFAULT), Bool, Int64, Main.##WeaveSandBox#1048\n0.var\"#3#4\"}(DiffEqBase.INITIALIZE_DEFAULT, true, 50, Main.##WeaveSandBox#1\n0480.var\"#3#4\"()), DiffEqBase.FINALIZE_DEFAULT, Bool[1, 1]), DiffEqBase.Dis\ncreteCallback{typeof(Main.##WeaveSandBox#10480.thr), typeof(Main.##WeaveSan\ndBox#10480.reset!), typeof(DiffEqBase.INITIALIZE_DEFAULT), typeof(DiffEqBas\ne.FINALIZE_DEFAULT)}(Main.##WeaveSandBox#10480.thr, Main.##WeaveSandBox#104\n80.reset!, DiffEqBase.INITIALIZE_DEFAULT, DiffEqBase.FINALIZE_DEFAULT, Bool\n[1, 1])))","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"One key feature of the Izhikevich model is that each spike increases our second dimension u[2] by a preset amount p[4]. Between spikes u[2] decays to a value that depends on p[1] and p[2] and the equilibrium potential p[3]. Otherwise the code is not too different from the LIF model. We will again need to define our parameters and we are ready to simulate.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"p = [0.02, 0.2, -50, 2, 0]\nu0 = [-65, p[2]*-65]\ntspan = (0.0, 300)\n\nprob = ODEProblem(izh!, u0, tspan, p, callback=cb)","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"ODEProblem with uType Vector{Float64} and tType Float64. In-place: true\ntimespan: (0.0, 300.0)\nu0: 2-element Vector{Float64}:\n -65.0\n -13.0","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"sol = solve(prob);\nplot(sol, vars=1)","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"This spiking type is called chattering. It fires with intermittent periods of silence. Note that the input starts at t=50 and remain constant for the duration of the simulation. One of mechanisms that sustains this type of firing is the spike induced hyperpolarization coming from our second dimension, so let's look at this variable.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"plot(sol, vars=2)","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Our second dimension u[2] increases with every spike. When it becomes too large, the system cannot generate another spike until u[2] has decayed to a value small enough that spiking can resume. This process repeats. In this model, spiking is no longer regular like it was in the LIF. Here we have two frequencies, the frequency during the spiking state and the frequency between spiking states. The LIF model was dominated by one single frequency that was a function of the input strength. Let's see if we can generate another spiking type by changing the parameters.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"p = [0.02, 0.2, -65, 8, 0]\nu0 = [-65, p[2]*-65]\ntspan = (0.0, 300)\n\nprob = ODEProblem(izh!, u0, tspan, p, callback=cb)\nsol = solve(prob);\nplot(sol, vars=1)","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"This type is called regularly spiking and we created it just by lowering p[3] and increasing p[4]. Note that the type is called regularly spiking but it is not instantaneously regular. The instantenous frequency is higher in the beginning. This is called spike frequency adaptation and is a common property of real neurons. There are many more spike types that can be generated. Check out the original Izhikevich work and create your own favorite neuron!","category":"page"},{"location":"models/08-spiking_neural_systems/#Hodgkin-Huxley-Model","page":"Spiking Neural Systems","title":"Hodgkin-Huxley Model","text":"","category":"section"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"The Hodgkin-Huxley (HH) model is our first biophysically realistic model. This means that all parameters and mechanisms of the model represent biological mechanisms. Specifically, the HH model simulates the ionic currents that depolarize and hyperpolarize a neuron during an action potential. This makes the HH model four-dimensional. Let's see how it looks.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"using DifferentialEquations\nusing Plots\n\n# Potassium ion-channel rate functions\nalpha_n(v) = (0.02 * (v - 25.0)) / (1.0 - exp((-1.0 * (v - 25.0)) / 9.0))\nbeta_n(v) = (-0.002 * (v - 25.0)) / (1.0 - exp((v - 25.0) / 9.0))\n\n# Sodium ion-channel rate functions\nalpha_m(v) = (0.182*(v + 35.0)) / (1.0 - exp((-1.0 * (v + 35.0)) / 9.0))\nbeta_m(v) = (-0.124 * (v + 35.0)) / (1.0 - exp((v + 35.0) / 9.0))\n\nalpha_h(v) = 0.25 * exp((-1.0 * (v + 90.0)) / 12.0)\nbeta_h(v) = (0.25 * exp((v + 62.0) / 6.0)) / exp((v + 90.0) / 12.0)\n\nfunction HH!(du,u,p,t);\n    gK, gNa, gL, EK, ENa, EL, C, I = p\n    v, n, m, h = u\n\n    du[1] = (-(gK * (n^4.0) * (v - EK)) - (gNa * (m ^ 3.0) * h * (v - ENa)) - (gL * (v - EL)) + I) / C\n    du[2] = (alpha_n(v) * (1.0 - n)) - (beta_n(v) * n)\n    du[3] = (alpha_m(v) * (1.0 - m)) - (beta_m(v) * m)\n    du[4] = (alpha_h(v) * (1.0 - h)) - (beta_h(v) * h)\nend","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"HH! (generic function with 1 method)","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"We have three different types of ionic conductances. Potassium, sodium and the leak. The potassium and sodium conducance are voltage gated. They increase or decrease depending on the voltage. In ion channel terms, open channels can transition to the closed state and closed channels can transition to the open state. It's probably easiest to start with the potassium current described by gK * (n^4.0) * (EK - v). Here gK is the total possible conductance that we could reach if all potassium channels were open. If all channels were open, n would equal 1 which is usually not the case. The transition from open state to closed state is modeled in alpha_n(v) while the transition from closed to open is in beta_n(v). Because potassium conductance is voltage gated, these transitions depend on v. The numbers in alpha_n; beta_n were calculated by Hodgkin and Huxley based on their extensive experiments on the squid giant axon. They also determined, that n needs to be taken to the power of 4 to correctly model the amount of open channels.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"The sodium current is not very different but it has two gating variables, m, h instead of one. The leak conductance gL has no gating variables because it is not voltage gated. Let's move on to the parameters. If you want all the details on the HH model you can find a great description here.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"current_step= PresetTimeCallback(100,integrator -> integrator.p[8] += 1)\n\n# n, m & h steady-states\nn_inf(v) = alpha_n(v) / (alpha_n(v) + beta_n(v))\nm_inf(v) = alpha_m(v) / (alpha_m(v) + beta_m(v))\nh_inf(v) = alpha_h(v) / (alpha_h(v) + beta_h(v))\n\np = [35.0, 40.0, 0.3, -77.0, 55.0, -65.0, 1, 0]\nu0 = [-60, n_inf(-60), m_inf(-60), h_inf(-60)]\ntspan = (0.0, 1000)\n\nprob = ODEProblem(HH!, u0, tspan, p, callback=current_step)","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"ODEProblem with uType Vector{Float64} and tType Float64. In-place: true\ntimespan: (0.0, 1000.0)\nu0: 4-element Vector{Float64}:\n -60.0\n   0.0007906538330645917\n   0.08362733690208038\n   0.41742979353768533","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"For the HH model we need only one callback. The PresetTimeCallback that starts our input current. We don't need to reset the voltage when it reaches threshold because the HH model has its own repolarization mechanism. That is the potassium current, which activates at large voltages and makes the voltage more negative. The three functions n_inf; m_inf; h_inf help us to find good initial values for the gating variables. Those functions tell us that the steady-state gating values should be for the initial voltage. The parameters were chosen in a way that the properties of the model roughly resemble that of a cortical pyramidal cell instead of the giant axon Hodgkin and Huxley were originally working on.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"sol = solve(prob);\nplot(sol, vars=1)","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"That's some good regular voltage spiking. One of the cool things about a biophysically realistic model is that the gating variables tell us something about the mechanisms behind the action potential. You might have seen something like the following plot in a biology textbook.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"plot(sol, vars=[2,3,4], tspan=(105.0,130.0))","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"So far we have only given our neurons very simple step inputs by simply changing the number I. Actual neurons recieve their inputs mostly from chemical synapses. They produce conductance changes with very complex structures. In the next chapter we will try to incorporate a synapse into our HH model.","category":"page"},{"location":"models/08-spiking_neural_systems/#Alpha-Synapse","page":"Spiking Neural Systems","title":"Alpha Synapse","text":"","category":"section"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"One of the most simple synaptic mechanisms used in computational neuroscience is the alpha synapse. When this mechanism is triggered, it causes an instantanouse rise in conductance followed by an exponential decay. Let's incorporate that into our HH model.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"function gSyn(max_gsyn, tau, tf, t);\n    if t-tf >= 0\n        return max_gsyn * exp(-(t-tf)/tau)\n    else\n        return 0.0\n    end\nend\nfunction HH!(du,u,p,t);\n    gK, gNa, gL, EK, ENa, EL, C, I, max_gSyn, ESyn, tau, tf = p\n    v, n, m, h = u\n\n    ISyn = gSyn(max_gSyn, tau, tf, t) * (v - ESyn)\n\n    du[1] = (-(gK * (n^4.0) * (v - EK)) - (gNa * (m ^ 3.0) * h * (v - ENa)) - (gL * (v - EL)) + I - ISyn) / C\n    du[2] = (alpha_n(v) * (1.0 - n)) - (beta_n(v) * n)\n    du[3] = (alpha_m(v) * (1.0 - m)) - (beta_m(v) * m)\n    du[4] = (alpha_h(v) * (1.0 - h)) - (beta_h(v) * h)\nend","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"HH! (generic function with 1 method)","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"gSyn models the step to the maximum conductance and the following exponential decay with time constant tau. Of course we only want to integrate the conductance at and after time tf, the onset of the synaptic response. Before tf, gSyn returns zero. To convert the conductance to a current, we multiply by the difference between the current voltage and the synapses equilibrium voltage: ISyn = gSyn(max_gSyn, tau, tf, t) * (v - ESyn). Later we will set the parameter ESyn to 0, making this synapse an excitatory synapse. Excitatory synapses have equilibrium potentials far above the resting potential. Let's see what our synapse does to the voltage of the cell.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"p = [35.0, 40.0, 0.3, -77.0, 55.0, -65.0, 1, 0, 0.008, 0, 20, 100]\ntspan = (0.0, 200)\nprob = ODEProblem(HH!, u0, tspan, p)\nsol = solve(prob);\nplot(sol, vars=1)","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"What you see here is called an excitatory postsynaptic potential (EPSP). It is the voltage response to a synaptic current. While our synaptic conductance rises instantly, the voltage response rises at a slower time course that is given by the membrane capacitance C. This particular voltage response is not strong enough to evoke spiking, so we say it is subthreshold. To get a suprathreshold response that evokes spiking we simply increase the parameter max_gSyn to increase the maximum conductance.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"p = [35.0, 40.0, 0.3, -77.0, 55.0, -65.0, 1, 0, 0.01, 0, 20, 100]\ntspan = (0.0, 200)\nprob = ODEProblem(HH!, u0, tspan, p)\nsol = solve(prob);\nplot!(sol, vars=1)","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"This plot shows both the subthreshold EPSP from above as well as the suprathreshold EPSP. Alpha synapses are nice because of their simplicity. Real synapses however, are extremely complex structures. One of the most important features of real synapses is that their maximum conductance is not the same on every event. The number and frequency of synaptic events changes the size of the maximum conductance in a dynamic way. While we usually avoid anatomical and biophysical details of real synapses, there is a widely used phenomenological way to capture those dynamics called the Tsodyks-Markram synapse.","category":"page"},{"location":"models/08-spiking_neural_systems/#Tsodyks-Markram-Synapse","page":"Spiking Neural Systems","title":"Tsodyks-Markram Synapse","text":"","category":"section"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"The Tsodyks-Markram synapse (TMS) is a dynamic system that models the changes of maximum conductance that occur between EPSPs at different frequencies. The single response is similar to the alpha synapse in that it rises instantaneously and decays exponentially. The maximum conductance it reaches depends on the event history. To simulate the TMS we need to incorporate three more dimensions, u, R, gsyn into our system. u decays towards 0, R decays towards 1 and gsyn decays towards 0 as it did with the alpha synapse. The crucial part of the TMS is in epsp!, where we handle the discontinuities when a synaptic event occurs. Instead of just setting gsyn to the maximum conductance gmax, we increment gsyn by a fraction of gmax that depends on the other two dynamic parameters. The frequency dependence comes from the size of the time constants tau_u and tau_R. Enough talk, let's simulate it.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"function HH!(du,u,p,t);\n    gK, gNa, gL, EK, ENa, EL, C, I, tau, tau_u, tau_R, u0, gmax, Esyn  = p\n    v, n, m, h, u, R, gsyn = u\n\n    du[1] = ((gK * (n^4.0) * (EK - v)) + (gNa * (m ^ 3.0) * h * (ENa - v)) + (gL * (EL - v)) + I + gsyn * (Esyn - v)) / C\n    du[2] = (alpha_n(v) * (1.0 - n)) - (beta_n(v) * n)\n    du[3] = (alpha_m(v) * (1.0 - m)) - (beta_m(v) * m)\n    du[4] = (alpha_h(v) * (1.0 - h)) - (beta_h(v) * h)\n\n    # Synaptic variables\n    du[5] = -(u/tau_u)\n    du[6] = (1-R)/tau_R\n    du[7] = -(gsyn/tau)\nend\n\nfunction epsp!(integrator);\n    integrator.u[5] += integrator.p[12] * (1 - integrator.u[5])\n    integrator.u[7] += integrator.p[13] * integrator.u[5] * integrator.u[6]\n    integrator.u[6] -= integrator.u[5] * integrator.u[6]\n\nend\n\nepsp_ts= PresetTimeCallback(100:100:500, epsp!)\n\np = [35.0, 40.0, 0.3, -77.0, 55.0, -65.0, 1, 0, 30, 1000, 50, 0.5, 0.005, 0]\nu0 = [-60, n_inf(-60), m_inf(-60), h_inf(-60), 0.0, 1.0, 0.0]\ntspan = (0.0, 700)\nprob = ODEProblem(HH!, u0, tspan, p, callback=epsp_ts)\nsol = solve(prob);\nplot(sol, vars=1)","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"plot(sol, vars=7)","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Both the voltage response as well as the conductances show what is called short-term facilitation. An increase in peak conductance over multiple synaptic events. Here the first event has a conductance of around 0.0025 and the last one of 0.004. We can plot the other two varialbes to see what underlies those dynamics","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"plot(sol, vars=[5,6])","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Because of the time courses at play here, this facilitation is frequency dependent. If we increase the period between these events, facilitation does not occur.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"epsp_ts= PresetTimeCallback(100:1000:5100, epsp!)\n\np = [35.0, 40.0, 0.3, -77.0, 55.0, -65.0, 1, 0, 30, 500, 50, 0.5, 0.005, 0]\nu0 = [-60, n_inf(-60), m_inf(-60), h_inf(-60), 0.0, 1.0, 0.0]\ntspan = (0.0, 5300)\nprob = ODEProblem(HH!, u0, tspan, p, callback=epsp_ts)\nsol = solve(prob);\nplot(sol, vars=7)","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"plot(sol, vars=[5,6])","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"We can also change these time constants such that the dynamics show short-term depression instead of facilitation.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"epsp_ts= PresetTimeCallback(100:100:500, epsp!)\n\np = [35.0, 40.0, 0.3, -77.0, 55.0, -65.0, 1, 0, 30, 100, 1000, 0.5, 0.005, 0]\nu0 = [-60, n_inf(-60), m_inf(-60), h_inf(-60), 0.0, 1.0, 0.0]\ntspan = (0.0, 700)\nprob = ODEProblem(HH!, u0, tspan, p, callback=epsp_ts)\nsol = solve(prob);\nplot(sol, vars=7)","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"plot(sol, vars=[5,6])","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Just changing those two time constants has changed the dynamics to short-term depression. This is still frequency dependent. Changing these parameters can generate a variety of different short-term dynamics.","category":"page"},{"location":"models/08-spiking_neural_systems/#Summary","page":"Spiking Neural Systems","title":"Summary","text":"","category":"section"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"That's it for now. Thanks for making it this far. If you want to learn more about neuronal dynamics, this is a great resource. If you want to learn more about Julia check out the official website and to learn more about the DifferentialEquations package you are in the right place, because this chapter is part of a larger tutorial series about just that.","category":"page"},{"location":"models/08-spiking_neural_systems/#Appendix","page":"Spiking Neural Systems","title":"Appendix","text":"","category":"section"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"tutorials/models\",\"08-spiking_neural_systems.jmd\")","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Computer Information:","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Julia Version 1.6.2\nCommit 1b93d53fc4 (2021-07-14 15:36 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, znver2)\nEnvironment:\n  JULIA_DEPOT_PATH = /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n  JULIA_NUM_THREADS = 16\n","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Package Information:","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"      Status `/var/lib/buildkite-agent/builds/1-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/models/Project.toml`\n  [479239e8] Catalyst v6.12.1\n  [459566f4] DiffEqCallbacks v2.16.1\n  [f3b72e0c] DiffEqDevTools v2.27.2\n  [055956cb] DiffEqPhysics v3.9.0\n  [0c46a032] DifferentialEquations v6.17.1\n  [31c24e10] Distributions v0.24.18\n  [587475ba] Flux v0.12.1\n  [f6369f11] ForwardDiff v0.10.18\n  [23fbe1c1] Latexify v0.15.5\n  [961ee093] ModelingToolkit v5.17.3\n  [2774e3e8] NLsolve v4.5.1\n  [315f7962] NeuralPDE v3.10.1\n  [429524aa] Optim v1.3.0\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [91a5bcdd] Plots v1.15.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [789caeaf] StochasticDiffEq v6.34.1\n  [37e2e46d] LinearAlgebra\n  [2f01184e] SparseArrays","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"And the full manifest:","category":"page"},{"location":"models/08-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"      Status `/var/lib/buildkite-agent/builds/1-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/models/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.16.0\n  [621f4979] AbstractFFTs v1.0.1\n  [1520ce14] AbstractTrees v0.3.4\n  [79e6a3ab] Adapt v3.3.0\n  [ec485272] ArnoldiMethod v0.1.0\n  [4fba245c] ArrayInterface v3.1.15\n  [4c555306] ArrayLayouts v0.7.0\n  [13072b0f] AxisAlgorithms v1.0.0\n  [ab4f0b2a] BFloat16s v0.1.0\n  [aae01518] BandedMatrices v0.16.9\n  [764a87c0] BoundaryValueDiffEq v2.7.1\n  [fa961155] CEnum v0.4.1\n  [00ebfdb7] CSTParser v2.5.0\n  [052768ef] CUDA v2.6.3\n  [479239e8] Catalyst v6.12.1\n  [082447d4] ChainRules v0.7.65\n  [d360d2e6] ChainRulesCore v0.9.44\n  [b630d9fa] CheapThreads v0.2.5\n  [944b1d66] CodecZlib v0.7.0\n  [35d6a980] ColorSchemes v3.12.1\n  [3da002f7] ColorTypes v0.11.0\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [a80b9123] CommonMark v0.8.1\n  [38540f10] CommonSolve v0.2.0\n  [bbf7d656] CommonSubexpressions v0.3.0\n  [34da2185] Compat v3.30.0\n  [8f4d0f93] Conda v1.5.2\n  [88cd18e8] ConsoleProgressMonitor v0.1.2\n  [187b0558] ConstructionBase v1.2.1\n  [d38c429a] Contour v0.5.7\n  [a8cc5b0e] Crayons v4.0.4\n  [8a292aeb] Cuba v2.2.0\n  [667455a9] Cubature v1.5.1\n  [9a962f9c] DataAPI v1.6.0\n  [82cc6244] DataInterpolations v3.3.1\n  [864edb3b] DataStructures v0.18.9\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [bcd4f6db] DelayDiffEq v5.31.0\n  [2b5f629d] DiffEqBase v6.62.2\n  [459566f4] DiffEqCallbacks v2.16.1\n  [f3b72e0c] DiffEqDevTools v2.27.2\n  [5a0ffddc] DiffEqFinancial v2.4.0\n  [aae7a2af] DiffEqFlux v1.37.0\n  [c894b116] DiffEqJump v6.14.2\n  [77a26b50] DiffEqNoiseProcess v5.7.3\n  [055956cb] DiffEqPhysics v3.9.0\n  [41bf760c] DiffEqSensitivity v6.45.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.0.2\n  [0c46a032] DifferentialEquations v6.17.1\n  [c619ae07] DimensionalPlotRecipes v1.2.0\n  [b4f34e82] Distances v0.10.3\n  [31c24e10] Distributions v0.24.18\n  [ced4e74d] DistributionsAD v0.6.26\n  [ffbed154] DocStringExtensions v0.8.4\n  [e30172f5] Documenter v0.26.3\n  [d4d017d3] ExponentialUtilities v1.8.4\n  [e2ba6199] ExprTools v0.1.3\n  [c87230d0] FFMPEG v0.4.0\n  [7a1cc6ca] FFTW v1.4.1\n  [7034ab61] FastBroadcast v0.1.8\n  [9aa1b823] FastClosures v0.3.2\n  [1a297f60] FillArrays v0.11.7\n  [6a86dc24] FiniteDiff v2.8.0\n  [53c48c17] FixedPointNumbers v0.8.4\n  [587475ba] Flux v0.12.1\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.18\n  [069b7b12] FunctionWrappers v1.1.2\n  [d9f16b24] Functors v0.2.1\n  [0c68f7d7] GPUArrays v6.4.1\n  [61eb1bfa] GPUCompiler v0.10.0\n  [28b8d3ca] GR v0.57.4\n  [a75be94c] GalacticOptim v1.2.0\n  [5c1252a2] GeometryBasics v0.3.12\n  [af5da776] GlobalSensitivity v1.0.0\n  [42e2da0e] Grisu v1.0.2\n  [19dc6840] HCubature v1.5.0\n  [cd3eb016] HTTP v0.9.9\n  [eafb193a] Highlights v0.4.5\n  [0e44f5e4] Hwloc v2.0.0\n  [7073ff75] IJulia v1.23.2\n  [b5f81e59] IOCapture v0.1.1\n  [7869d1d1] IRTools v0.4.2\n  [615f187c] IfElse v0.1.0\n  [d25df0c9] Inflate v0.1.2\n  [83e8ac13] IniFile v0.5.0\n  [a98d9a8b] Interpolations v0.13.2\n  [c8e1da08] IterTools v1.3.0\n  [42fd0dbc] IterativeSolvers v0.9.1\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.3.0\n  [682c06a0] JSON v0.21.1\n  [98e50ef6] JuliaFormatter v0.13.7\n  [e5e0dc1b] Juno v0.8.4\n  [5ab0869b] KernelDensity v0.6.3\n  [929cbde3] LLVM v3.7.1\n  [b964fa9f] LaTeXStrings v1.2.1\n  [2ee39098] LabelledArrays v1.6.1\n  [23fbe1c1] Latexify v0.15.5\n  [a5e1c1ea] LatinHypercubeSampling v1.8.0\n  [73f95e8e] LatticeRules v0.0.1\n  [1d6d02ad] LeftChildRightSiblingTrees v0.1.2\n  [093fc24a] LightGraphs v1.3.5\n  [d3d80556] LineSearches v7.1.1\n  [2ab3a3ac] LogExpFunctions v0.2.4\n  [e6f89c97] LoggingExtras v0.4.6\n  [bdcacae8] LoopVectorization v0.12.23\n  [1914dd2f] MacroTools v0.5.6\n  [739be429] MbedTLS v1.0.3\n  [442fdcdd] Measures v0.3.1\n  [e89f7d12] Media v0.5.0\n  [c03570c3] Memoize v0.4.4\n  [e1d29d7a] Missings v1.0.0\n  [961ee093] ModelingToolkit v5.17.3\n  [4886b29c] MonteCarloIntegration v0.0.2\n  [46d2c3a1] MuladdMacro v0.2.2\n  [f9640e96] MultiScaleArrays v1.8.1\n  [ffc61752] Mustache v1.0.10\n  [d41bc354] NLSolversBase v7.8.0\n  [2774e3e8] NLsolve v4.5.1\n  [872c559c] NNlib v0.7.19\n  [77ba4419] NaNMath v0.3.5\n  [315f7962] NeuralPDE v3.10.1\n  [8913a72c] NonlinearSolve v0.3.8\n  [6fe1bfb0] OffsetArrays v1.9.0\n  [429524aa] Optim v1.3.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [90014a1f] PDMats v0.11.0\n  [65888b18] ParameterizedFunctions v5.10.0\n  [d96e819e] Parameters v0.12.2\n  [69de0a69] Parsers v1.1.0\n  [ccf2f8ad] PlotThemes v2.0.1\n  [995b91a9] PlotUtils v1.0.10\n  [91a5bcdd] Plots v1.15.2\n  [e409e4f3] PoissonRandom v0.4.0\n  [f517fe37] Polyester v0.3.1\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [21216c6a] Preferences v1.2.2\n  [33c8b6b6] ProgressLogging v0.1.4\n  [92933f4c] ProgressMeter v1.6.2\n  [1fd47b50] QuadGK v2.4.1\n  [67601950] Quadrature v1.8.1\n  [8a4e6c94] QuasiMonteCarlo v0.2.2\n  [74087812] Random123 v1.3.1\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.4.0\n  [c84ed2f1] Ratios v0.4.0\n  [3cdcf5f2] RecipesBase v1.1.1\n  [01d81517] RecipesPipeline v0.3.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [f2c3362d] RecursiveFactorization v0.1.12\n  [189a3867] Reexport v1.0.0\n  [ae029012] Requires v1.1.3\n  [ae5879a3] ResettableStacks v1.1.0\n  [37e2e3b7] ReverseDiff v1.9.0\n  [79098fc4] Rmath v0.7.0\n  [47965b36] RootedTrees v1.0.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.2\n  [476501e8] SLEEFPirates v0.6.20\n  [1bc83da4] SafeTestsets v0.0.1\n  [0bca4576] SciMLBase v1.13.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [6c6a2e73] Scratch v1.0.3\n  [efcf1570] Setfield v0.7.0\n  [992d4aef] Showoff v1.0.3\n  [699a6c99] SimpleTraits v0.9.3\n  [ed01d8cd] Sobol v1.5.0\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.0\n  [47a9eef4] SparseDiffTools v1.13.2\n  [276daf66] SpecialFunctions v1.4.1\n  [860ef19b] StableRNGs v1.0.0\n  [aedffcd0] Static v0.2.4\n  [90137ffa] StaticArrays v1.2.0\n  [82ae8749] StatsAPI v1.0.0\n  [2913bbd2] StatsBase v0.33.8\n  [4c63d2b9] StatsFuns v0.9.8\n  [9672c7b4] SteadyStateDiffEq v1.6.2\n  [789caeaf] StochasticDiffEq v6.34.1\n  [7792a7ef] StrideArraysCore v0.1.11\n  [09ab397b] StructArrays v0.5.1\n  [c3572dad] Sundials v4.4.3\n  [d1185830] SymbolicUtils v0.11.2\n  [0c5d862f] Symbolics v0.1.25\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.4.2\n  [5d786b92] TerminalLoggers v0.1.3\n  [8290d209] ThreadingUtilities v0.4.4\n  [a759f4b9] TimerOutputs v0.5.9\n  [0796e94c] Tokenize v0.5.16\n  [9f7883ad] Tracker v0.2.16\n  [3bb67fe8] TranscodingStreams v0.9.5\n  [592b5752] Trapz v2.0.2\n  [a2a6695c] TreeViews v0.3.0\n  [5c2747f8] URIs v1.3.0\n  [3a884ed6] UnPack v1.0.2\n  [1986cc42] Unitful v1.7.0\n  [3d5dd08c] VectorizationBase v0.20.11\n  [81def892] VersionParsing v1.2.0\n  [19fa3120] VertexSafeGraphs v0.1.2\n  [44d3d7a6] Weave v0.10.8\n  [efce3f68] WoodburyMatrices v0.5.3\n  [ddb6d928] YAML v0.4.6\n  [c2297ded] ZMQ v1.2.1\n  [a5390f91] ZipFile v0.9.3\n  [e88e6eb3] Zygote v0.6.11\n  [700de1a5] ZygoteRules v0.2.1\n  [6e34b625] Bzip2_jll v1.0.6+5\n  [83423d85] Cairo_jll v1.16.0+6\n  [3bed1096] Cuba_jll v4.2.1+0\n  [7bc98958] Cubature_jll v1.0.4+0\n  [5ae413db] EarCut_jll v2.1.5+1\n  [2e619515] Expat_jll v2.2.10+0\n  [b22a6f82] FFMPEG_jll v4.3.1+4\n  [f5851436] FFTW_jll v3.3.9+7\n  [a3f928ae] Fontconfig_jll v2.13.1+14\n  [d7e528f0] FreeType2_jll v2.10.1+5\n  [559328eb] FriBidi_jll v1.0.5+6\n  [0656b61e] GLFW_jll v3.3.4+0\n  [d2c73de3] GR_jll v0.57.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.1+0\n  [e33a78d0] Hwloc_jll v2.4.1+0\n  [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2\n  [aacddb02] JpegTurbo_jll v2.0.1+3\n  [c1c5ebd0] LAME_jll v3.100.0+3\n  [dd4b983a] LZO_jll v2.10.1+0\n  [dd192d2f] LibVPX_jll v1.9.0+1\n  [e9f186c6] Libffi_jll v3.2.2+0\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+0\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.1.0+2\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [856f044c] MKL_jll v2021.1.1+1\n  [e7412a2a] Ogg_jll v1.3.4+2\n  [458c3c95] OpenSSL_jll v1.1.1+6\n  [efe28fd5] OpenSpecFun_jll v0.5.4+0\n  [91d4177d] Opus_jll v1.3.1+3\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.2+0\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.0+1\n  [a2964d1f] Wayland_jll v1.17.0+4\n  [2381bf8a] Wayland_protocols_jll v1.18.0+4\n  [02c8fc9c] XML2_jll v2.9.12+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.2+6\n  [3161d3a3] Zstd_jll v1.5.0+0\n  [0ac62f75] libass_jll v0.14.0+4\n  [f638f0a6] libfdk_aac_jll v0.1.6+4\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.6+6\n  [1270edf5] x264_jll v2020.7.14+2\n  [dfaa095f] x265_jll v3.0.0+3\n  [d8fb68d0] xkbcommon_jll v0.9.1+5\n  [0dad84c5] ArgTools\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [4af54fe1] LazyArtifacts\n  [b27032c2] LibCURL\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions\n  [44cfe95a] Pkg\n  [de0858da] Printf\n  [9abbd945] Profile\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML\n  [a4e569a6] Tar\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll\n  [deac9b47] LibCURL_jll\n  [29816b5a] LibSSH2_jll\n  [c8ffd9c3] MbedTLS_jll\n  [14a3606d] MozillaCACerts_jll\n  [4536629a] OpenBLAS_jll\n  [bea87d4a] SuiteSparse_jll\n  [83775a58] Zlib_jll\n  [8e850ede] nghttp2_jll\n  [3f19e933] p7zip_jll","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/#Optimization-Under-Uncertainty-with-DiffEqUncertainty.jl","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"","category":"section"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"This tutorial gives and overview of how to leverage the efficient Koopman expectation method from DiffEqUncertainty to perform optimization under uncertainty. We demonstrate this by using a bouncing ball model with an uncertain model parameter. We also demonstrate its application to problems with probabilistic constraints, in particular a special class of constraints called chance constraints. ","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/#System-Model","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"System Model","text":"","category":"section"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"First lets consider a 2D bouncing ball, where the states are the horizontal position x, horizontal velocity dotx, vertical position y, and vertical velocity doty. This model has two system parameters, acceleration due to gravity and coefficient of restitution (models energy loss when the ball impacts the ground). We can simulate such a system using ContinuousCallback as","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"using OrdinaryDiffEq, Plots\n\nfunction ball!(du,u,p,t) \n    du[1] = u[2]\n    du[2] = 0.0\n    du[3] = u[4]\n    du[4] = -p[1]\nend\n\nground_condition(u,t,integrator) = u[3]\nground_affect!(integrator) = integrator.u[4] = -integrator.p[2] * integrator.u[4]\nground_cb = ContinuousCallback(ground_condition, ground_affect!)\n\nu0 = [0.0,2.0,50.0,0.0]\ntspan = (0.0,50.0)\np = [9.807, 0.9]\n\nprob = ODEProblem(ball!,u0,tspan,p)\nsol = solve(prob,Tsit5(),callback=ground_cb)\nplot(sol, vars=(1,3), label = nothing, xlabel=\"x\", ylabel=\"y\")","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"(Image: )","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"For this particular problem, we wish to measure the impact distance from a point y=25 on a wall at x=25. So, we introduce an additional callback that terminates the simulation on wall impact. ","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"stop_condition(u,t,integrator) = u[1] - 25.0\nstop_cb = ContinuousCallback(stop_condition, terminate!)\ncbs = CallbackSet(ground_cb, stop_cb)\n\ntspan = (0.0, 1500.0)\nprob = ODEProblem(ball!,u0,tspan,p)\nsol = solve(prob,Tsit5(),callback=cbs)","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"To help visualize this problem, we plot as follows, where the star indicates a desired impace location","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"rectangle(xc, yc, w, h) = Shape(xc .+ [-w,w,w,-w]./2.0, yc .+ [-h,-h,h,h]./2.0)\n\nbegin\n    plot(sol, vars=(1,3), label=nothing, lw = 3, c=:black)\n    xlabel!(\"x [m]\")\n    ylabel!(\"y [m]\")\n    plot!(rectangle(27.5, 25, 5, 50), c=:red, label = nothing)\n    scatter!([25],[25],marker=:star, ms=10, label = nothing,c=:green)\n    ylims!(0.0,50.0)\nend","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"(Image: )","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/#Considering-Uncertainty","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Considering Uncertainty","text":"","category":"section"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"We now wish to introduce uncertainty in p[2], the coefficient of restitution. This is defined via a continuous univiate distribution from Distributions.jl. We can then run a Monte Carlo simulation of 100,000 trajectories via the EnsembleProblem interface.","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"using Distributions\n\ncor_dist = truncated(Normal(0.9, 0.02), 0.9-3*0.02, 1.0)\ntrajectories = 100000\n\nprob_func(prob,i,repeat) = remake(prob, p = [p[1], rand(cor_dist)])\nensemble_prob = EnsembleProblem(prob,prob_func=prob_func)\nensemblesol = solve(ensemble_prob,Tsit5(),EnsembleThreads(),trajectories=trajectories, callback=cbs)\n\nbegin # plot\n    plot(ensemblesol, vars = (1,3), lw=1,alpha=0.2, label=nothing, idxs = 1:350)\n    xlabel!(\"x [m]\")\n    ylabel!(\"y [m]\")\n    plot!(rectangle(27.5, 25, 5, 50), c=:red, label = nothing)\n    scatter!([25],[25],marker=:star, ms=10, label = nothing, c=:green)\n    plot!(sol, vars=(1,3), label=nothing, lw = 3, c=:black, ls=:dash)\n    xlims!(0.0,27.5)\nend","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"(Image: )","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"Here, we plot the first 350 Monte Carlo simulations along with the trajectory corrresponding to the mean of the distribution (dashed line).","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"We now wish to compute the expected squared impact distance from the star. This is called an \"observation\" of our system or an \"observable\" of interest. ","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"We define this observable as","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"obs(sol) = abs2(sol[3,end]-25)","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"obs (generic function with 1 method)","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"With the observable defined, we can compute the expected squared miss distance from our Monte Carlo simulation results as","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"mean_ensemble = mean([obs(sol) for sol in ensemblesol])","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"36.003264051459894","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"Alternatively, we can use the Koopman() algorithm in DiffEqUncertainty.jl to compute this expectation much more efficiently as","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"using DiffEqUncertainty\n\np_uncertain = [9.807, cor_dist]\nexpectation(obs, prob, u0, p_uncertain, Koopman(), Tsit5();\n            ireltol = 1e-5, callback=cbs)","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"u: 36.008628214169704","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/#Optimization-Under-Uncertainty","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty","text":"","category":"section"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"We now wish to optimize the initial position (x_0y_0) and horizontal velocity (dotx_0) of the system to minimize the expected squared miss distance from the star, where x_0inleft-1000right, y_0inleft13right, and dotx_0inleft1050right. We will demonstrate this using a gradient-based optimization approach from NLopt.jl using ForwardDiff.jl AD through the expectation calculation.","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"First, we load the required packages and define our loss function","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"using NLopt, DiffEqSensitivity, ForwardDiff\n\nmake_u0(θ) = [θ[1],θ[2],θ[3], 0.0]\n\nfunction 𝔼_loss(θ)   # \\bbE\n    u0 = make_u0(θ)\n    expectation(obs, prob, u0, p_uncertain, Koopman(), Tsit5();\n                 ireltol = 1e-5, callback=cbs)[1]\nend","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"𝔼_loss (generic function with 1 method)","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"NLopt requires that this loss function return the loss as above, but also do an inplace update of the gradient. So, we wrap this function to put it in the form required by NLopt. ","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"function 𝔼_loss_nlopt(x,∇)\n    length(∇) > 0 ? ForwardDiff.gradient!(∇, 𝔼_loss,x) : nothing\n    𝔼_loss(x)\nend","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"𝔼_loss_nlopt (generic function with 1 method)","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"We then optimize using the Method of Moving Asymptotes algorithm (:LD_MMA)","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"opt = Opt(:LD_MMA, 3)\nopt.lower_bounds = [-100.0,1.0, 10.0]\nopt.upper_bounds = [0.0,3.0, 50.0]\nopt.xtol_rel = 1e-3\nopt.min_objective = 𝔼_loss_nlopt\n(minf,minx,ret) = NLopt.optimize(opt, [-1.0, 2.0, 50.0])","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"(0.0838151729557601, [-0.05713109086715892, 2.4366742783682063, 49.99835957\n072762], :XTOL_REACHED)","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"Let's now visualize 350 Monte Carlo simulations","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"ensembleprob = EnsembleProblem(remake(prob,u0 = make_u0(minx)),prob_func=prob_func)\nensemblesol = solve(ensembleprob,Tsit5(),EnsembleThreads(), trajectories=100_000, callback=cbs)\n\nbegin\n    plot(ensemblesol, vars = (1,3), lw=1,alpha=0.1, label=nothing, idxs = 1:350)\n    plot!(solve(remake(prob, u0=make_u0(minx)),Tsit5(), callback=cbs), \n            vars=(1,3),label = nothing, c=:black, lw=3,ls=:dash)\n    xlabel!(\"x [m]\")\n    ylabel!(\"y [m]\")\n    plot!(rectangle(27.5, 25, 5, 50), c=:red, label = nothing)\n    scatter!([25],[25],marker=:star, ms=10, label = nothing,c=:green)\n    ylims!(0.0,50.0)\n    xlims!(minx[1], 27.5)\nend","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"(Image: )","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"Looks pretty good! But, how long did it take? Let's benchmark.","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"using BenchmarkTools\n\n@btime NLopt.optimize($opt, $[-1.0, 2.0, 50.0])","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"131.701 ms (851126 allocations: 63.07 MiB)\n(0.0838151729557601, [-0.05713109086715892, 2.4366742783682063, 49.99835957\n072762], :XTOL_REACHED)","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"Not bad for bound constrained optimization under uncertainty of a hybrid system!","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/#Probabilistic-Constraints","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Probabilistic Constraints","text":"","category":"section"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"With this approach we can also consider probabilistic constraints. Let us now consider a wall at x=20 with height 25.","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"constraint = [20.0, 25.0]\nbegin\n    plot(rectangle(27.5, 25, 5, 50), c=:red, label = nothing)\n    xlabel!(\"x [m]\")\n    ylabel!(\"y [m]\")\n    plot!([constraint[1], constraint[1]],[0.0,constraint[2]], lw=5, c=:black, label=nothing)\n    scatter!([25],[25],marker=:star, ms=10, label = nothing,c=:green)\n    ylims!(0.0,50.0)\n    xlims!(minx[1], 27.5)\nend","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"(Image: )","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"We now wish to minimize the same loss function as before, but introduce an inequality constraint such that the solution must have less than a 1% chance of colliding with the wall at x=20. This class of probabilistic constraints is called a chance constraint. ","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"To do this, we first introduce a new callback and solve the system using the previous optimal solution","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"constraint_condition(u,t,integrator) = u[1] - constraint[1]\nconstraint_affect!(integrator) = integrator.u[3] < constraint[2] ? terminate!(integrator) : nothing\nconstraint_cb = ContinuousCallback(constraint_condition, constraint_affect!, save_positions=(true,false));\nconstraint_cbs = CallbackSet(ground_cb, stop_cb, constraint_cb)\n\nensemblesol = solve(ensembleprob,Tsit5(),EnsembleThreads(), trajectories=350, callback=constraint_cbs, maxstep=0.1)\n\nbegin\n    plot(ensemblesol, vars = (1,3), lw=1,alpha=0.1, label=nothing)\n    plot!(solve(remake(prob, u0=make_u0(minx)),Tsit5(), callback=constraint_cbs), \n            vars=(1,3),label = nothing, c=:black, lw=3, ls=:dash)\n\n    xlabel!(\"x [m]\")\n    ylabel!(\"y [m]\")\n    plot!(rectangle(27.5, 25, 5, 50), c=:red, label = nothing)\n    plot!([constraint[1], constraint[1]],[0.0,constraint[2]], lw=5, c=:black)\n    scatter!([25],[25],marker=:star, ms=10, label = nothing,c=:green)\n    ylims!(0.0,50.0)\n    xlims!(minx[1], 27.5)\nend","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"(Image: )","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"That doesn't look good! ","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"We now need a second observable for the system. In order to compute a probability of impact, we use an indicator function for if a trajectory impacts the wall. In other words, this functions returns 1 if the trajectory hits the wall and 0 otherwise.","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"constraint_obs(sol) = sol[1,end] ≈ constraint[1] ? one(sol[1,end]) : zero(sol[1,end])","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"constraint_obs (generic function with 1 method)","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"Using the previously computed optimal initial conditions, lets compute the probability of hitting this wall","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"expectation(constraint_obs, prob, make_u0(minx), p_uncertain, Koopman(), Tsit5();\n            ireltol= 1e-9, iabstol = 1e-9, callback=constraint_cbs)[1]","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"0.9910305871387488","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"We then setup the constraint function for NLopt just as before. ","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"function 𝔼_constraint(θ)\n    u0 = [θ[1],θ[2],θ[3], 0.0]\n    expectation(constraint_obs, prob, u0, p_uncertain, Koopman(), Tsit5(),\n                ireltol= 1e-9, iabstol = 1e-9,callback=constraint_cbs)[1]\nend\n\nfunction 𝔼_constraint_nlopt(x,∇)\n    length(∇) > 0 ? ForwardDiff.gradient!(∇, 𝔼_constraint,x) : nothing\n    𝔼_constraint(x) - 0.01\nend","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"𝔼_constraint_nlopt (generic function with 1 method)","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"Note that NLopt requires the constraint function to be of the form g(x) leq 0. Hence, why we return 𝔼_constraint(x) - 0.01 for the 1% chance constraint.","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"The rest of the NLopt setup looks the same as before with the exception of adding the inequality constraint","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"opt = Opt(:LD_MMA, 3)\nopt.lower_bounds = [-100.0, 1.0, 10.0]\nopt.upper_bounds = [0.0, 3.0, 50.0]\nopt.xtol_rel = 1e-3\nopt.min_objective = 𝔼_loss_nlopt\ninequality_constraint!(opt,𝔼_constraint_nlopt, 1e-5)\n(minf2,minx2,ret2) = NLopt.optimize(opt, [-1.0, 2.0, 50.0])","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"(40.28996781875263, [-0.8176321801341233, 2.000952669391841, 50.0], :XTOL_R\nEACHED)","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"The probability of impacting the wall is now","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"λ = 𝔼_constraint(minx2)","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"0.010004498174330818","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"We can check if this is within tolerance by","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"λ - 0.01 <= 1e-5","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"true","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"Again, we plot some Monte Carlo simulations from this result as follows","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"ensembleprob = EnsembleProblem(remake(prob,u0 = make_u0(minx2)),prob_func=prob_func)\nensemblesol = solve(ensembleprob,Tsit5(),EnsembleThreads(), \n                    trajectories=350, callback=constraint_cbs)\n\nbegin\n    plot(ensemblesol, vars = (1,3), lw=1,alpha=0.1, label=nothing)\n    plot!(solve(remake(prob, u0=make_u0(minx2)),Tsit5(), callback=constraint_cbs), \n            vars=(1,3),label = nothing, c=:black, lw=3, ls=:dash)\n    plot!([constraint[1], constraint[1]],[0.0,constraint[2]], lw=5, c=:black)\n\n    xlabel!(\"x [m]\")\n    ylabel!(\"y [m]\")\n    plot!(rectangle(27.5, 25, 5, 50), c=:red, label = nothing)\n    scatter!([25],[25],marker=:star, ms=10, label = nothing,c=:green)\n    ylims!(0.0,50.0)\n    xlims!(minx[1], 27.5)\nend","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"(Image: )","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/#Appendix","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Appendix","text":"","category":"section"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"This tutorial is part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl.  For more information on doing scientific machine learning (SciML) with open source software, check out https://sciml.ai/.","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"DiffEqUncertainty\",\"02-AD_and_optimization.jmd\")","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"Computer Information:","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"Julia Version 1.4.2\nCommit 44fa15b150* (2020-05-23 18:35 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Core(TM) i7-9700K CPU @ 3.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-8.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_LOAD_PATH = /builds/JuliaGPU/DiffEqTutorials.jl:\n  JULIA_DEPOT_PATH = /builds/JuliaGPU/DiffEqTutorials.jl/.julia\n  JULIA_CUDA_MEMORY_LIMIT = 2147483648\n  JULIA_NUM_THREADS = 8\n","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"Package Information:","category":"page"},{"location":"DiffEqUncertainty/02-AD_and_optimization/","page":"Optimization Under Uncertainty with DiffEqUncertainty.jl","title":"Optimization Under Uncertainty with DiffEqUncertainty.jl","text":"Status `/builds/JuliaGPU/DiffEqTutorials.jl/tutorials/DiffEqUncertainty/Project.toml`\n[6e4b80f9-dd63-53aa-95a3-0cdb28fa8baf] BenchmarkTools 0.5.0\n[8a292aeb-7a57-582c-b821-06e4c11590b1] Cuba 2.1.0\n[071ae1c0-96b5-11e9-1965-c90190d839ea] DiffEqGPU 1.5.0\n[41bf760c-e81c-5289-8e54-58b1f1f8abe2] DiffEqSensitivity 6.28.0\n[ef61062a-5684-51dc-bb67-a0fcdec5c97d] DiffEqUncertainty 1.5.0\n[0c46a032-eb83-5123-abaf-570d42b7fbaa] DifferentialEquations 6.15.0\n[31c24e10-a181-5473-b8eb-7969acd0382f] Distributions 0.23.8\n[f6369f11-7733-5829-9624-2563aa707210] ForwardDiff 0.10.12\n[76087f3c-5699-56af-9a33-bf431cd00edd] NLopt 0.6.0\n[1dea7af3-3e70-54e6-95c3-0bf5283fa5ed] OrdinaryDiffEq 5.42.1\n[91a5bcdd-55d7-5caf-9e0b-520d859cae80] Plots 1.5.8\n[67601950-bd08-11e9-3c89-fd23fb4432d2] Quadrature 1.3.0","category":"page"},{"location":"advanced/03-kolmogorov_equations/#Kolmogorov-Backward-Equations","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"","category":"section"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"using Flux, StochasticDiffEq\nusing NeuralPDE\nusing Plots\nusing CUDA","category":"page"},{"location":"advanced/03-kolmogorov_equations/#Introduction-on-Backward-Kolmogorov-Equations","page":"Kolmogorov Backward Equations","title":"Introduction on Backward Kolmogorov Equations","text":"","category":"section"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"The backward Kolmogorov Equation deals with a terminal condtion. The one dimensional backward kolmogorov equation that we are going to deal with is of the form :","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"$","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"\\frac{\\partial p}{\\partial t} = -\\mu(x)\\frac{\\partial p}{\\partial x} - \\frac{1}{2}{\\sigma^2}(x)\\frac{\\partial^2 p}{\\partial x^2} ,\\hspace{0.5cm} p(T , x) = \\varphi(x) $ for all $ t \\in{ [0 , T] } $ and for all $ x \\in R^d $","category":"page"},{"location":"advanced/03-kolmogorov_equations/#The-Black-Scholes-Model","page":"Kolmogorov Backward Equations","title":"The Black Scholes Model","text":"","category":"section"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"The Black-Scholes Model governs the price evolution of the European put or call option. In the below equation V is the price of some derivative , S is the Stock Price , r is the risk free interest rate and σ the volatility of the stock returns. The payoff at a time T is known to us. And this makes it a terminal PDE. In case of an European put option the PDE is: $   \\frac{\\partial V}{\\partial t} + rS\\frac{\\partial V}{\\partial S} + \\frac{1}{2}{\\sigma^2}{S^2}\\frac{\\partial^2 V}{\\partial S^2} -rV = 0  ,\\hspace{0.5cm} V(T , S) =  max{\\mathcal{K} - S , 0 } $ for all $ t \\in{ [0 , T] } $ and for all $ S \\in R^d $","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"In order to make the above equation in the form of the Backward - Kolmogorov PDE we should substitute","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"$","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"V(S , t) = e^{r(t-T)}p(S , t) $ and thus we get $   e^{r(t-T)}\\frac{\\partial p}{\\partial t} + re^{r(t-T)}p(S , t)  = -\\mu(x)\\frac{\\partial p}{\\partial x}e^{r(t-T)} - \\frac{1}{2}{\\sigma^2}(x)\\frac{\\partial^2 p}{\\partial x^2}e^{r(t-T)}","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"re^{r(t-T)}p(S , t)","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"$","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"And the terminal condition $   p(S , T) = max{ \\mathcal{K} - x , 0 } $ We will train our model and the model itself will be the solution of the equation","category":"page"},{"location":"advanced/03-kolmogorov_equations/#Defining-the-problem-and-the-solver","page":"Kolmogorov Backward Equations","title":"Defining the problem and the solver","text":"","category":"section"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"We should start defining the terminal condition for our equation:","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"function phi(xi)\n    y = Float64[]\n    K = 100\n    for x in eachcol(xi)\n        val = max(K - maximum(x) , 0.00)\n        y = push!(y , val)\n    end\n    y = reshape(y , 1 , size(y)[1] )\n    return y\nend","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"phi (generic function with 1 method)","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"Now we shall define the problem : We will define the σ and μ by comparing it to the orignal equation. The xspan is the span of initial stock prices.","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"d = 1\nr = 0.04\nsigma = 0.2\nxspan = (80.00 , 115.0)\ntspan = (0.0 , 1.0)\nσ(du , u , p , t) = du .= sigma.*u\nμ(du , u , p , t) = du .= r.*u\nprob = KolmogorovPDEProblem(μ , σ , phi , xspan , tspan, d)","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"Error: UndefVarError: KolmogorovPDEProblem not defined","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"Now once we have defined our problem it is necessary to define the parameters for the solver.","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"sdealg = EM()\nensemblealg = EnsembleThreads()\ndt = 0.01\ndx = 0.01\ntrajectories = 100000","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"100000","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"Now lets define our model m and the optimiser","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"m = Chain(Dense(d, 64, elu),Dense(64, 128, elu),Dense(128 , 16 , elu) , Dense(16 , 1))\nuse_gpu = false\nif CUDA.functional() == true\n  m = fmap(CUDA.cu , m)\n  use_gpu = true\nend\nopt = Flux.ADAM(0.0005)","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"Error: UndefVarError: Dense not defined","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"And then finally call the solver","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"@time sol = solve(prob, NeuralPDE.NNKolmogorov(m, opt, sdealg, ensemblealg), verbose = true, dt = dt,\n            dx = dx , trajectories = trajectories , abstol=1e-6, maxiters = 1000 , use_gpu = use_gpu)","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"Error: UndefVarError: NNKolmogorov not defined","category":"page"},{"location":"advanced/03-kolmogorov_equations/#Analyzing-the-solution","page":"Kolmogorov Backward Equations","title":"Analyzing the solution","text":"","category":"section"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"Now let us find a Monte-Carlo Solution and plot the both:","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"monte_carlo_sol = []\nx_out = collect(85:2.00:110.00)\nfor x in x_out\n  u₀= [x]\n  g_val(du , u , p , t) = du .= 0.2.*u\n  f_val(du , u , p , t) = du .= 0.04.*u\n  dt = 0.01\n  tspan = (0.0,1.0)\n  prob = SDEProblem(f_val,g_val,u₀,tspan)\n  output_func(sol,i) = (sol[end],false)\n  ensembleprob_val = EnsembleProblem(prob , output_func = output_func )\n  sim_val = solve(ensembleprob_val, EM(), EnsembleThreads() , dt=0.01, trajectories=100000,adaptive=false)\n  s = reduce(hcat , sim_val.u)\n  mean_phi = sum(phi(s))/length(phi(s))\n  global monte_carlo_sol = push!(monte_carlo_sol , mean_phi)\nend","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"##Plotting the Solutions We should reshape the inputs and outputs to make it compatible with our model. This is the most important part. The algorithm gives a distributed function over all initial prices in the xspan.","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"x_model = reshape(x_out, 1 , size(x_out)[1])\nif use_gpu == true\n  m = fmap(cpu , m)\nend\ny_out = m(x_model)\ny_out = reshape(y_out , 13 , 1)","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"Error: UndefVarError: use_gpu not defined","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"And now finally we can plot the solutions","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"plot(x_out , y_out , lw = 3 ,  xaxis=\"Initial Stock Price\", yaxis=\"Payoff\" , label = \"NNKolmogorov\")\nplot!(x_out , monte_carlo_sol , lw = 3 ,  xaxis=\"Initial Stock Price\", yaxis=\"Payoff\" ,label = \"Monte Carlo Solutions\")","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"Error: UndefVarError: y_out not defined","category":"page"},{"location":"advanced/03-kolmogorov_equations/#Appendix","page":"Kolmogorov Backward Equations","title":"Appendix","text":"","category":"section"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"tutorials/advanced\",\"03-kolmogorov_equations.jmd\")","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"Computer Information:","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"Julia Version 1.6.2\nCommit 1b93d53fc4 (2021-07-14 15:36 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, znver2)\nEnvironment:\n  JULIA_DEPOT_PATH = /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n  JULIA_NUM_THREADS = 16\n","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"Package Information:","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"      Status `/var/lib/buildkite-agent/builds/8-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/advanced/Project.toml`\n  [2169fc97] AlgebraicMultigrid v0.4.0\n  [6e4b80f9] BenchmarkTools v1.0.0\n  [052768ef] CUDA v2.6.3\n  [2b5f629d] DiffEqBase v6.62.2\n  [9fdde737] DiffEqOperators v4.26.0\n  [0c46a032] DifferentialEquations v6.17.1\n  [587475ba] Flux v0.12.1\n  [961ee093] ModelingToolkit v5.17.3\n  [2774e3e8] NLsolve v4.5.1\n  [315f7962] NeuralPDE v3.10.1\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [91a5bcdd] Plots v1.15.2\n  [0bca4576] SciMLBase v1.13.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [47a9eef4] SparseDiffTools v1.13.2\n  [684fba80] SparsityDetection v0.3.4\n  [789caeaf] StochasticDiffEq v6.34.1\n  [c3572dad] Sundials v4.4.3\n  [37e2e46d] LinearAlgebra\n  [2f01184e] SparseArrays","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"And the full manifest:","category":"page"},{"location":"advanced/03-kolmogorov_equations/","page":"Kolmogorov Backward Equations","title":"Kolmogorov Backward Equations","text":"      Status `/var/lib/buildkite-agent/builds/8-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/advanced/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.16.0\n  [621f4979] AbstractFFTs v1.0.1\n  [1520ce14] AbstractTrees v0.3.4\n  [79e6a3ab] Adapt v3.3.0\n  [2169fc97] AlgebraicMultigrid v0.4.0\n  [ec485272] ArnoldiMethod v0.1.0\n  [4fba245c] ArrayInterface v3.1.15\n  [4c555306] ArrayLayouts v0.7.0\n  [13072b0f] AxisAlgorithms v1.0.0\n  [ab4f0b2a] BFloat16s v0.1.0\n  [aae01518] BandedMatrices v0.16.9\n  [6e4b80f9] BenchmarkTools v1.0.0\n  [8e7c35d0] BlockArrays v0.15.3\n  [ffab5731] BlockBandedMatrices v0.10.6\n  [764a87c0] BoundaryValueDiffEq v2.7.1\n  [fa961155] CEnum v0.4.1\n  [00ebfdb7] CSTParser v2.5.0\n  [052768ef] CUDA v2.6.3\n  [7057c7e9] Cassette v0.3.6\n  [082447d4] ChainRules v0.7.65\n  [d360d2e6] ChainRulesCore v0.9.44\n  [b630d9fa] CheapThreads v0.2.5\n  [944b1d66] CodecZlib v0.7.0\n  [35d6a980] ColorSchemes v3.12.1\n  [3da002f7] ColorTypes v0.11.0\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [a80b9123] CommonMark v0.8.1\n  [38540f10] CommonSolve v0.2.0\n  [bbf7d656] CommonSubexpressions v0.3.0\n  [34da2185] Compat v3.30.0\n  [aa819f21] CompatHelper v1.18.6\n  [8f4d0f93] Conda v1.5.2\n  [88cd18e8] ConsoleProgressMonitor v0.1.2\n  [187b0558] ConstructionBase v1.2.1\n  [d38c429a] Contour v0.5.7\n  [a8cc5b0e] Crayons v4.0.4\n  [8a292aeb] Cuba v2.2.0\n  [667455a9] Cubature v1.5.1\n  [9a962f9c] DataAPI v1.6.0\n  [82cc6244] DataInterpolations v3.3.1\n  [864edb3b] DataStructures v0.18.9\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [bcd4f6db] DelayDiffEq v5.31.0\n  [2b5f629d] DiffEqBase v6.62.2\n  [459566f4] DiffEqCallbacks v2.16.1\n  [5a0ffddc] DiffEqFinancial v2.4.0\n  [aae7a2af] DiffEqFlux v1.37.0\n  [c894b116] DiffEqJump v6.14.2\n  [77a26b50] DiffEqNoiseProcess v5.7.3\n  [9fdde737] DiffEqOperators v4.26.0\n  [055956cb] DiffEqPhysics v3.9.0\n  [41bf760c] DiffEqSensitivity v6.45.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.0.2\n  [0c46a032] DifferentialEquations v6.17.1\n  [c619ae07] DimensionalPlotRecipes v1.2.0\n  [b4f34e82] Distances v0.10.3\n  [31c24e10] Distributions v0.24.18\n  [ced4e74d] DistributionsAD v0.6.26\n  [ffbed154] DocStringExtensions v0.8.4\n  [e30172f5] Documenter v0.26.3\n  [d4d017d3] ExponentialUtilities v1.8.4\n  [e2ba6199] ExprTools v0.1.3\n  [8f5d6c58] EzXML v1.1.0\n  [c87230d0] FFMPEG v0.4.0\n  [7a1cc6ca] FFTW v1.4.1\n  [7034ab61] FastBroadcast v0.1.8\n  [9aa1b823] FastClosures v0.3.2\n  [1a297f60] FillArrays v0.11.7\n  [6a86dc24] FiniteDiff v2.8.0\n  [53c48c17] FixedPointNumbers v0.8.4\n  [587475ba] Flux v0.12.1\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.18\n  [069b7b12] FunctionWrappers v1.1.2\n  [d9f16b24] Functors v0.2.1\n  [0c68f7d7] GPUArrays v6.4.1\n  [61eb1bfa] GPUCompiler v0.10.0\n  [28b8d3ca] GR v0.57.4\n  [a75be94c] GalacticOptim v1.2.0\n  [5c1252a2] GeometryBasics v0.3.12\n  [bc5e4493] GitHub v5.4.0\n  [af5da776] GlobalSensitivity v1.0.0\n  [42e2da0e] Grisu v1.0.2\n  [19dc6840] HCubature v1.5.0\n  [cd3eb016] HTTP v0.9.9\n  [eafb193a] Highlights v0.4.5\n  [0e44f5e4] Hwloc v2.0.0\n  [7073ff75] IJulia v1.23.2\n  [b5f81e59] IOCapture v0.1.1\n  [7869d1d1] IRTools v0.4.2\n  [615f187c] IfElse v0.1.0\n  [d25df0c9] Inflate v0.1.2\n  [83e8ac13] IniFile v0.5.0\n  [a98d9a8b] Interpolations v0.13.2\n  [c8e1da08] IterTools v1.3.0\n  [42fd0dbc] IterativeSolvers v0.9.1\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.3.0\n  [682c06a0] JSON v0.21.1\n  [98e50ef6] JuliaFormatter v0.13.7\n  [e5e0dc1b] Juno v0.8.4\n  [5ab0869b] KernelDensity v0.6.3\n  [929cbde3] LLVM v3.7.1\n  [b964fa9f] LaTeXStrings v1.2.1\n  [2ee39098] LabelledArrays v1.6.1\n  [23fbe1c1] Latexify v0.15.5\n  [a5e1c1ea] LatinHypercubeSampling v1.8.0\n  [73f95e8e] LatticeRules v0.0.1\n  [5078a376] LazyArrays v0.21.4\n  [d7e5e226] LazyBandedMatrices v0.5.7\n  [1d6d02ad] LeftChildRightSiblingTrees v0.1.2\n  [093fc24a] LightGraphs v1.3.5\n  [d3d80556] LineSearches v7.1.1\n  [2ab3a3ac] LogExpFunctions v0.2.4\n  [e6f89c97] LoggingExtras v0.4.6\n  [bdcacae8] LoopVectorization v0.12.23\n  [1914dd2f] MacroTools v0.5.6\n  [a3b82374] MatrixFactorizations v0.8.3\n  [739be429] MbedTLS v1.0.3\n  [442fdcdd] Measures v0.3.1\n  [e89f7d12] Media v0.5.0\n  [c03570c3] Memoize v0.4.4\n  [e1d29d7a] Missings v1.0.0\n  [78c3b35d] Mocking v0.7.1\n  [961ee093] ModelingToolkit v5.17.3\n  [4886b29c] MonteCarloIntegration v0.0.2\n  [46d2c3a1] MuladdMacro v0.2.2\n  [f9640e96] MultiScaleArrays v1.8.1\n  [ffc61752] Mustache v1.0.10\n  [d41bc354] NLSolversBase v7.8.0\n  [2774e3e8] NLsolve v4.5.1\n  [872c559c] NNlib v0.7.19\n  [77ba4419] NaNMath v0.3.5\n  [315f7962] NeuralPDE v3.10.1\n  [8913a72c] NonlinearSolve v0.3.8\n  [6fe1bfb0] OffsetArrays v1.9.0\n  [429524aa] Optim v1.3.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [90014a1f] PDMats v0.11.0\n  [65888b18] ParameterizedFunctions v5.10.0\n  [d96e819e] Parameters v0.12.2\n  [69de0a69] Parsers v1.1.0\n  [ccf2f8ad] PlotThemes v2.0.1\n  [995b91a9] PlotUtils v1.0.10\n  [91a5bcdd] Plots v1.15.2\n  [e409e4f3] PoissonRandom v0.4.0\n  [f517fe37] Polyester v0.3.1\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [21216c6a] Preferences v1.2.2\n  [33c8b6b6] ProgressLogging v0.1.4\n  [92933f4c] ProgressMeter v1.6.2\n  [1fd47b50] QuadGK v2.4.1\n  [67601950] Quadrature v1.8.1\n  [8a4e6c94] QuasiMonteCarlo v0.2.2\n  [74087812] Random123 v1.3.1\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.4.0\n  [c84ed2f1] Ratios v0.4.0\n  [3cdcf5f2] RecipesBase v1.1.1\n  [01d81517] RecipesPipeline v0.3.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [f2c3362d] RecursiveFactorization v0.1.12\n  [189a3867] Reexport v1.0.0\n  [ae029012] Requires v1.1.3\n  [ae5879a3] ResettableStacks v1.1.0\n  [37e2e3b7] ReverseDiff v1.9.0\n  [79098fc4] Rmath v0.7.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.2\n  [476501e8] SLEEFPirates v0.6.20\n  [1bc83da4] SafeTestsets v0.0.1\n  [0bca4576] SciMLBase v1.13.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [6c6a2e73] Scratch v1.0.3\n  [efcf1570] Setfield v0.7.0\n  [992d4aef] Showoff v1.0.3\n  [699a6c99] SimpleTraits v0.9.3\n  [ed01d8cd] Sobol v1.5.0\n  [2133526b] SodiumSeal v0.1.1\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.0\n  [47a9eef4] SparseDiffTools v1.13.2\n  [684fba80] SparsityDetection v0.3.4\n  [276daf66] SpecialFunctions v1.4.1\n  [860ef19b] StableRNGs v1.0.0\n  [aedffcd0] Static v0.2.4\n  [90137ffa] StaticArrays v1.2.0\n  [82ae8749] StatsAPI v1.0.0\n  [2913bbd2] StatsBase v0.33.8\n  [4c63d2b9] StatsFuns v0.9.8\n  [9672c7b4] SteadyStateDiffEq v1.6.2\n  [789caeaf] StochasticDiffEq v6.34.1\n  [7792a7ef] StrideArraysCore v0.1.11\n  [09ab397b] StructArrays v0.5.1\n  [c3572dad] Sundials v4.4.3\n  [d1185830] SymbolicUtils v0.11.2\n  [0c5d862f] Symbolics v0.1.25\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.4.2\n  [5d786b92] TerminalLoggers v0.1.3\n  [8290d209] ThreadingUtilities v0.4.4\n  [f269a46b] TimeZones v1.5.5\n  [a759f4b9] TimerOutputs v0.5.9\n  [0796e94c] Tokenize v0.5.16\n  [9f7883ad] Tracker v0.2.16\n  [3bb67fe8] TranscodingStreams v0.9.5\n  [592b5752] Trapz v2.0.2\n  [a2a6695c] TreeViews v0.3.0\n  [5c2747f8] URIs v1.3.0\n  [3a884ed6] UnPack v1.0.2\n  [1986cc42] Unitful v1.7.0\n  [3d5dd08c] VectorizationBase v0.20.11\n  [81def892] VersionParsing v1.2.0\n  [19fa3120] VertexSafeGraphs v0.1.2\n  [44d3d7a6] Weave v0.10.8\n  [efce3f68] WoodburyMatrices v0.5.3\n  [ddb6d928] YAML v0.4.6\n  [c2297ded] ZMQ v1.2.1\n  [a5390f91] ZipFile v0.9.3\n  [e88e6eb3] Zygote v0.6.11\n  [700de1a5] ZygoteRules v0.2.1\n  [6e34b625] Bzip2_jll v1.0.6+5\n  [83423d85] Cairo_jll v1.16.0+6\n  [3bed1096] Cuba_jll v4.2.1+0\n  [7bc98958] Cubature_jll v1.0.4+0\n  [5ae413db] EarCut_jll v2.1.5+1\n  [2e619515] Expat_jll v2.2.10+0\n  [b22a6f82] FFMPEG_jll v4.3.1+4\n  [f5851436] FFTW_jll v3.3.9+7\n  [a3f928ae] Fontconfig_jll v2.13.1+14\n  [d7e528f0] FreeType2_jll v2.10.1+5\n  [559328eb] FriBidi_jll v1.0.5+6\n  [0656b61e] GLFW_jll v3.3.4+0\n  [d2c73de3] GR_jll v0.57.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.1+0\n  [e33a78d0] Hwloc_jll v2.4.1+0\n  [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2\n  [aacddb02] JpegTurbo_jll v2.0.1+3\n  [c1c5ebd0] LAME_jll v3.100.0+3\n  [dd4b983a] LZO_jll v2.10.1+0\n  [dd192d2f] LibVPX_jll v1.9.0+1\n  [e9f186c6] Libffi_jll v3.2.2+0\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+0\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.1.0+2\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [856f044c] MKL_jll v2021.1.1+1\n  [e7412a2a] Ogg_jll v1.3.4+2\n  [458c3c95] OpenSSL_jll v1.1.1+6\n  [efe28fd5] OpenSpecFun_jll v0.5.4+0\n  [91d4177d] Opus_jll v1.3.1+3\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.2+0\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.0+1\n  [a2964d1f] Wayland_jll v1.17.0+4\n  [2381bf8a] Wayland_protocols_jll v1.18.0+4\n  [02c8fc9c] XML2_jll v2.9.12+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.2+6\n  [3161d3a3] Zstd_jll v1.5.0+0\n  [0ac62f75] libass_jll v0.14.0+4\n  [f638f0a6] libfdk_aac_jll v0.1.6+4\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.6+6\n  [1270edf5] x264_jll v2020.7.14+2\n  [dfaa095f] x265_jll v3.0.0+3\n  [d8fb68d0] xkbcommon_jll v0.9.1+5\n  [0dad84c5] ArgTools\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [4af54fe1] LazyArtifacts\n  [b27032c2] LibCURL\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions\n  [44cfe95a] Pkg\n  [de0858da] Printf\n  [9abbd945] Profile\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML\n  [a4e569a6] Tar\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll\n  [deac9b47] LibCURL_jll\n  [29816b5a] LibSSH2_jll\n  [c8ffd9c3] MbedTLS_jll\n  [14a3606d] MozillaCACerts_jll\n  [4536629a] OpenBLAS_jll\n  [bea87d4a] SuiteSparse_jll\n  [83775a58] Zlib_jll\n  [8e850ede] nghttp2_jll\n  [3f19e933] p7zip_jll","category":"page"},{"location":"advanced/01-beeler_reuter/#An-Implicit/Explicit-CUDA-Accelerated-Solver-for-the-2D-Beeler-Reuter-Model","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/#Background","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"Background","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"SciML is a suite of optimized Julia libraries to solve ordinary differential equations (ODE). SciML provides a large number of explicit and implicit solvers suited for different types of ODE problems. It is possible to reduce a system of partial differential equations into an ODE problem by employing the method of lines (MOL). The essence of MOL is to discretize the spatial derivatives (by finite difference, finite volume or finite element methods) into algebraic equations and to keep the time derivatives as is. The resulting differential equations are left with only one independent variable (time) and can be solved with an ODE solver. Solving Systems of Stochastic PDEs and using GPUs in Julia is a brief introduction to MOL and using GPUs to accelerate PDE solving in JuliaDiffEq. Here we expand on this introduction by developing an implicit/explicit (IMEX) solver for a 2D cardiac electrophysiology model and show how to use CUDA libraries to run the explicit part of the model on a GPU.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Note that this tutorial does not use the higher order IMEX methods built into DifferentialEquations.jl but instead shows how to hand-split an equation when the explicit portion has an analytical solution (or approxiate), which is common in many scenarios.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"There are hundreds of ionic models that describe cardiac electrical activity in various degrees of detail. Most are based on the classic Hodgkin-Huxley model and define the time-evolution of different state variables in the form of nonlinear first-order ODEs. The state vector for these models includes the transmembrane potential, gating variables, and ionic concentrations. The coupling between cells is through the transmembrame potential only and is described as a reaction-diffusion equation, which is a parabolic PDE,","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"partial V  partial t = nabla (D  nabla V) - frac I_textion C_m","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"where V is the transmembrane potential, D is a diffusion tensor, I_textion is the sum of the transmembrane currents and is calculated from the ODEs, and C_m is the membrane capacitance and is usually assumed to be constant. Here we model a uniform and isotropic medium. Therefore, the model can be simplified to,","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"partial V  partial t = D DeltaV - frac I_textion C_m","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"where D is now a scalar. By nature, these models have to deal with different time scales and are therefore classified as stiff. Commonly, they are solved using the explicit Euler method, usually with a closed form for the integration of the gating variables (the Rush-Larsen method, see below). We can also solve these problems using implicit or semi-implicit PDE solvers (e.g., the Crank-Nicholson method combined with an iterative solver). Higher order explicit methods such as Runge-Kutta and linear multi-step methods cannot overcome the stiffness and are not particularly helpful.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"In this tutorial, we first develop a CPU-only IMEX solver and then show how to move the explicit part to a GPU.","category":"page"},{"location":"advanced/01-beeler_reuter/#The-Beeler-Reuter-Model","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"The Beeler-Reuter Model","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"We have chosen the Beeler-Reuter ventricular ionic model as our example. It is a classic model first described in 1977 and is used as a base for many other ionic models. It has eight state variables, which makes it complicated enough to be interesting without obscuring the main points of the exercise. The eight state variables are: the transmembrane potential (V), sodium-channel activation and inactivation gates (m and h, similar to the Hodgkin-Huxley model), with an additional slow inactivation gate (j), calcium-channel activation and deactivations gates (d and f), a time-dependent inward-rectifying potassium current gate (x_1), and intracellular calcium concentration (c). There are four currents: a sodium current (i_Na), a calcium current (i_Ca), and two potassium currents, one time-dependent (i_x_1) and one background time-independent (i_K_1).","category":"page"},{"location":"advanced/01-beeler_reuter/#CPU-Only-Beeler-Reuter-Solver","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"CPU-Only Beeler-Reuter Solver","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Let's start by developing a CPU only IMEX solver. The main idea is to use the DifferentialEquations framework to handle the implicit part of the equation and code the analytical approximation for explicit part separately. If no analytical approximation was known for the explicit part, one could use methods from this list.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"First, we define the model constants:","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"const v0 = -84.624\nconst v1 = 10.0\nconst C_K1 = 1.0f0\nconst C_x1 = 1.0f0\nconst C_Na = 1.0f0\nconst C_s = 1.0f0\nconst D_Ca = 0.0f0\nconst D_Na = 0.0f0\nconst g_s = 0.09f0\nconst g_Na = 4.0f0\nconst g_NaC = 0.005f0\nconst ENa = 50.0f0 + D_Na\nconst γ = 0.5f0\nconst C_m = 1.0f0","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"1.0f0","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Note that the constants are defined as Float32 and not Float64. The reason is that most GPUs have many more single precision cores than double precision ones. To ensure uniformity between CPU and GPU, we also code most states variables as Float32 except for the transmembrane potential, which is solved by an implicit solver provided by the Sundial library and needs to be Float64.","category":"page"},{"location":"advanced/01-beeler_reuter/#The-State-Structure","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"The State Structure","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Next, we define a struct to contain our state. BeelerReuterCpu is a functor and we will define a deriv function as its associated function.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"mutable struct BeelerReuterCpu <: Function\n    t::Float64              # the last timestep time to calculate Δt\n    diff_coef::Float64      # the diffusion-coefficient (coupling strength)\n\n    C::Array{Float32, 2}    # intracellular calcium concentration\n    M::Array{Float32, 2}    # sodium current activation gate (m)\n    H::Array{Float32, 2}    # sodium current inactivation gate (h)\n    J::Array{Float32, 2}    # sodium current slow inactivaiton gate (j)\n    D::Array{Float32, 2}    # calcium current activaiton gate (d)\n    F::Array{Float32, 2}    # calcium current inactivation gate (f)\n    XI::Array{Float32, 2}   # inward-rectifying potassium current (iK1)\n\n    Δu::Array{Float64, 2}   # place-holder for the Laplacian\n\n    function BeelerReuterCpu(u0, diff_coef)\n        self = new()\n\n        ny, nx = size(u0)\n        self.t = 0.0\n        self.diff_coef = diff_coef\n\n        self.C = fill(0.0001f0, (ny,nx))\n        self.M = fill(0.01f0, (ny,nx))\n        self.H = fill(0.988f0, (ny,nx))\n        self.J = fill(0.975f0, (ny,nx))\n        self.D = fill(0.003f0, (ny,nx))\n        self.F = fill(0.994f0, (ny,nx))\n        self.XI = fill(0.0001f0, (ny,nx))\n\n        self.Δu = zeros(ny,nx)\n\n        return self\n    end\nend","category":"page"},{"location":"advanced/01-beeler_reuter/#Laplacian","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"Laplacian","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"The finite-difference Laplacian is calculated in-place by a 5-point stencil. The Neumann boundary condition is enforced. Note that we could have also used DiffEqOperators.jl to automate this step.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"# 5-point stencil\nfunction laplacian(Δu, u)\n    n1, n2 = size(u)\n\n    # internal nodes\n    for j = 2:n2-1\n        for i = 2:n1-1\n            @inbounds  Δu[i,j] = u[i+1,j] + u[i-1,j] + u[i,j+1] + u[i,j-1] - 4*u[i,j]\n        end\n    end\n\n    # left/right edges\n    for i = 2:n1-1\n        @inbounds Δu[i,1] = u[i+1,1] + u[i-1,1] + 2*u[i,2] - 4*u[i,1]\n        @inbounds Δu[i,n2] = u[i+1,n2] + u[i-1,n2] + 2*u[i,n2-1] - 4*u[i,n2]\n    end\n\n    # top/bottom edges\n    for j = 2:n2-1\n        @inbounds Δu[1,j] = u[1,j+1] + u[1,j-1] + 2*u[2,j] - 4*u[1,j]\n        @inbounds Δu[n1,j] = u[n1,j+1] + u[n1,j-1] + 2*u[n1-1,j] - 4*u[n1,j]\n    end\n\n    # corners\n    @inbounds Δu[1,1] = 2*(u[2,1] + u[1,2]) - 4*u[1,1]\n    @inbounds Δu[n1,1] = 2*(u[n1-1,1] + u[n1,2]) - 4*u[n1,1]\n    @inbounds Δu[1,n2] = 2*(u[2,n2] + u[1,n2-1]) - 4*u[1,n2]\n    @inbounds Δu[n1,n2] = 2*(u[n1-1,n2] + u[n1,n2-1]) - 4*u[n1,n2]\nend","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"laplacian (generic function with 1 method)","category":"page"},{"location":"advanced/01-beeler_reuter/#The-Rush-Larsen-Method","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"The Rush-Larsen Method","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"We use an explicit solver for all the state variables except for the transmembrane potential which is solved with the help of an implicit solver. The explicit solver is a domain-specific exponential method, the Rush-Larsen method. This method utilizes an approximation on the model in order to transform the IMEX equation into a form suitable for an implicit ODE solver. This combination of implicit and explicit methods forms a specialized IMEX solver. For general IMEX integration, please see the IMEX solvers documentation. While we could have used the general model to solve the current problem, for this specific model, the transformation approach is more efficient and is of practical interest.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"The Rush-Larsen method replaces the explicit Euler integration for the gating variables with direct integration. The starting point is the general ODE for the gating variables in Hodgkin-Huxley style ODEs,","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"fracdgdt = alpha(V) (1 - g) - beta(V) g","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"where g is a generic gating variable, ranging from 0 to 1, and alpha and beta are reaction rates. This equation can be written as,","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"fracdgdt = (g_infty - g)  tau_g","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"where g_infty and tau_g are","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"g_infty = fracalpha(alpha + beta)","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"and,","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"tau_g = frac1(alpha + beta)","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Assuing that g_infty and tau_g are constant for the duration of a single time step (Deltat), which is a reasonable assumption for most cardiac models, we can integrate directly to have,","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"g(t + Deltat) = g_infty - left(g_infty - g(Deltat)right)e^-Deltattau_g","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"This is the Rush-Larsen technique. Note that as Deltat rightarrow 0, this equations morphs into the explicit Euler formula,","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"g(t + Deltat) = g(t) + Deltatfracdgdt","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"rush_larsen is a helper function that use the Rush-Larsen method to integrate the gating variables.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"@inline function rush_larsen(g, α, β, Δt)\n    inf = α/(α+β)\n    τ = 1f0 / (α+β)\n    return clamp(g + (g - inf) * expm1(-Δt/τ), 0f0, 1f0)\nend","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"rush_larsen (generic function with 1 method)","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"The gating variables are updated as below. The details of how to calculate alpha and beta are based on the Beeler-Reuter model and not of direct interest to this tutorial.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"function update_M_cpu(g, v, Δt)\n    # the condition is needed here to prevent NaN when v == 47.0\n    α = isapprox(v, 47.0f0) ? 10.0f0 : -(v+47.0f0) / (exp(-0.1f0*(v+47.0f0)) - 1.0f0)\n    β = (40.0f0 * exp(-0.056f0*(v+72.0f0)))\n    return rush_larsen(g, α, β, Δt)\nend\n\nfunction update_H_cpu(g, v, Δt)\n    α = 0.126f0 * exp(-0.25f0*(v+77.0f0))\n    β = 1.7f0 / (exp(-0.082f0*(v+22.5f0)) + 1.0f0)\n   return rush_larsen(g, α, β, Δt)\nend\n\nfunction update_J_cpu(g, v, Δt)\n    α = (0.55f0 * exp(-0.25f0*(v+78.0f0))) / (exp(-0.2f0*(v+78.0f0)) + 1.0f0)\n    β = 0.3f0 / (exp(-0.1f0*(v+32.0f0)) + 1.0f0)\n    return rush_larsen(g, α, β, Δt)\nend\n\nfunction update_D_cpu(g, v, Δt)\n    α = γ * (0.095f0 * exp(-0.01f0*(v-5.0f0))) / (exp(-0.072f0*(v-5.0f0)) + 1.0f0)\n    β = γ * (0.07f0 * exp(-0.017f0*(v+44.0f0))) / (exp(0.05f0*(v+44.0f0)) + 1.0f0)\n    return rush_larsen(g, α, β, Δt)\nend\n\nfunction update_F_cpu(g, v, Δt)\n    α = γ * (0.012f0 * exp(-0.008f0*(v+28.0f0))) / (exp(0.15f0*(v+28.0f0)) + 1.0f0)\n    β = γ * (0.0065f0 * exp(-0.02f0*(v+30.0f0))) / (exp(-0.2f0*(v+30.0f0)) + 1.0f0)\n    return rush_larsen(g, α, β, Δt)\nend\n\nfunction update_XI_cpu(g, v, Δt)\n    α = (0.0005f0 * exp(0.083f0*(v+50.0f0))) / (exp(0.057f0*(v+50.0f0)) + 1.0f0)\n    β = (0.0013f0 * exp(-0.06f0*(v+20.0f0))) / (exp(-0.04f0*(v+20.0f0)) + 1.0f0)\n    return rush_larsen(g, α, β, Δt)\nend","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"update_XI_cpu (generic function with 1 method)","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"The intracelleular calcium is not technically a gating variable, but we can use a similar explicit exponential integrator for it.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"function update_C_cpu(g, d, f, v, Δt)\n    ECa = D_Ca - 82.3f0 - 13.0278f0 * log(g)\n    kCa = C_s * g_s * d * f\n    iCa = kCa * (v - ECa)\n    inf = 1.0f-7 * (0.07f0 - g)\n    τ = 1f0 / 0.07f0\n    return g + (g - inf) * expm1(-Δt/τ)\nend","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"update_C_cpu (generic function with 1 method)","category":"page"},{"location":"advanced/01-beeler_reuter/#Implicit-Solver","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"Implicit Solver","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Now, it is time to define the derivative function as an associated function of BeelerReuterCpu. We plan to use the CVODE_BDF solver as our implicit portion. Similar to other iterative methods, it calls the deriv function with the same t multiple times. For example, these are consecutive ts from a representative run:","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"0.86830 0.86830 0.85485 0.85485 0.85485 0.86359 0.86359 0.86359 0.87233 0.87233 0.87233 0.88598 ...","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Here, every time step is called three times. We distinguish between two types of calls to the deriv function. When t changes, the gating variables are updated by calling update_gates_cpu:","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"function update_gates_cpu(u, XI, M, H, J, D, F, C, Δt)\n    let Δt = Float32(Δt)\n        n1, n2 = size(u)\n        for j = 1:n2\n            for i = 1:n1\n                v = Float32(u[i,j])\n\n                XI[i,j] = update_XI_cpu(XI[i,j], v, Δt)\n                M[i,j] = update_M_cpu(M[i,j], v, Δt)\n                H[i,j] = update_H_cpu(H[i,j], v, Δt)\n                J[i,j] = update_J_cpu(J[i,j], v, Δt)\n                D[i,j] = update_D_cpu(D[i,j], v, Δt)\n                F[i,j] = update_F_cpu(F[i,j], v, Δt)\n\n                C[i,j] = update_C_cpu(C[i,j], D[i,j], F[i,j], v, Δt)\n            end\n        end\n    end\nend","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"update_gates_cpu (generic function with 1 method)","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"On the other hand, du is updated at each time step, since it is independent of Deltat.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"# iK1 is the inward-rectifying potassium current\nfunction calc_iK1(v)\n    ea = exp(0.04f0*(v+85f0))\n    eb = exp(0.08f0*(v+53f0))\n    ec = exp(0.04f0*(v+53f0))\n    ed = exp(-0.04f0*(v+23f0))\n    return 0.35f0 * (4f0*(ea-1f0)/(eb + ec)\n            + 0.2f0 * (isapprox(v, -23f0) ? 25f0 : (v+23f0) / (1f0-ed)))\nend\n\n# ix1 is the time-independent background potassium current\nfunction calc_ix1(v, xi)\n    ea = exp(0.04f0*(v+77f0))\n    eb = exp(0.04f0*(v+35f0))\n    return xi * 0.8f0 * (ea-1f0) / eb\nend\n\n# iNa is the sodium current (similar to the classic Hodgkin-Huxley model)\nfunction calc_iNa(v, m, h, j)\n    return C_Na * (g_Na * m^3 * h * j + g_NaC) * (v - ENa)\nend\n\n# iCa is the calcium current\nfunction calc_iCa(v, d, f, c)\n    ECa = D_Ca - 82.3f0 - 13.0278f0 * log(c)    # ECa is the calcium reversal potential\n    return C_s * g_s * d * f * (v - ECa)\nend\n\nfunction update_du_cpu(du, u, XI, M, H, J, D, F, C)\n    n1, n2 = size(u)\n\n    for j = 1:n2\n        for i = 1:n1\n            v = Float32(u[i,j])\n\n            # calculating individual currents\n            iK1 = calc_iK1(v)\n            ix1 = calc_ix1(v, XI[i,j])\n            iNa = calc_iNa(v, M[i,j], H[i,j], J[i,j])\n            iCa = calc_iCa(v, D[i,j], F[i,j], C[i,j])\n\n            # total current\n            I_sum = iK1 + ix1 + iNa + iCa\n\n            # the reaction part of the reaction-diffusion equation\n            du[i,j] = -I_sum / C_m\n        end\n    end\nend","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"update_du_cpu (generic function with 1 method)","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Finally, we put everything together is our deriv function, which is a call on BeelerReuterCpu.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"function (f::BeelerReuterCpu)(du, u, p, t)\n    Δt = t - f.t\n\n    if Δt != 0 || t == 0\n        update_gates_cpu(u, f.XI, f.M, f.H, f.J, f.D, f.F, f.C, Δt)\n        f.t = t\n    end\n\n    laplacian(f.Δu, u)\n\n    # calculate the reaction portion\n    update_du_cpu(du, u, f.XI, f.M, f.H, f.J, f.D, f.F, f.C)\n\n    # ...add the diffusion portion\n    du .+= f.diff_coef .* f.Δu\nend","category":"page"},{"location":"advanced/01-beeler_reuter/#Results","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"Results","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Time to test! We need to define the starting transmembrane potential with the help of global constants v0 and v1, which represent the resting and activated potentials.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"const N = 192;\nu0 = fill(v0, (N, N));\nu0[90:102,90:102] .= v1;   # a small square in the middle of the domain","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"The initial condition is a small square in the middle of the domain.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"using Plots\nheatmap(u0)","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"(Image: )","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Next, the problem is defined:","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"using DifferentialEquations, Sundials\n\nderiv_cpu = BeelerReuterCpu(u0, 1.0);\nprob = ODEProblem(deriv_cpu, u0, (0.0, 50.0));","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"For stiff reaction-diffusion equations, CVODE_BDF from Sundial library is an excellent solver.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"@time sol = solve(prob, CVODE_BDF(linear_solver=:GMRES), saveat=100.0);","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"30.348145 seconds (1.98 M allocations: 122.833 MiB, 0.10% gc time, 3.29% c\nompilation time)","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"heatmap(sol.u[end])","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"(Image: )","category":"page"},{"location":"advanced/01-beeler_reuter/#CPU/GPU-Beeler-Reuter-Solver","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"CPU/GPU Beeler-Reuter Solver","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"GPUs are great for embarrassingly parallel problems but not so much for highly coupled models. We plan to keep the implicit part on CPU and run the decoupled explicit code on a GPU with the help of the CUDAnative library.","category":"page"},{"location":"advanced/01-beeler_reuter/#GPUs-and-CUDA","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"GPUs and CUDA","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"It this section, we present a brief summary of how GPUs (specifically NVIDIA GPUs) work and how to program them using the Julia CUDA interface. The readers who are familiar with these basic concepts may skip this section.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Let's start by looking at the hardware of a typical high-end GPU, GTX 1080. It has four Graphics Processing Clusters (equivalent to a discrete CPU), each harboring five Streaming Multiprocessor (similar to a CPU core). Each SM has 128 single-precision CUDA cores. Therefore, GTX 1080 has a total of 4 x 5 x 128 = 2560 CUDA cores. The maximum  theoretical throughput for a GTX 1080 is reported as 8.87 TFLOPS. This figure is calculated for a boost clock frequency of 1.733 MHz as 2 x 2560 x 1.733 MHz = 8.87 TFLOPS. The factor 2 is included because two single floating point operations, a multiplication and an addition, can be done in a clock cycle as part of a fused-multiply-addition FMA operation. GTX 1080 also has 8192 MB of global memory accessible to all the cores (in addition to local and shared memory on each SM).","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"A typical CUDA application has the following flow:","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Define and initialize the problem domain tensors (multi-dimensional arrays) in CPU memory.\nAllocate corresponding tensors in the GPU global memory.\nTransfer the input tensors from CPU to the corresponding GPU tensors.\nInvoke CUDA kernels (i.e., the GPU functions callable from CPU) that operate on the GPU tensors.\nTransfer the result tensors from GPU back to CPU.\nProcess tensors on CPU.\nRepeat steps 3-6 as needed.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Some libraries, such as ArrayFire, hide the complexicities of steps 2-5 behind a higher level of abstraction. However, here we take a lower level route. By using CUDA, we achieve a finer-grained control and higher performance. In return, we need to implement each step manually.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"CuArray is a thin abstraction layer over the CUDA API and allows us to define GPU-side tensors and copy data to and from them but does not provide for operations on tensors. CUDAnative is a compiler that translates Julia functions designated as CUDA kernels into ptx (a high-level CUDA assembly language).","category":"page"},{"location":"advanced/01-beeler_reuter/#The-CUDA-Code","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"The CUDA Code","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"The key to fast CUDA programs is to minimize CPU/GPU memory transfers and global memory accesses. The implicit solver is currently CPU only, but it only needs access to the transmembrane potential. The rest of state variables reside on the GPU memory.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"We modify BeelerReuterCpu into BeelerReuterGpu by defining the state variables as CuArrays instead of standard Julia Arrays. The name of each variable defined on GPU is prefixed by d_ for clarity. Note that Deltav is a temporary storage for the Laplacian and stays on the CPU side.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"using CUDA\n\nmutable struct BeelerReuterGpu <: Function\n    t::Float64                  # the last timestep time to calculate Δt\n    diff_coef::Float64          # the diffusion-coefficient (coupling strength)\n\n    d_C::CuArray{Float32, 2}    # intracellular calcium concentration\n    d_M::CuArray{Float32, 2}    # sodium current activation gate (m)\n    d_H::CuArray{Float32, 2}    # sodium current inactivation gate (h)\n    d_J::CuArray{Float32, 2}    # sodium current slow inactivaiton gate (j)\n    d_D::CuArray{Float32, 2}    # calcium current activaiton gate (d)\n    d_F::CuArray{Float32, 2}    # calcium current inactivation gate (f)\n    d_XI::CuArray{Float32, 2}   # inward-rectifying potassium current (iK1)\n\n    d_u::CuArray{Float64, 2}    # place-holder for u in the device memory\n    d_du::CuArray{Float64, 2}   # place-holder for d_u in the device memory\n\n    Δv::Array{Float64, 2}       # place-holder for voltage gradient\n\n    function BeelerReuterGpu(u0, diff_coef)\n        self = new()\n\n        ny, nx = size(u0)\n        @assert (nx % 16 == 0) && (ny % 16 == 0)\n        self.t = 0.0\n        self.diff_coef = diff_coef\n\n        self.d_C = CuArray(fill(0.0001f0, (ny,nx)))\n        self.d_M = CuArray(fill(0.01f0, (ny,nx)))\n        self.d_H = CuArray(fill(0.988f0, (ny,nx)))\n        self.d_J = CuArray(fill(0.975f0, (ny,nx)))\n        self.d_D = CuArray(fill(0.003f0, (ny,nx)))\n        self.d_F = CuArray(fill(0.994f0, (ny,nx)))\n        self.d_XI = CuArray(fill(0.0001f0, (ny,nx)))\n\n        self.d_u = CuArray(u0)\n        self.d_du = CuArray(zeros(ny,nx))\n\n        self.Δv = zeros(ny,nx)\n\n        return self\n    end\nend","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"The Laplacian function remains unchanged. The main change to the explicit gating solvers is that exp and expm1 functions are prefixed by CUDAnative.. This is a technical nuisance that will hopefully be resolved in future.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"function rush_larsen_gpu(g, α, β, Δt)\n    inf = α/(α+β)\n    τ = 1.0/(α+β)\n    return clamp(g + (g - inf) * CUDAnative.expm1(-Δt/τ), 0f0, 1f0)\nend\n\nfunction update_M_gpu(g, v, Δt)\n    # the condition is needed here to prevent NaN when v == 47.0\n    α = isapprox(v, 47.0f0) ? 10.0f0 : -(v+47.0f0) / (CUDAnative.exp(-0.1f0*(v+47.0f0)) - 1.0f0)\n    β = (40.0f0 * CUDAnative.exp(-0.056f0*(v+72.0f0)))\n    return rush_larsen_gpu(g, α, β, Δt)\nend\n\nfunction update_H_gpu(g, v, Δt)\n    α = 0.126f0 * CUDAnative.exp(-0.25f0*(v+77.0f0))\n    β = 1.7f0 / (CUDAnative.exp(-0.082f0*(v+22.5f0)) + 1.0f0)\n    return rush_larsen_gpu(g, α, β, Δt)\nend\n\nfunction update_J_gpu(g, v, Δt)\n    α = (0.55f0 * CUDAnative.exp(-0.25f0*(v+78.0f0))) / (CUDAnative.exp(-0.2f0*(v+78.0f0)) + 1.0f0)\n    β = 0.3f0 / (CUDAnative.exp(-0.1f0*(v+32.0f0)) + 1.0f0)\n    return rush_larsen_gpu(g, α, β, Δt)\nend\n\nfunction update_D_gpu(g, v, Δt)\n    α = γ * (0.095f0 * CUDAnative.exp(-0.01f0*(v-5.0f0))) / (CUDAnative.exp(-0.072f0*(v-5.0f0)) + 1.0f0)\n    β = γ * (0.07f0 * CUDAnative.exp(-0.017f0*(v+44.0f0))) / (CUDAnative.exp(0.05f0*(v+44.0f0)) + 1.0f0)\n    return rush_larsen_gpu(g, α, β, Δt)\nend\n\nfunction update_F_gpu(g, v, Δt)\n    α = γ * (0.012f0 * CUDAnative.exp(-0.008f0*(v+28.0f0))) / (CUDAnative.exp(0.15f0*(v+28.0f0)) + 1.0f0)\n    β = γ * (0.0065f0 * CUDAnative.exp(-0.02f0*(v+30.0f0))) / (CUDAnative.exp(-0.2f0*(v+30.0f0)) + 1.0f0)\n    return rush_larsen_gpu(g, α, β, Δt)\nend\n\nfunction update_XI_gpu(g, v, Δt)\n    α = (0.0005f0 * CUDAnative.exp(0.083f0*(v+50.0f0))) / (CUDAnative.exp(0.057f0*(v+50.0f0)) + 1.0f0)\n    β = (0.0013f0 * CUDAnative.exp(-0.06f0*(v+20.0f0))) / (CUDAnative.exp(-0.04f0*(v+20.0f0)) + 1.0f0)\n    return rush_larsen_gpu(g, α, β, Δt)\nend\n\nfunction update_C_gpu(c, d, f, v, Δt)\n    ECa = D_Ca - 82.3f0 - 13.0278f0 * CUDAnative.log(c)\n    kCa = C_s * g_s * d * f\n    iCa = kCa * (v - ECa)\n    inf = 1.0f-7 * (0.07f0 - c)\n    τ = 1f0 / 0.07f0\n    return c + (c - inf) * CUDAnative.expm1(-Δt/τ)\nend","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"update_C_gpu (generic function with 1 method)","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Similarly, we modify the functions to calculate the individual currents by adding CUDAnative prefix.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"# iK1 is the inward-rectifying potassium current\nfunction calc_iK1(v)\n    ea = CUDAnative.exp(0.04f0*(v+85f0))\n    eb = CUDAnative.exp(0.08f0*(v+53f0))\n    ec = CUDAnative.exp(0.04f0*(v+53f0))\n    ed = CUDAnative.exp(-0.04f0*(v+23f0))\n    return 0.35f0 * (4f0*(ea-1f0)/(eb + ec)\n            + 0.2f0 * (isapprox(v, -23f0) ? 25f0 : (v+23f0) / (1f0-ed)))\nend\n\n# ix1 is the time-independent background potassium current\nfunction calc_ix1(v, xi)\n    ea = CUDAnative.exp(0.04f0*(v+77f0))\n    eb = CUDAnative.exp(0.04f0*(v+35f0))\n    return xi * 0.8f0 * (ea-1f0) / eb\nend\n\n# iNa is the sodium current (similar to the classic Hodgkin-Huxley model)\nfunction calc_iNa(v, m, h, j)\n    return C_Na * (g_Na * m^3 * h * j + g_NaC) * (v - ENa)\nend\n\n# iCa is the calcium current\nfunction calc_iCa(v, d, f, c)\n    ECa = D_Ca - 82.3f0 - 13.0278f0 * CUDAnative.log(c)    # ECa is the calcium reversal potential\n    return C_s * g_s * d * f * (v - ECa)\nend","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"calc_iCa (generic function with 1 method)","category":"page"},{"location":"advanced/01-beeler_reuter/#CUDA-Kernels","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"CUDA Kernels","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"A CUDA program does not directly deal with GPCs and SMs. The logical view of a CUDA program is in the term of blocks and threads. We have to specify the number of block and threads when running a CUDA kernel. Each thread runs on a single CUDA core. Threads are logically bundled into blocks, which are in turn specified on a grid. The grid stands for the entirety of the domain of interest.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Each thread can find its logical coordinate by using few pre-defined indexing variables (threadIdx, blockIdx, blockDim and gridDim) in C/C++ and the corresponding functions (e.g., threadIdx()) in Julia. There variables and functions are defined automatically for each thread and may return a different value depending on the calling thread. The return value of these functions is a 1, 2, or 3 dimensional structure whose elements can be accessed as .x, .y, and .z (for a 1-dimensional case, .x reports the actual index and .y and .z simply return 1). For example, if we deploy a kernel in 128 blocks and with 256 threads per block, each thread will see","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"    gridDim.x = 128;\n    blockDim=256;","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"while blockIdx.x ranges from 0 to 127 in C/C++ and 1 to 128 in Julia. Similarly, threadIdx.x will be between 0 to 255 in C/C++ (of course, in Julia the range will be 1 to 256).","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"A C/C++ thread can calculate its index as","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"    int idx = blockDim.x * blockIdx.x + threadIdx.x;","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"In Julia, we have to take into account base 1. Therefore, we use the following formula","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"    idx = (blockIdx().x-UInt32(1)) * blockDim().x + threadIdx().x","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"A CUDA programmer is free to interpret the calculated index however it fits the application, but in practice, it is usually interpreted as an index into input tensors.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"In the GPU version of the solver, each thread works on a single element of the medium, indexed by a (x,y) pair. update_gates_gpu and update_du_gpu are very similar to their CPU counterparts but are in fact CUDA kernels where the for loops are replaced with CUDA specific indexing. Note that CUDA kernels cannot return a valve; hence, nothing at the end.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"function update_gates_gpu(u, XI, M, H, J, D, F, C, Δt)\n    i = (blockIdx().x-UInt32(1)) * blockDim().x + threadIdx().x\n    j = (blockIdx().y-UInt32(1)) * blockDim().y + threadIdx().y\n\n    v = Float32(u[i,j])\n\n    let Δt = Float32(Δt)\n        XI[i,j] = update_XI_gpu(XI[i,j], v, Δt)\n        M[i,j] = update_M_gpu(M[i,j], v, Δt)\n        H[i,j] = update_H_gpu(H[i,j], v, Δt)\n        J[i,j] = update_J_gpu(J[i,j], v, Δt)\n        D[i,j] = update_D_gpu(D[i,j], v, Δt)\n        F[i,j] = update_F_gpu(F[i,j], v, Δt)\n\n        C[i,j] = update_C_gpu(C[i,j], D[i,j], F[i,j], v, Δt)\n    end\n    nothing\nend\n\nfunction update_du_gpu(du, u, XI, M, H, J, D, F, C)\n    i = (blockIdx().x-UInt32(1)) * blockDim().x + threadIdx().x\n    j = (blockIdx().y-UInt32(1)) * blockDim().y + threadIdx().y\n\n    v = Float32(u[i,j])\n\n    # calculating individual currents\n    iK1 = calc_iK1(v)\n    ix1 = calc_ix1(v, XI[i,j])\n    iNa = calc_iNa(v, M[i,j], H[i,j], J[i,j])\n    iCa = calc_iCa(v, D[i,j], F[i,j], C[i,j])\n\n    # total current\n    I_sum = iK1 + ix1 + iNa + iCa\n\n    # the reaction part of the reaction-diffusion equation\n    du[i,j] = -I_sum / C_m\n    nothing\nend","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"update_du_gpu (generic function with 1 method)","category":"page"},{"location":"advanced/01-beeler_reuter/#Implicit-Solver-2","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"Implicit Solver","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Finally, the deriv function is modified to copy u to GPU and copy du back and to invoke CUDA kernels.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"function (f::BeelerReuterGpu)(du, u, p, t)\n    L = 16   # block size\n    Δt = t - f.t\n    copyto!(f.d_u, u)\n    ny, nx = size(u)\n\n    if Δt != 0 || t == 0\n        @cuda blocks=(ny÷L,nx÷L) threads=(L,L) update_gates_gpu(\n            f.d_u, f.d_XI, f.d_M, f.d_H, f.d_J, f.d_D, f.d_F, f.d_C, Δt)\n        f.t = t\n    end\n\n    laplacian(f.Δv, u)\n\n    # calculate the reaction portion\n    @cuda blocks=(ny÷L,nx÷L) threads=(L,L) update_du_gpu(\n        f.d_du, f.d_u, f.d_XI, f.d_M, f.d_H, f.d_J, f.d_D, f.d_F, f.d_C)\n\n    copyto!(du, f.d_du)\n\n    # ...add the diffusion portion\n    du .+= f.diff_coef .* f.Δv\nend","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Ready to test!","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"using DifferentialEquations, Sundials\n\nderiv_gpu = BeelerReuterGpu(u0, 1.0);\nprob = ODEProblem(deriv_gpu, u0, (0.0, 50.0));\n@time sol = solve(prob, CVODE_BDF(linear_solver=:GMRES), saveat=100.0);","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Error: CUDA.jl did not successfully initialize, and is not usable.\nIf you did not see any other error message, try again in a new session\nwith the JULIA_DEBUG environment variable set to 'CUDA'.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"heatmap(sol.u[end])","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"(Image: )","category":"page"},{"location":"advanced/01-beeler_reuter/#Summary","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"Summary","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"We achieve around a 6x speedup with running the explicit portion of our IMEX solver on a GPU. The major bottleneck of this technique is the communication between CPU and GPU. In its current form, not all of the internals of the method utilize GPU acceleration. In particular, the implicit equations solved by GMRES are performed on the CPU. This partial CPU nature also increases the amount of data transfer that is required between the GPU and CPU (performed every f call). Compiling the full ODE solver to the GPU would solve both of these issues and potentially give a much larger speedup. JuliaDiffEq developers are currently working on solutions to alleviate these issues, but these will only be compatible with native Julia solvers (and not Sundials).","category":"page"},{"location":"advanced/01-beeler_reuter/#Appendix","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"Appendix","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"tutorials/advanced\",\"01-beeler_reuter.jmd\")","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Computer Information:","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Julia Version 1.6.2\nCommit 1b93d53fc4 (2021-07-14 15:36 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, znver2)\nEnvironment:\n  JULIA_DEPOT_PATH = /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n  JULIA_NUM_THREADS = 16\n","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Package Information:","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"      Status `/var/lib/buildkite-agent/builds/8-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/advanced/Project.toml`\n  [2169fc97] AlgebraicMultigrid v0.4.0\n  [6e4b80f9] BenchmarkTools v1.0.0\n  [052768ef] CUDA v2.6.3\n  [2b5f629d] DiffEqBase v6.62.2\n  [9fdde737] DiffEqOperators v4.26.0\n  [0c46a032] DifferentialEquations v6.17.1\n  [587475ba] Flux v0.12.1\n  [961ee093] ModelingToolkit v5.17.3\n  [2774e3e8] NLsolve v4.5.1\n  [315f7962] NeuralPDE v3.10.1\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [91a5bcdd] Plots v1.15.2\n  [0bca4576] SciMLBase v1.13.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [47a9eef4] SparseDiffTools v1.13.2\n  [684fba80] SparsityDetection v0.3.4\n  [789caeaf] StochasticDiffEq v6.34.1\n  [c3572dad] Sundials v4.4.3\n  [37e2e46d] LinearAlgebra\n  [2f01184e] SparseArrays","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"And the full manifest:","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"      Status `/var/lib/buildkite-agent/builds/8-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/advanced/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.16.0\n  [621f4979] AbstractFFTs v1.0.1\n  [1520ce14] AbstractTrees v0.3.4\n  [79e6a3ab] Adapt v3.3.0\n  [2169fc97] AlgebraicMultigrid v0.4.0\n  [ec485272] ArnoldiMethod v0.1.0\n  [4fba245c] ArrayInterface v3.1.15\n  [4c555306] ArrayLayouts v0.7.0\n  [13072b0f] AxisAlgorithms v1.0.0\n  [ab4f0b2a] BFloat16s v0.1.0\n  [aae01518] BandedMatrices v0.16.9\n  [6e4b80f9] BenchmarkTools v1.0.0\n  [8e7c35d0] BlockArrays v0.15.3\n  [ffab5731] BlockBandedMatrices v0.10.6\n  [764a87c0] BoundaryValueDiffEq v2.7.1\n  [fa961155] CEnum v0.4.1\n  [00ebfdb7] CSTParser v2.5.0\n  [052768ef] CUDA v2.6.3\n  [7057c7e9] Cassette v0.3.6\n  [082447d4] ChainRules v0.7.65\n  [d360d2e6] ChainRulesCore v0.9.44\n  [b630d9fa] CheapThreads v0.2.5\n  [944b1d66] CodecZlib v0.7.0\n  [35d6a980] ColorSchemes v3.12.1\n  [3da002f7] ColorTypes v0.11.0\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [a80b9123] CommonMark v0.8.1\n  [38540f10] CommonSolve v0.2.0\n  [bbf7d656] CommonSubexpressions v0.3.0\n  [34da2185] Compat v3.30.0\n  [aa819f21] CompatHelper v1.18.6\n  [8f4d0f93] Conda v1.5.2\n  [88cd18e8] ConsoleProgressMonitor v0.1.2\n  [187b0558] ConstructionBase v1.2.1\n  [d38c429a] Contour v0.5.7\n  [a8cc5b0e] Crayons v4.0.4\n  [8a292aeb] Cuba v2.2.0\n  [667455a9] Cubature v1.5.1\n  [9a962f9c] DataAPI v1.6.0\n  [82cc6244] DataInterpolations v3.3.1\n  [864edb3b] DataStructures v0.18.9\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [bcd4f6db] DelayDiffEq v5.31.0\n  [2b5f629d] DiffEqBase v6.62.2\n  [459566f4] DiffEqCallbacks v2.16.1\n  [5a0ffddc] DiffEqFinancial v2.4.0\n  [aae7a2af] DiffEqFlux v1.37.0\n  [c894b116] DiffEqJump v6.14.2\n  [77a26b50] DiffEqNoiseProcess v5.7.3\n  [9fdde737] DiffEqOperators v4.26.0\n  [055956cb] DiffEqPhysics v3.9.0\n  [41bf760c] DiffEqSensitivity v6.45.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.0.2\n  [0c46a032] DifferentialEquations v6.17.1\n  [c619ae07] DimensionalPlotRecipes v1.2.0\n  [b4f34e82] Distances v0.10.3\n  [31c24e10] Distributions v0.24.18\n  [ced4e74d] DistributionsAD v0.6.26\n  [ffbed154] DocStringExtensions v0.8.4\n  [e30172f5] Documenter v0.26.3\n  [d4d017d3] ExponentialUtilities v1.8.4\n  [e2ba6199] ExprTools v0.1.3\n  [8f5d6c58] EzXML v1.1.0\n  [c87230d0] FFMPEG v0.4.0\n  [7a1cc6ca] FFTW v1.4.1\n  [7034ab61] FastBroadcast v0.1.8\n  [9aa1b823] FastClosures v0.3.2\n  [1a297f60] FillArrays v0.11.7\n  [6a86dc24] FiniteDiff v2.8.0\n  [53c48c17] FixedPointNumbers v0.8.4\n  [587475ba] Flux v0.12.1\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.18\n  [069b7b12] FunctionWrappers v1.1.2\n  [d9f16b24] Functors v0.2.1\n  [0c68f7d7] GPUArrays v6.4.1\n  [61eb1bfa] GPUCompiler v0.10.0\n  [28b8d3ca] GR v0.57.4\n  [a75be94c] GalacticOptim v1.2.0\n  [5c1252a2] GeometryBasics v0.3.12\n  [bc5e4493] GitHub v5.4.0\n  [af5da776] GlobalSensitivity v1.0.0\n  [42e2da0e] Grisu v1.0.2\n  [19dc6840] HCubature v1.5.0\n  [cd3eb016] HTTP v0.9.9\n  [eafb193a] Highlights v0.4.5\n  [0e44f5e4] Hwloc v2.0.0\n  [7073ff75] IJulia v1.23.2\n  [b5f81e59] IOCapture v0.1.1\n  [7869d1d1] IRTools v0.4.2\n  [615f187c] IfElse v0.1.0\n  [d25df0c9] Inflate v0.1.2\n  [83e8ac13] IniFile v0.5.0\n  [a98d9a8b] Interpolations v0.13.2\n  [c8e1da08] IterTools v1.3.0\n  [42fd0dbc] IterativeSolvers v0.9.1\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.3.0\n  [682c06a0] JSON v0.21.1\n  [98e50ef6] JuliaFormatter v0.13.7\n  [e5e0dc1b] Juno v0.8.4\n  [5ab0869b] KernelDensity v0.6.3\n  [929cbde3] LLVM v3.7.1\n  [b964fa9f] LaTeXStrings v1.2.1\n  [2ee39098] LabelledArrays v1.6.1\n  [23fbe1c1] Latexify v0.15.5\n  [a5e1c1ea] LatinHypercubeSampling v1.8.0\n  [73f95e8e] LatticeRules v0.0.1\n  [5078a376] LazyArrays v0.21.4\n  [d7e5e226] LazyBandedMatrices v0.5.7\n  [1d6d02ad] LeftChildRightSiblingTrees v0.1.2\n  [093fc24a] LightGraphs v1.3.5\n  [d3d80556] LineSearches v7.1.1\n  [2ab3a3ac] LogExpFunctions v0.2.4\n  [e6f89c97] LoggingExtras v0.4.6\n  [bdcacae8] LoopVectorization v0.12.23\n  [1914dd2f] MacroTools v0.5.6\n  [a3b82374] MatrixFactorizations v0.8.3\n  [739be429] MbedTLS v1.0.3\n  [442fdcdd] Measures v0.3.1\n  [e89f7d12] Media v0.5.0\n  [c03570c3] Memoize v0.4.4\n  [e1d29d7a] Missings v1.0.0\n  [78c3b35d] Mocking v0.7.1\n  [961ee093] ModelingToolkit v5.17.3\n  [4886b29c] MonteCarloIntegration v0.0.2\n  [46d2c3a1] MuladdMacro v0.2.2\n  [f9640e96] MultiScaleArrays v1.8.1\n  [ffc61752] Mustache v1.0.10\n  [d41bc354] NLSolversBase v7.8.0\n  [2774e3e8] NLsolve v4.5.1\n  [872c559c] NNlib v0.7.19\n  [77ba4419] NaNMath v0.3.5\n  [315f7962] NeuralPDE v3.10.1\n  [8913a72c] NonlinearSolve v0.3.8\n  [6fe1bfb0] OffsetArrays v1.9.0\n  [429524aa] Optim v1.3.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [90014a1f] PDMats v0.11.0\n  [65888b18] ParameterizedFunctions v5.10.0\n  [d96e819e] Parameters v0.12.2\n  [69de0a69] Parsers v1.1.0\n  [ccf2f8ad] PlotThemes v2.0.1\n  [995b91a9] PlotUtils v1.0.10\n  [91a5bcdd] Plots v1.15.2\n  [e409e4f3] PoissonRandom v0.4.0\n  [f517fe37] Polyester v0.3.1\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [21216c6a] Preferences v1.2.2\n  [33c8b6b6] ProgressLogging v0.1.4\n  [92933f4c] ProgressMeter v1.6.2\n  [1fd47b50] QuadGK v2.4.1\n  [67601950] Quadrature v1.8.1\n  [8a4e6c94] QuasiMonteCarlo v0.2.2\n  [74087812] Random123 v1.3.1\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.4.0\n  [c84ed2f1] Ratios v0.4.0\n  [3cdcf5f2] RecipesBase v1.1.1\n  [01d81517] RecipesPipeline v0.3.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [f2c3362d] RecursiveFactorization v0.1.12\n  [189a3867] Reexport v1.0.0\n  [ae029012] Requires v1.1.3\n  [ae5879a3] ResettableStacks v1.1.0\n  [37e2e3b7] ReverseDiff v1.9.0\n  [79098fc4] Rmath v0.7.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.2\n  [476501e8] SLEEFPirates v0.6.20\n  [1bc83da4] SafeTestsets v0.0.1\n  [0bca4576] SciMLBase v1.13.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [6c6a2e73] Scratch v1.0.3\n  [efcf1570] Setfield v0.7.0\n  [992d4aef] Showoff v1.0.3\n  [699a6c99] SimpleTraits v0.9.3\n  [ed01d8cd] Sobol v1.5.0\n  [2133526b] SodiumSeal v0.1.1\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.0\n  [47a9eef4] SparseDiffTools v1.13.2\n  [684fba80] SparsityDetection v0.3.4\n  [276daf66] SpecialFunctions v1.4.1\n  [860ef19b] StableRNGs v1.0.0\n  [aedffcd0] Static v0.2.4\n  [90137ffa] StaticArrays v1.2.0\n  [82ae8749] StatsAPI v1.0.0\n  [2913bbd2] StatsBase v0.33.8\n  [4c63d2b9] StatsFuns v0.9.8\n  [9672c7b4] SteadyStateDiffEq v1.6.2\n  [789caeaf] StochasticDiffEq v6.34.1\n  [7792a7ef] StrideArraysCore v0.1.11\n  [09ab397b] StructArrays v0.5.1\n  [c3572dad] Sundials v4.4.3\n  [d1185830] SymbolicUtils v0.11.2\n  [0c5d862f] Symbolics v0.1.25\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.4.2\n  [5d786b92] TerminalLoggers v0.1.3\n  [8290d209] ThreadingUtilities v0.4.4\n  [f269a46b] TimeZones v1.5.5\n  [a759f4b9] TimerOutputs v0.5.9\n  [0796e94c] Tokenize v0.5.16\n  [9f7883ad] Tracker v0.2.16\n  [3bb67fe8] TranscodingStreams v0.9.5\n  [592b5752] Trapz v2.0.2\n  [a2a6695c] TreeViews v0.3.0\n  [5c2747f8] URIs v1.3.0\n  [3a884ed6] UnPack v1.0.2\n  [1986cc42] Unitful v1.7.0\n  [3d5dd08c] VectorizationBase v0.20.11\n  [81def892] VersionParsing v1.2.0\n  [19fa3120] VertexSafeGraphs v0.1.2\n  [44d3d7a6] Weave v0.10.8\n  [efce3f68] WoodburyMatrices v0.5.3\n  [ddb6d928] YAML v0.4.6\n  [c2297ded] ZMQ v1.2.1\n  [a5390f91] ZipFile v0.9.3\n  [e88e6eb3] Zygote v0.6.11\n  [700de1a5] ZygoteRules v0.2.1\n  [6e34b625] Bzip2_jll v1.0.6+5\n  [83423d85] Cairo_jll v1.16.0+6\n  [3bed1096] Cuba_jll v4.2.1+0\n  [7bc98958] Cubature_jll v1.0.4+0\n  [5ae413db] EarCut_jll v2.1.5+1\n  [2e619515] Expat_jll v2.2.10+0\n  [b22a6f82] FFMPEG_jll v4.3.1+4\n  [f5851436] FFTW_jll v3.3.9+7\n  [a3f928ae] Fontconfig_jll v2.13.1+14\n  [d7e528f0] FreeType2_jll v2.10.1+5\n  [559328eb] FriBidi_jll v1.0.5+6\n  [0656b61e] GLFW_jll v3.3.4+0\n  [d2c73de3] GR_jll v0.57.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.1+0\n  [e33a78d0] Hwloc_jll v2.4.1+0\n  [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2\n  [aacddb02] JpegTurbo_jll v2.0.1+3\n  [c1c5ebd0] LAME_jll v3.100.0+3\n  [dd4b983a] LZO_jll v2.10.1+0\n  [dd192d2f] LibVPX_jll v1.9.0+1\n  [e9f186c6] Libffi_jll v3.2.2+0\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+0\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.1.0+2\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [856f044c] MKL_jll v2021.1.1+1\n  [e7412a2a] Ogg_jll v1.3.4+2\n  [458c3c95] OpenSSL_jll v1.1.1+6\n  [efe28fd5] OpenSpecFun_jll v0.5.4+0\n  [91d4177d] Opus_jll v1.3.1+3\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.2+0\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.0+1\n  [a2964d1f] Wayland_jll v1.17.0+4\n  [2381bf8a] Wayland_protocols_jll v1.18.0+4\n  [02c8fc9c] XML2_jll v2.9.12+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.2+6\n  [3161d3a3] Zstd_jll v1.5.0+0\n  [0ac62f75] libass_jll v0.14.0+4\n  [f638f0a6] libfdk_aac_jll v0.1.6+4\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.6+6\n  [1270edf5] x264_jll v2020.7.14+2\n  [dfaa095f] x265_jll v3.0.0+3\n  [d8fb68d0] xkbcommon_jll v0.9.1+5\n  [0dad84c5] ArgTools\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [4af54fe1] LazyArtifacts\n  [b27032c2] LibCURL\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions\n  [44cfe95a] Pkg\n  [de0858da] Printf\n  [9abbd945] Profile\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML\n  [a4e569a6] Tar\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll\n  [deac9b47] LibCURL_jll\n  [29816b5a] LibSSH2_jll\n  [c8ffd9c3] MbedTLS_jll\n  [14a3606d] MozillaCACerts_jll\n  [4536629a] OpenBLAS_jll\n  [bea87d4a] SuiteSparse_jll\n  [83775a58] Zlib_jll\n  [8e850ede] nghttp2_jll\n  [3f19e933] p7zip_jll","category":"page"},{"location":"jumps/spatial/#Ilin","page":"Ilin","title":"Ilin","text":"","category":"section"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"This tutorial shows how to use spatial solvers added to DiffEqJump in summer 2021. See the documentation for a tutorial on getting started with DiffEqJump.","category":"page"},{"location":"jumps/spatial/#Installing-DiffEqJump","page":"Ilin","title":"Installing DiffEqJump","text":"","category":"section"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"Once in REPL, do ] add DiffEqJump. After the installation finishes, you will be able to use all the functionality described below.","category":"page"},{"location":"jumps/spatial/#Reversible-binding-model-on-a-grid","page":"Ilin","title":"Reversible binding model on a grid","text":"","category":"section"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"A 5 by 5 Cartesian grid:","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"<!– –> <!– –> <!– –> <!– –> <!– –>\n. . . . B\n. . . . .\n. . . . .\n. . . . .\nA . . . .","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"Suppose we have a reversible binding system described by A+B to C at rate k_1 and C to A+B at rate k_2. Further suppose that all A molecules start in the lower left corner, while all B molecules start in the upper right corner of a 5 by 5 grid. There are no C molecules at the start.","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"We first create the grid:","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"using DiffEqJump\ndims = (5,5)\nnum_nodes = prod(dims) # number of sites\ngrid = CartesianGrid(dims) # or use LightGraphs.grid(dims)","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"A Cartesian grid with dimensions (5, 5)","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"Now we set the initial state of the simulation. It has to be a matrix with entry (si) being the number of species s at site i (with the standard column-major ordering of the grid).","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"num_species = 3\nstarting_state = zeros(Int, num_species, num_nodes)\nstarting_state[1,1] = 25\nstarting_state[2,end] = 25\nstarting_state","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"3×25 Matrix{Int64}:\n 25  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0   \n0\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  2\n5\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0   \n0","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"We now set the time-span of the simulation and the reaction rates. These can be chosen arbitrarily.","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"tspan = (0.0, 3.0)\nrates = [6.0, 0.05] # k_1 = rates[1], k_2 = rates[2]","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"2-element Vector{Float64}:\n 6.0\n 0.05","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"Now we can create the DiscreteProblem:","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"prob = DiscreteProblem(starting_state, tspan, rates)","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"DiscreteProblem with uType Matrix{Int64} and tType Float64. In-place: true\ntimespan: (0.0, 3.0)\nu0: 3×25 Matrix{Int64}:\n 25  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0   \n0\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  2\n5\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0   \n0","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"Since both reactions are massaction reactions, we put them together in a MassActionJump. In order to do that we create two stoichiometry vectors. The net stoichiometry vector describes which molecules change in number and how much after each reaction; for example, [1 => -1] is the first molecule disappearing. The reaction stoichiometry vector describes what the reactants of each reaction are; for example, [1 => 1, 2 => 1] would mean that the reactants are one molecule of type 1 and one molecule of type 2.","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"netstoch = [[1 => -1, 2 => -1, 3 => 1],[1 => 1, 2 => 1, 3 => -1]]\nreactstoch = [[1 => 1, 2 => 1],[3 => 1]]\nmajumps = MassActionJump(rates, reactstoch, netstoch)","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"DiffEqJump.MassActionJump{Vector{Float64}, Vector{Vector{Pair{Int64, Int64}\n}}, Vector{Vector{Pair{Int64, Int64}}}, Nothing}([6.0, 0.05], [[1 => 1, 2 =\n> 1], [3 => 1]], [[1 => -1, 2 => -1, 3 => 1], [1 => 1, 2 => 1, 3 => -1]], n\nothing)","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"The last thing to set up is the hopping constants – the probability per time of an individual molecule of each species hopping from one site to another site. In practice this parameter, as well as reaction rates, are obtained empirically. Suppose that molecule C cannot diffuse, while molecules A and B diffuse at probability per time 1 (i.e. the time of the diffusive hop is exponentially distributed with mean 1). Entry (si) of hopping_constants is the hopping rate of species s at site i to any of its neighboring sites (diagonal hops are not allowed). ","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"hopping_constants = ones(num_species, num_nodes)\nhopping_constants[3, :] .= 0.0\nhopping_constants","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"3×25 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  …  1.0  1.0  1.0  1.0  1.0  1.0  1\n.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1\n.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0\n.0","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"We are now ready to set up the JumpProblem with the Next Subvolume Method. ","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"alg = NSM()\njump_prob = JumpProblem(prob, alg, majumps, hopping_constants=hopping_constants, spatial_system = grid, save_positions=(true, false))","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"Number of constant rate jumps: 0\nNumber of variable rate jumps: 0\nHave a mass action jump","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"The save_positions keyword tells the solver to save the positions just before the jumps. To solve the jump problem do","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"solution = solve(jump_prob, SSAStepper())","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"retcode: Default\nInterpolation: Piecewise constant interpolation\nt: 401-element Vector{Float64}:\n 0.0\n 0.01805156477589096\n 0.021927208873289517\n 0.025769109693334135\n 0.03515984244149274\n 0.041941982193058974\n 0.052156972679011\n 0.07268000778197724\n 0.08516521051878839\n 0.09139750379283877\n ⋮\n 2.959136931928465\n 2.9646237117842693\n 2.9651086896415113\n 2.9728489281258383\n 2.9739124562005443\n 2.9757635813669086\n 2.9813576277964904\n 2.994984074931063\n 3.0\nu: 401-element Vector{Matrix{Int64}}:\n [25 0 … 0 0; 0 0 … 0 25; 0 0 … 0 0]\n [24 1 … 0 0; 0 0 … 0 25; 0 0 … 0 0]\n [24 0 … 0 0; 0 0 … 0 25; 0 0 … 0 0]\n [24 0 … 0 0; 0 0 … 0 24; 0 0 … 0 0]\n [24 0 … 0 0; 0 0 … 0 23; 0 0 … 0 0]\n [24 0 … 0 0; 0 0 … 0 22; 0 0 … 0 0]\n [23 1 … 0 0; 0 0 … 0 22; 0 0 … 0 0]\n [22 2 … 0 0; 0 0 … 0 22; 0 0 … 0 0]\n [22 2 … 0 0; 0 0 … 0 23; 0 0 … 0 0]\n [21 2 … 0 0; 0 0 … 0 23; 0 0 … 0 0]\n ⋮\n [1 4 … 0 0; 0 0 … 1 0; 0 0 … 0 0]\n [1 4 … 0 0; 0 0 … 1 0; 0 0 … 0 0]\n [2 3 … 0 0; 0 0 … 1 0; 0 0 … 0 0]\n [2 3 … 0 0; 0 0 … 2 0; 0 0 … 0 0]\n [2 3 … 0 0; 0 0 … 2 0; 0 0 … 0 0]\n [2 3 … 0 0; 0 0 … 2 0; 0 0 … 0 0]\n [2 3 … 0 0; 0 0 … 2 1; 0 0 … 0 0]\n [2 2 … 0 0; 0 0 … 2 1; 0 0 … 0 0]\n [2 2 … 0 0; 0 0 … 2 1; 0 0 … 0 0]","category":"page"},{"location":"jumps/spatial/#Animation","page":"Ilin","title":"Animation","text":"","category":"section"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"Visualizing solutions of spatial jump problems is best done with animations.","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"using Plots\nis_static(spec) = (spec == 3) # true if spec does not hop\n\"get frame k\"\nfunction get_frame(k, sol, linear_size, labels, title)\n    num_species = length(labels)\n    h = 1/linear_size\n    t = sol.t[k]\n    state = sol.u[k]\n    xlim=(0,1+3h/2); ylim=(0,1+3h/2);\n    plt = plot(xlim=xlim, ylim=ylim, title = \"$title, $(round(t, sigdigits=3)) seconds\")\n\n    species_seriess_x = [[] for i in 1:num_species]\n    species_seriess_y = [[] for i in 1:num_species]\n    CI = CartesianIndices((linear_size, linear_size))\n    for ci in CartesianIndices(state)\n        species, site = Tuple(ci)\n        x,y = Tuple(CI[site])\n        num_molecules = state[ci]\n        sizehint!(species_seriess_x[species], num_molecules)\n        sizehint!(species_seriess_y[species], num_molecules)\n        if !is_static(species)\n            randsx = rand(num_molecules)\n            randsy = rand(num_molecules)\n        else\n            randsx = zeros(num_molecules)\n            randsy = zeros(num_molecules)\n        end\n        for k in 1:num_molecules\n            push!(species_seriess_x[species], x*h - h/4 + 0.5h*randsx[k])\n            push!(species_seriess_y[species], y*h - h/4 + 0.5h*randsy[k])\n        end\n    end\n    for species in 1:num_species\n        scatter!(plt, species_seriess_x[species], species_seriess_y[species], label = labels[species], marker = 6)\n    end\n    xticks!(plt, range(xlim...,length = linear_size+1))\n    yticks!(plt, range(ylim...,length = linear_size+1))\n    xgrid!(plt, 1, 0.7)\n    ygrid!(plt, 1, 0.7)\n    return plt\nend\n\n\"make an animation of solution sol in 2 dimensions\"\nfunction animate_2d(sol, linear_size; species_labels, title, verbose = true)\n    num_frames = length(sol.t)\n    anim = @animate for k=1:num_frames\n        verbose && println(\"Making frame $k\")\n        get_frame(k, sol, linear_size, species_labels, title)\n    end\n    anim\nend\n# animate\nanim=animate_2d(solution, 5, species_labels = [\"A\", \"B\", \"C\"], title = \"A + B <--> C\", verbose = false)\nfps = 5\ngif(anim, fps = fps)","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"Plots.AnimatedGif(\"/var/lib/buildkite-agent/builds/7-amdci4-julia-csail-mit\n-edu/julialang/scimltutorials-dot-jl/markdown/jumps/tmp.gif\")","category":"page"},{"location":"jumps/spatial/#Making-changes-to-the-model","page":"Ilin","title":"Making changes to the model","text":"","category":"section"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"Now suppose we want to make some changes to the reversible binding model above. There are three \"dimensions\" that can be changed: the topology of the system, the structure of hopping rates and the solver. The supported topologies are CartesianGrid – used above, and any AbstractGraph from LightGraphs. The supported forms of hopping rates are D_si D_sij D_s * L_ij, and D_si * L_ij, where s denotes the species, i – the source site, and j – the destination. The supported solvers are NSM, DirectCRDirect and any of the standard non-spatial solvers.","category":"page"},{"location":"jumps/spatial/#Topology","page":"Ilin","title":"Topology","text":"","category":"section"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"If our mesh is a grid (1D, 2D and 3D are supported), we can create the mesh as follows.","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"dims = (2,3,4) # can pass in a 1-Tuple, a 2-Tuple or a 3-Tuple\nnum_nodes = prod(dims)\ngrid = CartesianGrid(dims)","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"A Cartesian grid with dimensions (2, 3, 4)","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"The interface is the same as for LightGraphs.grid. If we want to use an unstructured mesh, we can simply use any AbstractGraph from LightGraphs as follows:","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"using LightGraphs\ngraph = cycle_digraph(5) # directed cyclic graph on 5 nodes","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"{5, 5} directed simple Int64 graph","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"Now either graph or grid can be used as spatial_system in creation of the JumpProblem.","category":"page"},{"location":"jumps/spatial/#Hopping-rates","page":"Ilin","title":"Hopping rates","text":"","category":"section"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"The most general form of hopping rates that is supported is D_sij – each (species, source, destination) triple gets its own independent hopping rate. To use this, hopping_constants must be of type Matrix{Vector{F}} where F <: Number (usually F is Float64) with hopping_constants[s,i][j] being the hopping rate of species s at site i to neighbor at index j. Note that neighbors are in ascending order, like in LightGraphs. Here is an example where only hopping up and left is allowed.","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"hopping_constants = Matrix{Vector{Float64}}(undef, num_species, num_nodes)\nfor ci in CartesianIndices(hopping_constants)\n    (species, site) = Tuple(ci)\n    hopping_constants[species, site] = zeros(outdegree(grid, site))\n    for (n, nb) in enumerate(neighbors(grid, site))\n        if nb < site\n            hopping_constants[species, site][n] = 1.0\n        end\n    end\nend","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"To pass in hopping_constants of form D_s * L_ij we need two vectors – one for D_s and one for L_ij. Here is an example.","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"species_hop_constants = ones(num_species)\nsite_hop_constants = Vector{Vector{Float64}}(undef, num_nodes)\nfor site in 1:num_nodes\n    site_hop_constants[site] = ones(outdegree(grid, site))\nend\nhopping_constants=Pair(species_hop_constants, site_hop_constants)","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"[1.0, 1.0, 1.0] => [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0],\n [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.\n0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1\n.0]  …  [1.0, 1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.\n0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0,\n 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"We must combine both vectors into a pair as in the last line above.","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"Finally, to use in hopping_constants of form D_si * L_ij we construct a matrix instead of a vector for D_sj.","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"species_hop_constants = ones(num_species, num_nodes)\nsite_hop_constants = Vector{Vector{Float64}}(undef, num_nodes)\nfor site in 1:num_nodes\n    site_hop_constants[site] = ones(outdegree(grid, site))\nend\nhopping_constants=Pair(species_hop_constants, site_hop_constants)","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"[1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0] => [[1.0, 1.0, 1.\n0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0,\n 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1\n.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1.0]  …  [1.0, 1.0, 1.0, 1.0, 1.0]\n, [1.0, 1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1\n.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0],\n [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"We can use either of the four versions of hopping_constants to construct a JumpProblem with the same syntax as in the original example. The different forms of hopping rates are supported not only for convenience but also for better memory usage and performance. So it is recommended that the most specialized form of hopping rates is used.","category":"page"},{"location":"jumps/spatial/#Solvers","page":"Ilin","title":"Solvers","text":"","category":"section"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"There are currently two specialized \"spatial\" solvers: NSM and DirectCRDirect. The former stands for Next Subvolume Method [1]. The latter employs Composition-Rejection to sample the next site to fire, similar to the ordinary DirectCR method. For larger networks DirectCRDirect is expected to be faster. Both methods can be used interchangeably.","category":"page"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"Additionally, all standard solvers are supported as well, although they are expected to use more memory and be slower. They \"flatten\" the problem, i.e. turn all hops into reactions, resulting in a much larger system. For example, to use the Next Reaction Method (NRM), simply pass in NRM() instead of NSM() in the construction of the JumpProblem. Importantly, you must pass in hopping_constants in the D_{s,i,j} or D_{s,i} form to use any of the non-specialized solvers.","category":"page"},{"location":"jumps/spatial/#References","page":"Ilin","title":"References","text":"","category":"section"},{"location":"jumps/spatial/","page":"Ilin","title":"Ilin","text":"[1]: Elf, Johan and Ehrenberg, Mäns. “Spontaneous separation of bi-stable biochemical systems into spatial domains of opposite phases”. In: Systems biology 1.2 (2004), pp. 230–236.","category":"page"},{"location":"models/03-diffeqbio_I_introduction/#DiffEqBiological-Tutorial-I:-Introduction","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"","category":"section"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"DiffEqBiological.jl is a domain specific language (DSL) for writing chemical reaction networks in Julia. The generated chemical reaction network model can then be translated into a variety of mathematical models which can be solved using components of the broader DifferentialEquations.jl ecosystem.","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"In this tutorial we'll provide an introduction to using DiffEqBiological to specify chemical reaction networks, and then to solve ODE, jump, tau-leaping and SDE models generated from them. Let's start by using the DiffEqBiological reaction_network macro to specify a simply chemical reaction network; the well-known Repressilator.","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"We first import the basic packages we'll need, and use Plots.jl for making figures:","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"# If not already installed, first hit \"]\" within a Julia REPL. Then type:\n# add DifferentialEquations DiffEqBiological PyPlot Plots Latexify\n\nusing DifferentialEquations, DiffEqBiological, Plots, Latexify\npyplot(fmt=:svg);","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"Error: ArgumentError: Package DiffEqBiological not found in current path:\n- Run `import Pkg; Pkg.add(\"DiffEqBiological\")` to install the DiffEqBiolog\nical package.","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"We now construct the reaction network. The basic types of arrows and predefined rate laws one can use are discussed in detail within the DiffEqBiological Chemical Reaction Models documentation. Here we use a mix of first order, zero order and repressive Hill function rate laws. Note, varnothing corresponds to the empty state, and is used for zeroth order production and first order degradation reactions:","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"repressilator = @reaction_network begin\n    hillr(P₃,α,K,n), ∅ --> m₁\n    hillr(P₁,α,K,n), ∅ --> m₂\n    hillr(P₂,α,K,n), ∅ --> m₃\n    (δ,γ), m₁ ↔ ∅\n    (δ,γ), m₂ ↔ ∅\n    (δ,γ), m₃ ↔ ∅\n    β, m₁ --> m₁ + P₁\n    β, m₂ --> m₂ + P₂\n    β, m₃ --> m₃ + P₃\n    μ, P₁ --> ∅\n    μ, P₂ --> ∅\n    μ, P₃ --> ∅\nend α K n δ γ β μ;","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"Error: LoadError: UndefVarError: @reaction_network not defined\nin expression starting at /var/lib/buildkite-agent/builds/1-amdci4-julia-cs\nail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/models/03-diffeqbio_I\n_introduction.jmd:2","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"We can use Latexify to look at the corresponding reactions and understand the generated rate laws for each reaction","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"latexify(repressilator; env=:chemical)","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"Error: KeyError: key :doctype not found","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"We can also use Latexify to look at the corresponding ODE model for the chemical system","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"latexify(repressilator, cdot=false)","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"Error: UndefVarError: latexify not defined","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"To solve the ODEs we need to specify the values of the parameters in the model, the initial condition, and the time interval to solve the model on. To do this it helps to know the orderings of the parameters and the species. Parameters are ordered in the same order they appear after the end statement in the @reaction_network macro. Species are ordered in the order they first appear within the @reaction_network macro. We can see these orderings using the speciesmap and paramsmap functions:","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"speciesmap(repressilator)","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"Error: UndefVarError: speciesmap not defined","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"paramsmap(repressilator)","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"Error: UndefVarError: paramsmap not defined","category":"page"},{"location":"models/03-diffeqbio_I_introduction/#Solving-the-ODEs:","page":"DiffEqBiological Tutorial I: Introduction","title":"Solving the ODEs:","text":"","category":"section"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"Knowing these orderings, we can create parameter and initial condition vectors, and setup the ODEProblem we want to solve:","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"# parameters [α,K,n,δ,γ,β,μ]\np = (.5, 40, 2, log(2)/120, 5e-3, 20*log(2)/120, log(2)/60)\n\n# initial condition [m₁,m₂,m₃,P₁,P₂,P₃]\nu₀ = [0.,0.,0.,20.,0.,0.]\n\n# time interval to solve on\ntspan = (0., 10000.)\n\n# create the ODEProblem we want to solve\noprob = ODEProblem(repressilator, u₀, tspan, p)","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"Error: UndefVarError: repressilator not defined","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"At this point we are all set to solve the ODEs. We can now use any ODE solver from within the DiffEq package. We'll just use the default DifferentialEquations solver for now, and then plot the solutions:","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"sol = solve(oprob, saveat=10.)\nplot(sol, fmt=:svg)","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"Error: UndefVarError: oprob not defined","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"We see the well-known oscillatory behavior of the repressilator! For more on choices of ODE solvers, see the JuliaDiffEq documentation.","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"","category":"page"},{"location":"models/03-diffeqbio_I_introduction/#Stochastic-Simulation-Algorithms-(SSAs)-for-Stochastic-Chemical-Kinetics","page":"DiffEqBiological Tutorial I: Introduction","title":"Stochastic Simulation Algorithms (SSAs) for Stochastic Chemical Kinetics","text":"","category":"section"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"Let's now look at a stochastic chemical kinetics model of the repressilator, modeling it with jump processes. Here we will construct a DiffEqJump JumpProblem that uses Gillespie's Direct method, and then solve it to generate one realization of the jump process:","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"# first we redefine the initial condition to be integer valued\nu₀ = [0,0,0,20,0,0]\n\n# next we create a discrete problem to encode that our species are integer valued:\ndprob = DiscreteProblem(repressilator, u₀, tspan, p)\n\n# now we create a JumpProblem, and specify Gillespie's Direct Method as the solver:\njprob = JumpProblem(dprob, Direct(), repressilator, save_positions=(false,false))\n\n# now let's solve and plot the jump process:\nsol = solve(jprob, SSAStepper(), saveat=10.)\nplot(sol, fmt=:svg)","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"Error: UndefVarError: repressilator not defined","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"Here we see that oscillations remain, but become much noiser. Note, in constructing the JumpProblem we could have used any of the SSAs that are part of DiffEqJump instead of the Direct method, see the list of SSAs (i.e. constant rate jump aggregators) in the documentation.","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"","category":"page"},{"location":"models/03-diffeqbio_I_introduction/#\\tau-leaping-Methods:","page":"DiffEqBiological Tutorial I: Introduction","title":"tau-leaping Methods:","text":"","category":"section"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"While SSAs generate exact realizations for stochastic chemical kinetics jump process models, tau-leaping methods offer a performant alternative by discretizing in time the underlying time-change representation of the stochastic process. The DiffEqJump package has limited support for tau-leaping methods in the form of the basic Euler's method type approximation proposed by Gillespie. We can simulate a tau-leap approximation to the repressilator by using the  RegularJump representation of the network to construct a JumpProblem:","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"rjs = regularjumps(repressilator)\nlprob = JumpProblem(dprob, Direct(), rjs)\nlsol = solve(lprob, SimpleTauLeaping(), dt=.1)\nplot(lsol, plotdensity=1000, fmt=:svg)","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"Error: UndefVarError: regularjumps not defined","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"","category":"page"},{"location":"models/03-diffeqbio_I_introduction/#Chemical-Langevin-Equation-(CLE)-Stochastic-Differential-Equation-(SDE)-Models:","page":"DiffEqBiological Tutorial I: Introduction","title":"Chemical Langevin Equation (CLE) Stochastic Differential Equation (SDE) Models:","text":"","category":"section"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"At an intermediary physical scale between macroscopic ODE models and microscopic stochastic chemical kinetic models lies the CLE, a SDE version of the model. The SDEs add to each ODE above a noise term. As the repressilator has species that get very close to zero in size, it is not a good candidate to model with the CLE (where solutions can then go negative and become unphysical). Let's create a simpler reaction network for a birth-death process that will stay non-negative:","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"bdp = @reaction_network begin\n  c₁, X --> 2X\n  c₂, X --> 0\n  c₃, 0 --> X\nend c₁ c₂ c₃\np = (1.0,2.0,50.)\nu₀ = [5.]\ntspan = (0.,4.);","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"Error: LoadError: UndefVarError: @reaction_network not defined\nin expression starting at /var/lib/buildkite-agent/builds/1-amdci4-julia-cs\nail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/models/03-diffeqbio_I\n_introduction.jmd:2","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"The corresponding Chemical Langevin Equation SDE is then","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"latexify(bdp, noise=true, cdot=false)","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"Error: UndefVarError: latexify not defined","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"where each W_i(t) denotes an independent Brownian Motion. We can solve the CLE SDE model by creating an SDEProblem and solving it similar to what we did for ODEs above:","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"# SDEProblem for CLE\nsprob = SDEProblem(bdp, u₀, tspan, p)\n\n# solve and plot, tstops is used to specify enough points\n# that the plot looks well-resolved\nsol = solve(sprob, tstops=range(0., step=4e-3, length=1001))\nplot(sol, fmt=:svg)","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"Error: UndefVarError: bdp not defined","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"We again have complete freedom to select any of the StochasticDifferentialEquations.jl SDE solvers, see the documentation.","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"","category":"page"},{"location":"models/03-diffeqbio_I_introduction/#What-information-can-be-queried-from-the-reaction_network:","page":"DiffEqBiological Tutorial I: Introduction","title":"What information can be queried from the reaction_network:","text":"","category":"section"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"The generated reaction_network contains a lot of basic information. For example","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"f=oderhsfun(repressilator) is a function f(du,u,p,t) that given the current state vector u and time t fills du with the time derivatives of u (i.e. the right hand side of the ODEs).\njac=jacfun(repressilator) is a function jac(J,u,p,t) that evaluates and returns the Jacobian of the ODEs in J. A corresponding Jacobian matrix of expressions can be accessed using the jacobianexprs function:","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"latexify(jacobianexprs(repressilator), cdot=false)","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"Error: UndefVarError: jacobianexprs not defined","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"pjac = paramjacfun(repressilator) is a function pjac(pJ,u,p,t) that evaluates and returns the Jacobian, pJ, of the ODEs with respect to the parameters. This allows reaction_networks to be used in the DifferentialEquations.jl local sensitivity analysis package DiffEqSensitivity.","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"By default, generated ODEProblems will be passed the corresponding Jacobian function, which will then be used within implicit ODE/SDE methods.","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"The DiffEqBiological API documentation provides a thorough description of the many query functions that are provided to access network properties and generated functions. In DiffEqBiological Tutorial II we'll explore the API.","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"","category":"page"},{"location":"models/03-diffeqbio_I_introduction/#Getting-Help","page":"DiffEqBiological Tutorial I: Introduction","title":"Getting Help","text":"","category":"section"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"Have a question related to DiffEqBiological or this tutorial? Feel free to ask in the DifferentialEquations.jl Gitter. If you think you've found a bug in DiffEqBiological, or would like to request/discuss new functionality, feel free to open an issue on Github (but please check there is no related issue already open). If you've found a bug in this tutorial, or have a suggestion, feel free to open an issue on the SciMLTutorials Github site. Or, submit a pull request to SciMLTutorials updating the tutorial!","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"","category":"page"},{"location":"models/03-diffeqbio_I_introduction/","page":"DiffEqBiological Tutorial I: Introduction","title":"DiffEqBiological Tutorial I: Introduction","text":"Error: MethodError: no method matching tutorial_footer(::String, ::String; \nremove_homedir=true)\nClosest candidates are:\n  tutorial_footer(::Any, ::Any) at /var/lib/buildkite-agent/builds/1-amdci4\n-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/src/SciMLTutorials.jl:\n79 got unsupported keyword argument \"remove_homedir\"\n  tutorial_footer(::Any) at /var/lib/buildkite-agent/builds/1-amdci4-julia-\ncsail-mit-edu/julialang/scimltutorials-dot-jl/src/SciMLTutorials.jl:79 got \nunsupported keyword argument \"remove_homedir\"","category":"page"},{"location":"Testing/test/","page":"-","title":"-","text":"","category":"page"},{"location":"Testing/test/","page":"-","title":"-","text":"author: \"Chris Rackauckas\" title: \"Test\" –-","category":"page"},{"location":"Testing/test/","page":"-","title":"-","text":"This is a test of the builder system.  It often gets bumped manually.","category":"page"},{"location":"Testing/test/#Appendix","page":"-","title":"Appendix","text":"","category":"section"},{"location":"Testing/test/","page":"-","title":"-","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"Testing/test/","page":"-","title":"-","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"Testing/test/","page":"-","title":"-","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"Testing\",\"test.jmd\")","category":"page"},{"location":"Testing/test/","page":"-","title":"-","text":"Computer Information:","category":"page"},{"location":"Testing/test/","page":"-","title":"-","text":"Julia Version 1.6.5\nCommit 9058264a69 (2021-12-19 12:30 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, znver2)\nEnvironment:\n  JULIA_CPU_THREADS = 16\n  BUILDKITE_PLUGIN_JULIA_CACHE_DIR = /cache/julia-buildkite-plugin\n  JULIA_DEPOT_PATH = /cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n","category":"page"},{"location":"Testing/test/","page":"-","title":"-","text":"Package Information:","category":"page"},{"location":"Testing/test/","page":"-","title":"-","text":"      Status `/cache/build/default-amdci4-1/julialang/scimltutorials-dot-jl/tutorials/Testing/Project.toml`\n  [30cb0354] SciMLTutorials v0.9.0","category":"page"},{"location":"Testing/test/","page":"-","title":"-","text":"And the full manifest:","category":"page"},{"location":"Testing/test/","page":"-","title":"-","text":"      Status `/cache/build/default-amdci4-1/julialang/scimltutorials-dot-jl/tutorials/Testing/Manifest.toml`\n  [79e6a3ab] Adapt v3.3.0\n  [35d6a980] ColorSchemes v3.12.1\n  [3da002f7] ColorTypes v0.11.0\n  [5ae59095] Colors v0.12.8\n  [34da2185] Compat v3.30.0\n  [8f4d0f93] Conda v1.5.2\n  [d38c429a] Contour v0.5.7\n  [9a962f9c] DataAPI v1.6.0\n  [864edb3b] DataStructures v0.18.9\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [ffbed154] DocStringExtensions v0.8.4\n  [c87230d0] FFMPEG v0.4.0\n  [53c48c17] FixedPointNumbers v0.8.4\n  [59287772] Formatting v0.4.2\n  [28b8d3ca] GR v0.57.4\n  [5c1252a2] GeometryBasics v0.3.12\n  [42e2da0e] Grisu v1.0.2\n  [cd3eb016] HTTP v0.9.9\n  [eafb193a] Highlights v0.4.5\n  [7073ff75] IJulia v1.23.2\n  [83e8ac13] IniFile v0.5.0\n  [c8e1da08] IterTools v1.3.0\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.3.0\n  [682c06a0] JSON v0.21.1\n  [b964fa9f] LaTeXStrings v1.2.1\n  [23fbe1c1] Latexify v0.15.5\n  [1914dd2f] MacroTools v0.5.6\n  [739be429] MbedTLS v1.0.3\n  [442fdcdd] Measures v0.3.1\n  [e1d29d7a] Missings v1.0.0\n  [ffc61752] Mustache v1.0.10\n  [77ba4419] NaNMath v0.3.5\n  [bac558e1] OrderedCollections v1.4.1\n  [69de0a69] Parsers v1.1.0\n  [ccf2f8ad] PlotThemes v2.0.1\n  [995b91a9] PlotUtils v1.0.10\n  [91a5bcdd] Plots v1.15.2\n  [21216c6a] Preferences v1.2.2\n  [3cdcf5f2] RecipesBase v1.1.1\n  [01d81517] RecipesPipeline v0.3.2\n  [189a3867] Reexport v1.0.0\n  [ae029012] Requires v1.1.3\n  [30cb0354] SciMLTutorials v0.9.0\n  [6c6a2e73] Scratch v1.0.3\n  [992d4aef] Showoff v1.0.3\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.0\n  [90137ffa] StaticArrays v1.2.0\n  [82ae8749] StatsAPI v1.0.0\n  [2913bbd2] StatsBase v0.33.8\n  [09ab397b] StructArrays v0.5.1\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.4.2\n  [5c2747f8] URIs v1.3.0\n  [81def892] VersionParsing v1.2.0\n  [44d3d7a6] Weave v0.10.8\n  [ddb6d928] YAML v0.4.6\n  [c2297ded] ZMQ v1.2.1\n  [6e34b625] Bzip2_jll v1.0.6+5\n  [83423d85] Cairo_jll v1.16.0+6\n  [5ae413db] EarCut_jll v2.1.5+1\n  [2e619515] Expat_jll v2.2.10+0\n  [b22a6f82] FFMPEG_jll v4.3.1+4\n  [a3f928ae] Fontconfig_jll v2.13.1+14\n  [d7e528f0] FreeType2_jll v2.10.1+5\n  [559328eb] FriBidi_jll v1.0.5+6\n  [0656b61e] GLFW_jll v3.3.4+0\n  [d2c73de3] GR_jll v0.57.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.1+0\n  [aacddb02] JpegTurbo_jll v2.0.1+3\n  [c1c5ebd0] LAME_jll v3.100.0+3\n  [dd4b983a] LZO_jll v2.10.1+0\n  [dd192d2f] LibVPX_jll v1.9.0+1\n  [e9f186c6] Libffi_jll v3.2.2+0\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+0\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.1.0+2\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [e7412a2a] Ogg_jll v1.3.4+2\n  [458c3c95] OpenSSL_jll v1.1.1+6\n  [91d4177d] Opus_jll v1.3.1+3\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.2+0\n  [a2964d1f] Wayland_jll v1.17.0+4\n  [2381bf8a] Wayland_protocols_jll v1.18.0+4\n  [02c8fc9c] XML2_jll v2.9.12+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.2+6\n  [3161d3a3] Zstd_jll v1.5.0+0\n  [0ac62f75] libass_jll v0.14.0+4\n  [f638f0a6] libfdk_aac_jll v0.1.6+4\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.6+6\n  [1270edf5] x264_jll v2020.7.14+2\n  [dfaa095f] x265_jll v3.0.0+3\n  [d8fb68d0] xkbcommon_jll v0.9.1+5\n  [0dad84c5] ArgTools\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads\n  [7b1f6079] FileWatching\n  [b77e0a4c] InteractiveUtils\n  [b27032c2] LibCURL\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions\n  [44cfe95a] Pkg\n  [de0858da] Printf\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [fa267f1f] TOML\n  [a4e569a6] Tar\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll\n  [deac9b47] LibCURL_jll\n  [29816b5a] LibSSH2_jll\n  [c8ffd9c3] MbedTLS_jll\n  [14a3606d] MozillaCACerts_jll\n  [83775a58] Zlib_jll\n  [8e850ede] nghttp2_jll\n  [3f19e933] p7zip_jll","category":"page"},{"location":"exercises/02-workshop_solutions/#SciML-Workshop-Exercise-Solutions","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"using DifferentialEquations\nusing Sundials\nusing BenchmarkTools\nusing Plots","category":"page"},{"location":"exercises/02-workshop_solutions/#Problem-1:-Investigating-Sources-of-Randomness-and-Uncertainty-in-a-Biological-System","page":"SciML Workshop Exercise Solutions","title":"Problem 1: Investigating Sources of Randomness and Uncertainty in a Biological System","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-1:-Simulating-the-Oregonator-ODE-model","page":"SciML Workshop Exercise Solutions","title":"Part 1: Simulating the Oregonator ODE model","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"using DifferentialEquations, Plots\nfunction orego(du,u,p,t)\n  s,q,w = p\n  y1,y2,y3 = u\n  du[1] = s*(y2+y1*(1-q*y1-y2))\n  du[2] = (y3-(1+y1)*y2)/s\n  du[3] = w*(y1-y3)\nend\np = [77.27,8.375e-6,0.161]\nprob = ODEProblem(orego,[1.0,2.0,3.0],(0.0,360.0),p)\nsol = solve(prob)\nplot(sol)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"plot(sol,vars=(1,2,3))","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-2:-Investigating-Stiffness","page":"SciML Workshop Exercise Solutions","title":"Part 2: Investigating Stiffness","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"using BenchmarkTools\nprob = ODEProblem(orego,[1.0,2.0,3.0],(0.0,50.0),p)\n@btime sol = solve(prob,Tsit5())","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"893.348 ms (8723143 allocations: 920.67 MiB)\nretcode: Success\nInterpolation: specialized 4th order \"free\" interpolation\nt: 872306-element Array{Float64,1}:\n  0.0\n  0.01618926718934831\n  0.02355386004837834\n  0.03818038870154586\n  0.050503515877727514\n  0.06810672932191658\n  0.08676359998206734\n  0.11145368602241688\n  0.14105967462147356\n  0.18104879156165962\n  ⋮\n 49.99977330536325\n 49.99980456142745\n 49.999835817515255\n 49.999867073624586\n 49.999898329755446\n 49.99992958590576\n 49.99996084207554\n 49.999992098266844\n 50.0\nu: 872306-element Array{Array{Float64,1},1}:\n [1.0, 2.0, 3.0]\n [1.7128564042197614, 1.9996098373795999, 2.9959141611121862]\n [1.8376268914687968, 1.9993653073090198, 2.994474646468457]\n [1.9480445809808178, 1.9988333244430836, 2.991907642632475]\n [1.9807789479174538, 1.998364632682339, 2.989876120098015]\n [1.996520358969301, 1.9976843022063284, 2.9870473687154533]\n [2.0012471416469095, 1.9969587120867922, 2.9840850652644586]\n [2.003267094253373, 1.9959962346456372, 2.980190667568818]\n [2.0046071951018165, 1.9948405279663373, 2.9755485736940304]\n [2.0062040975915965, 1.9932773146432707, 2.969322732597494]\n ⋮\n [1.00114451241949, 1453.0173573419604, 414.83224206133156]\n [1.0011445128905938, 1453.0163492345089, 414.8301595725294]\n [1.001144513536549, 1453.0153411262695, 414.82807709263454]\n [1.001144514166616, 1453.014333017309, 414.82599462178484]\n [1.0011445147807905, 1453.013324907627, 414.8239121599803]\n [1.0011445151883325, 1453.0123167972909, 414.82182970735875]\n [1.0011445153892404, 1453.0113086863003, 414.8197472639202]\n [1.001144515574252, 1453.0103005745884, 414.8176648295267]\n [1.0008765717435082, 1453.0100456736175, 414.8171383809634]","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"@btime sol = solve(prob,Rodas5())","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"534.668 μs (1907 allocations: 130.11 KiB)\nretcode: Success\nInterpolation: 3rd order Hermite\nt: 110-element Array{Float64,1}:\n  0.0\n  0.019615259849088615\n  0.029598314714131158\n  0.04705295553350644\n  0.06489958093933189\n  0.08933251171067431\n  0.12069400166576917\n  0.16655311655246774\n  0.24089140897016648\n  0.39558909491704786\n  ⋮\n 26.756905610888992\n 27.982111658219903\n 29.768997154114096\n 32.21837697976615\n 35.093850201346655\n 38.49798110093118\n 42.33811919585127\n 46.60842194880463\n 50.0\nu: 110-element Array{Array{Float64,1},1}:\n [1.0, 2.0, 3.0]\n [1.7804115041903392, 1.9994992840408727, 2.995224421497252]\n [1.898773632635922, 1.9991507098568697, 2.9933805881501456]\n [1.9745775749460168, 1.9984968888022705, 2.9904382700551317]\n [1.9949959346655894, 1.9978087397951183, 2.9875591897227847]\n [2.0015958931121642, 1.9968586608477479, 2.98367866834122]\n [2.003748190575679, 1.9956356930368464, 2.9787387129953866]\n [2.0056429388535917, 1.9938442509772465, 2.9715736894920433]\n [2.0085949421229565, 1.9909335157971781, 2.960099467726684]\n [2.014815188384092, 1.9848502001186519, 2.936770263171178]\n ⋮\n [1.0009510454262696, 1052.1681949981978, 17454.97704553619]\n [1.000790082105047, 1266.4223517298105, 14330.342720311946]\n [1.0006713873660182, 1490.2781714142227, 10747.93771088393]\n [1.000598803847115, 1670.9447027478102, 7245.705166049239]\n [1.000568993307521, 1758.4723173221284, 4560.988616721742]\n [1.000569273504183, 1757.6100577789323, 2636.982996349979]\n [1.000594225030407, 1683.8471494545056, 1421.4818618119598]\n [1.0006409946157637, 1561.0560213127278, 715.2527024515273]\n [1.0006887475677544, 1452.8969192375328, 414.7220773988324]","category":"page"},{"location":"exercises/02-workshop_solutions/#(Optional)-Part-3:-Specifying-Analytical-Jacobians-(I)","page":"SciML Workshop Exercise Solutions","title":"(Optional) Part 3: Specifying Analytical Jacobians (I)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#(Optional)-Part-4:-Automatic-Symbolicification-and-Analytical-Jacobian-Calculations","page":"SciML Workshop Exercise Solutions","title":"(Optional) Part 4: Automatic Symbolicification and Analytical Jacobian Calculations","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-5:-Adding-stochasticity-with-stochastic-differential-equations","page":"SciML Workshop Exercise Solutions","title":"Part 5: Adding stochasticity with stochastic differential equations","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function orego(du,u,p,t)\n  s,q,w = p\n  y1,y2,y3 = u\n  du[1] = s*(y2+y1*(1-q*y1-y2))\n  du[2] = (y3-(1+y1)*y2)/s\n  du[3] = w*(y1-y3)\nend\nfunction g(du,u,p,t)\n  du[1] = 0.1u[1]\n  du[2] = 0.1u[2]\n  du[3] = 0.1u[3]\nend\np = [77.27,8.375e-6,0.161]\nprob = SDEProblem(orego,g,[1.0,2.0,3.0],(0.0,30.0),p)\nsol = solve(prob,SOSRI())\nplot(sol)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"sol = solve(prob,ImplicitRKMil()); plot(sol)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Error: InexactError: Int64(Inf)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"sol = solve(prob,ImplicitRKMil()); plot(sol)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Error: InexactError: Int64(Inf)","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-6:-Gillespie-jump-models-of-discrete-stochasticity","page":"SciML Workshop Exercise Solutions","title":"Part 6: Gillespie jump models of discrete stochasticity","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-7:-Probabilistic-Programming-/-Bayesian-Parameter-Estimation-with-DiffEqBayes.jl-Turing.jl-(I)","page":"SciML Workshop Exercise Solutions","title":"Part 7: Probabilistic Programming / Bayesian Parameter Estimation with DiffEqBayes.jl + Turing.jl (I)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"The data was generated with:","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function orego(du,u,p,t)\n  s,q,w = p\n  y1,y2,y3 = u\n  du[1] = s*(y2+y1*(1-q*y1-y2))\n  du[2] = (y3-(1+y1)*y2)/s\n  du[3] = w*(y1-y3)\nend\np = [60.0,1e-5,0.2]\nprob = ODEProblem(orego,[1.0,2.0,3.0],(0.0,30.0),p)\nsol = solve(prob,Rodas5(),abstol=1/10^14,reltol=1/10^14)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"retcode: Success\nInterpolation: 3rd order Hermite\nt: 48825-element Array{Float64,1}:\n  0.0\n  0.0001377354452002734\n  0.0002010718419122773\n  0.0003021998626318717\n  0.0004033278833514661\n  0.0005062369821758017\n  0.0006097468311490204\n  0.0007142127440433809\n  0.0008192699078400218\n  0.0009249477742217067\n  ⋮\n 29.8029621721172\n 29.830644478725933\n 29.858326785334665\n 29.886009659186307\n 29.91369253303795\n 29.94137540688959\n 29.96906121150096\n 29.99674701611233\n 30.0\nu: 48825-element Array{Array{Float64,1},1}:\n [1.0, 2.0, 3.0]\n [1.0082299897608653, 1.9999976854327, 2.9999450200919755]\n [1.0119917072902584, 1.999996608412124, 2.999919814481464]\n [1.0179684138472678, 1.9999948722835914, 2.99987966834307]\n [1.0239089650942212, 1.9999931160074038, 2.9998396435319274]\n [1.029917251895588, 1.9999913082422207, 2.999799037595289]\n [1.0359233048539687, 1.999989469133448, 2.9997583198166615]\n [1.0419471308701034, 1.9999875920280812, 2.9997173524755154]\n [1.0479670917315083, 1.9999856831456868, 2.9996762806603012]\n [1.0539844577981918, 1.9999837417184405, 2.99963509426064]\n ⋮\n [1.000649179056226, 1541.3915652677524, 2704.0497424834743]\n [1.0006492543168537, 1541.2130026445143, 2689.1257668560265]\n [1.0006493324193109, 1541.027741407077, 2674.2841889364954]\n [1.0006494133487425, 1540.8358216266624, 2659.5242521879404]\n [1.0006494970871955, 1540.6372908555195, 2644.845809127133]\n [1.0006495836184481, 1540.4321926696598, 2630.248409804933]\n [1.0006496729360377, 1540.220547649861, 2615.7300741273025]\n [1.0006497650150368, 1540.0024202595741, 2601.291906654189]\n [1.00064977601455, 1539.9763674790563, 2599.600715743143]","category":"page"},{"location":"exercises/02-workshop_solutions/#(Optional)-Part-8:-Using-DiffEqBiological's-Reaction-Network-DSL","page":"SciML Workshop Exercise Solutions","title":"(Optional) Part 8: Using DiffEqBiological's Reaction Network DSL","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Problem-2:-Fitting-Hybrid-Delay-Pharmacokinetic-Models-with-Automated-Responses-(B)","page":"SciML Workshop Exercise Solutions","title":"Problem 2: Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-1:-Defining-an-ODE-with-Predetermined-Doses","page":"SciML Workshop Exercise Solutions","title":"Part 1: Defining an ODE with Predetermined Doses","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function onecompartment(du,u,p,t)\n  Ka,Ke = p\n  du[1] = -Ka*u[1]\n  du[2] =  Ka*u[1] - Ke*u[2]\nend\np = (Ka=2.268,Ke=0.07398)\nprob = ODEProblem(onecompartment,[100.0,0.0],(0.0,90.0),p)\n\ntstops = [24,48,72]\ncondition(u,t,integrator) = t ∈ tstops\naffect!(integrator) = (integrator.u[1] += 100)\ncb = DiscreteCallback(condition,affect!)\nsol = solve(prob,Tsit5(),callback=cb,tstops=tstops)\nplot(sol)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-2:-Adding-Delays","page":"SciML Workshop Exercise Solutions","title":"Part 2: Adding Delays","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function onecompartment_delay(du,u,h,p,t)\n  Ka,Ke,τ = p\n  delayed_depot = h(p,t-τ)[1]\n  du[1] = -Ka*u[1]\n  du[2] =  Ka*delayed_depot - Ke*u[2]\nend\np = (Ka=2.268,Ke=0.07398,τ=6.0)\nh(p,t) = [0.0,0.0]\nprob = DDEProblem(onecompartment_delay,[100.0,0.0],h,(0.0,90.0),p)\n\ntstops = [24,48,72]\ncondition(u,t,integrator) = t ∈ tstops\naffect!(integrator) = (integrator.u[1] += 100)\ncb = DiscreteCallback(condition,affect!)\nsol = solve(prob,MethodOfSteps(Rosenbrock23()),callback=cb,tstops=tstops)\nplot(sol)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-3:-Automatic-Differentiation-(AD)-for-Optimization-(I)","page":"SciML Workshop Exercise Solutions","title":"Part 3: Automatic Differentiation (AD) for Optimization (I)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-4:-Fitting-Known-Quantities-with-DiffEqParamEstim.jl-Optim.jl","page":"SciML Workshop Exercise Solutions","title":"Part 4: Fitting Known Quantities with DiffEqParamEstim.jl + Optim.jl","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"The data was generated with","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"p = (Ka = 0.5, Ke = 0.1, τ = 4.0)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Ka = 0.5, Ke = 0.1, τ = 4.0)","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-5:-Implementing-Control-Based-Logic-with-ContinuousCallbacks-(I)","page":"SciML Workshop Exercise Solutions","title":"Part 5: Implementing Control-Based Logic with ContinuousCallbacks (I)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-6:-Global-Sensitivity-Analysis-with-the-Morris-and-Sobol-Methods","page":"SciML Workshop Exercise Solutions","title":"Part 6: Global Sensitivity Analysis with the Morris and Sobol Methods","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Problem-3:-Differential-Algebraic-Equation-Modeling-of-a-Double-Pendulum-(B)","page":"SciML Workshop Exercise Solutions","title":"Problem 3: Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-1:-Simple-Introduction-to-DAEs:-Mass-Matrix-Robertson-Equations","page":"SciML Workshop Exercise Solutions","title":"Part 1: Simple Introduction to DAEs: Mass-Matrix Robertson Equations","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function f(du, u, p, t)\n    du[1] = -p[1]*u[1] + p[2]*u[2]*u[3]\n    du[2] = p[1]*u[1] - p[2]*u[2]*u[3] - p[3]*u[2]*u[2]\n    du[3] = u[1] + u[2] + u[3] - 1.\nend\nM = [1 0 0; 0 1 0; 0 0 0.]\np = [0.04, 10^4, 3e7]\nu0 = [1.,0.,0.]\ntspan = (0., 1e6)\nprob = ODEProblem(ODEFunction(f, mass_matrix = M), u0, tspan, p)\nsol = solve(prob, Rodas5())\nplot(sol, xscale=:log10, tspan=(1e-6, 1e5), layout=(3,1))","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-2:-Solving-the-Implicit-Robertson-Equations-with-IDA","page":"SciML Workshop Exercise Solutions","title":"Part 2: Solving the Implicit Robertson Equations with IDA","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"# Robertson Equation DAE Implicit form\nfunction h(out, du, u, p, t)\n    out[1] = -p[1]*u[1] + p[2]*u[2]*u[3] - du[1]\n    out[2] = p[1]*u[1] - p[2]*u[2]*u[3] - p[3]*u[2]*u[2] - du[2]\n    out[3] = u[1] + u[2] + u[3] - 1.\nend\np = [0.04, 10^4, 3e7]\ndu0 = [-0.04, 0.04, 0.0]\nu0 = [1.,0.,0.]\ntspan = (0., 1e6)\ndifferential_vars = [true, true, false]\nprob = DAEProblem(h, du0, u0, tspan, p, differential_vars = differential_vars)\nsol = solve(prob, IDA())\nplot(sol, xscale=:log10, tspan=(1e-6, 1e5), layout=(3,1))","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-3:-Manual-Index-Reduction-of-the-Single-Pendulum","page":"SciML Workshop Exercise Solutions","title":"Part 3: Manual Index Reduction of the Single Pendulum","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Consider the equation: $ x^2 + y^2 = L $ Differentiating once with respect to time: $ 2x\\dot{x} + 2y\\dot{y} = 0 $ A second time: $ \\begin{align} {\\dot{x}}^2 + x\\ddot{x} + {\\dot{y}}^2 + y\\ddot{y} &= 0  \\\nu^2 + v^2 + x(\\frac{x}{mL}T) + y(\\frac{y}{mL}T - g) &= 0  \\\nu^2 + v^2 + \\frac{x^2 + y^2}{mL}T - yg &= 0 \\\nu^2 + v^2 + \\frac{T}{m} - yg &= 0 \\end{align} $","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Our final set of equations is hence $ \\begin{align}    \\ddot{x} &= \\frac{x}{mL}T \\\n   \\ddot{y} &= \\frac{y}{mL}T - g \\\n   \\dot{x} &= u \\\n   \\dot{y} &= v \\\n   u^2 + v^2 -yg + \\frac{T}{m} &= 0 \\end{align} $","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"We finally obtain T into the third equation. This required two differentiations with respect to time, and so our system of equations went from index 3 to index 1. Now our solver can handle the index 1 system.","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-4:-Single-Pendulum-Solution-with-IDA","page":"SciML Workshop Exercise Solutions","title":"Part 4: Single Pendulum Solution with IDA","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function f(out, da, a, p, t)\n   (L, m, g) = p\n   u, v, x, y, T = a\n   du, dv, dx, dy, dT = da\n   out[1] = x*T/(m*L) - du\n   out[2] = y*T/(m*L) - g - dv\n   out[3] = u - dx\n   out[4] = v - dy\n   out[5] = u^2 + v^2 - y*g + T/m\n   nothing\nend\n\n# Release pendulum from top right\nu0 = zeros(5)\nu0[3] = 1.0\ndu0 = zeros(5)\ndu0[2] = 9.81\n\np = [1,1,9.8]\ntspan = (0.,100.)\n\ndifferential_vars = [true, true, true, true, false]\nprob = DAEProblem(f, du0, u0, tspan, p, differential_vars = differential_vars)\nsol = solve(prob, IDA())\nplot(sol, vars=(3,4))","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-5:-Solving-the-Double-Penulum-DAE-System","page":"SciML Workshop Exercise Solutions","title":"Part 5: Solving the Double Penulum DAE System","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"For the double pendulum: The equations for the second ball are the same as the single pendulum case. That is, the equations for the second ball are: $ \\begin{align}    \\ddot{x2} &= \\frac{x2}{m2L2}T2 \\\n   \\ddot{y2} &= \\frac{y2}{m2L2}T2 - g \\\n   \\dot{x2} &= u \\\n   \\dot{y2} &= v \\\n   u2^2 + v2^2 -y2g + \\frac{T2}{m2} &= 0 \\end{align} $ For the first ball, consider x1^2 + y1^2 = L $ $ \\begin{align} x1^2 + x2^2 &= L \\\n2x1\\dot{x1} + 2y1\\dot{y1} &= 0 \\\n\\dot{x1}^2 + \\dot{y1}^2 + x1(\\frac{x1}{m1L1}T1 - \\frac{x2}{m1L2}T2) + y1(\\frac{y1}{m1L1}T1 - g - \\frac{y2}{m1L2}T2) &= 0 \\\nu1^2 + v1^2 + \\frac{T1}{m1} - \\frac{x1x2 + y1y2}{m1L2}T2 &= 0 \\end{align} $","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"So the final equations are: $ \\begin{align}    \\dot{u2} &= x2T2/(m2L2)    \\dot{v2} &= y2*T2/(m2*L2) - g    \\dot{x2} &= u2    \\dot{y2} &= v2    u2^2 + v2^2 -y2*g + \\frac{T2}{m_2} &=  0","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"\\dot{u1} &= x1T1/(m1L1) - x2T2/(m2L2)    \\dot{v1} &= y1*T1/(m1*L1) - g - y2*T2/(m2*L2)    \\dot{x1} &= u1    \\dot{y1} &= v1    u1^2 + v1^2 + \\frac{T1}{m1} +                 \\frac{-x1*x2 - y1*y2}{m1L2}T2 - y1g &= 0 \\end{align} $","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function f(out, da, a, p, t)\n   L1, m1, L2, m2, g = p\n\n   u1, v1, x1, y1, T1,\n   u2, v2, x2, y2, T2 = a\n\n   du1, dv1, dx1, dy1, dT1,\n   du2, dv2, dx2, dy2, dT2 = da\n\n   out[1]  = x2*T2/(m2*L2) - du2\n   out[2]  = y2*T2/(m2*L2) - g - dv2\n   out[3]  = u2 - dx2\n   out[4]  = v2 - dy2\n   out[5]  = u2^2 + v2^2 -y2*g + T2/m2\n\n   out[6]  = x1*T1/(m1*L1) - x2*T2/(m2*L2) - du1\n   out[7]  = y1*T1/(m1*L1) - g - y2*T2/(m2*L2) - dv1\n   out[8]  = u1 - dx1\n   out[9]  = v1 - dy1\n   out[10] = u1^2 + v1^2 + T1/m1 +\n                (-x1*x2 - y1*y2)/(m1*L2)*T2 - y1*g\n   nothing\nend\n\n# Release pendulum from top right\nu0 = zeros(10)\nu0[3] = 1.0\nu0[8] = 1.0\ndu0 = zeros(10)\ndu0[2] = 9.8\ndu0[7] = 9.8\n\np = [1,1,1,1,9.8]\ntspan = (0.,100.)\n\ndifferential_vars = [true, true, true, true, false,\n                     true, true, true, true, false]\nprob = DAEProblem(f, du0, u0, tspan, p, differential_vars = differential_vars)\nsol = solve(prob, IDA())\n\nplot(sol, vars=(3,4))\nplot(sol, vars=(8,9))","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/#Problem-4:-Performance-Optimizing-and-Parallelizing-Semilinear-PDE-Solvers-(I)","page":"SciML Workshop Exercise Solutions","title":"Problem 4: Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-1:-Implementing-the-BRUSS-PDE-System-as-ODEs","page":"SciML Workshop Exercise Solutions","title":"Part 1: Implementing the BRUSS PDE System as ODEs","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"using DifferentialEquations, Sundials, Plots\n\n# initial condition\nfunction init_brusselator_2d(xyd)\n    N = length(xyd)\n    u = zeros(N, N, 2)\n    for I in CartesianIndices((N, N))\n        x = xyd[I[1]]\n        y = xyd[I[2]]\n        u[I,1] = 22*(y*(1-y))^(3/2)\n        u[I,2] = 27*(x*(1-x))^(3/2)\n    end\n    u\nend\n\nN = 32\n\nxyd_brusselator = range(0,stop=1,length=N)\n\nu0 = vec(init_brusselator_2d(xyd_brusselator))\n\ntspan = (0, 22.)\n\np = (3.4, 1., 10., xyd_brusselator)\n\nbrusselator_f(x, y, t) = ifelse((((x-0.3)^2 + (y-0.6)^2) <= 0.1^2) &&\n                                (t >= 1.1), 5., 0.)\n\n\nusing LinearAlgebra, SparseArrays\ndu = ones(N-1)\nD2 = spdiagm(-1 => du, 0=>fill(-2.0, N), 1 => du)\nD2[1, N] = D2[N, 1] = 1\nD2 = 1/step(xyd_brusselator)^2*D2\ntmp = Matrix{Float64}(undef, N, N)\nfunction brusselator_2d_op(du, u, (D2, tmp, p), t)\n    A, B, α, xyd = p\n    dx = step(xyd)\n    N = length(xyd)\n    α = α/dx^2\n    du = reshape(du, N, N, 2)\n    u = reshape(u, N, N, 2)\n    @views for i in axes(u, 3)\n        ui = u[:, :, i]\n        dui = du[:, :, i]\n        mul!(tmp, D2, ui)\n        mul!(dui, ui, D2')\n        dui .+= tmp\n    end\n\n    @inbounds begin\n        for I in CartesianIndices((N, N))\n            x = xyd[I[1]]\n            y = xyd[I[2]]\n            i = I[1]\n            j = I[2]\n\n            du[i,j,1] = α*du[i,j,1] + B + u[i,j,1]^2*u[i,j,2] - (A + 1)*u[i,j,1] + brusselator_f(x, y, t)\n            du[i,j,2] = α*du[i,j,2] + A*u[i,j,1] - u[i,j,1]^2*u[i,j,2]\n        end\n    end\n    nothing\nend\n\nprob1 = ODEProblem(brusselator_2d_op, u0, tspan, (D2, tmp, p))\n\nsol1 = @time solve(prob1, TRBDF2(autodiff=false));","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"9.267829 seconds (8.02 M allocations: 575.955 MiB, 0.94% gc time)\nretcode: Success\nInterpolation: 3rd order Hermite\nt: 79-element Array{Float64,1}:\n  0.0\n  1.0522804268928948e-10\n  1.1575084695821841e-9\n  1.1680312738511129e-8\n  1.1690835542780058e-7\n  1.169188782320695e-6\n  1.1691993051249639e-5\n  3.96415424995973e-5\n  0.0001251040827040069\n  0.00037992550155953065\n  ⋮\n 18.252302769116575\n 18.556761040654674\n 19.073892463800625\n 19.428284008927427\n 20.09879123998184\n 20.480538570171507\n 20.999444301927937\n 21.403330440737882\n 22.0\nu: 79-element Array{Array{Float64,1},1}:\n [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  2.5250877095783344, \n2.2620667554742258, 1.9735248771761977, 1.665005111992191, 1.34336401668221\n03, 1.0172186542655526, 0.6977464117458191, 0.4003323380813969, 0.148922584\n53196738, 0.0]\n [0.00011790503536898665, 0.00011790503536909906, 0.00011790503536928888, 0\n.00011790503536951345, 0.0001179050353697547, 0.00011790503537000097, 0.000\n11790503537024383, 0.00011790503537047684, 0.00011790503537069474, 0.000117\n90503537089335  …  2.5250585327638797, 2.262041954652914, 1.973505463224665\n6, 1.6649923614746842, 1.3433596406307873, 1.0172251412113864, 0.6977678519\n884, 0.4003770605722655, 0.14902217713448462, 0.000144701505282153]\n [0.0012949971428852717, 0.0012949971428992155, 0.001294997142922781, 0.001\n2949971429507092, 0.0012949971429807212, 0.0012949971430113658, 0.001294997\n1430415896, 0.0012949971430705825, 0.001294997143097699, 0.0012949971431224\n178  …  2.52476680944311, 2.2617940004952306, 1.973311391982252, 1.66486494\n7832933, 1.343316013313132, 1.0172902298879962, 0.6979827036906551, 0.40082\n59597669359, 0.15001758272059923, 0.0015893132679671673]\n [0.012876383252354838, 0.012876383254089876, 0.012876383257051385, 0.01287\n6383260614965, 0.012876383264461243, 0.012876383268395485, 0.01287638327227\n9336, 0.012876383276007026, 0.01287638327949474, 0.012876383282674856  …  2\n.5218540714350746, 2.2593198858887353, 1.971377545998155, 1.663600045556335\n, 1.3428932614037994, 1.0179637350768072, 0.7001796234851249, 0.40546907561\n279366, 0.159920626066569, 0.015802820975871525]\n [0.11431809668801969, 0.11431809701540827, 0.11431809761055266, 0.11431809\n838668756, 0.11431809926467854, 0.1143181001852524, 0.11431810110619822, 0.\n1143181019968641, 0.1143181028341037, 0.11431810359985839  …  2.49319122864\n72744, 2.2351481567086453, 1.9527784378871984, 1.6519892724152478, 1.340282\n573226162, 1.0275217594291501, 0.7274071832384641, 0.4600255371073474, 0.25\n403236055497325, 0.14029945313886596]\n [0.6824546276302552, 0.6824546576303283, 0.6824547160548516, 0.68245479982\n66596, 0.6824549045779489, 0.6824550250157978, 0.6824551553829176, 0.682455\n2898965248, 0.6824554230873283, 0.6824555500182544  …  2.2673901444639477, \n2.0670335967015725, 1.856281803467327, 1.6433610322349588, 1.43773260755362\n28, 1.249622628038894, 1.089014709165961, 0.964086299638045, 0.879715279699\n5076, 0.8375618491417234]\n [1.6813894581935167, 1.6813894979141795, 1.6813895760496735, 1.68138969005\n22025, 1.6813898362183566, 1.6813900097580707, 1.681390204842709, 1.6813904\n14668493, 1.6813906315812168, 1.681390847292351  …  1.8814741145279639, 1.9\n062408314582533, 1.932556304652824, 1.9593615779722884, 1.9854302030584638,\n 2.009456254944375, 2.030184671316311, 2.0465572620802512, 2.05782082872771\n7, 2.0635421902068396]\n [1.5465563234604633, 1.5465563151032578, 1.546556298667805, 1.546556274705\n925, 1.5465562440308058, 1.5465562077004953, 1.5465561669954782, 1.54655612\n33881666, 1.5465560785018047, 1.546556034057256  …  1.9340770272586247, 1.9\n289445685108866, 1.9236144878920916, 1.918294922809417, 1.9132050182112592,\n 1.90856340239867, 1.9045749934046978, 1.9014179583244304, 1.89923295644000\n23, 1.8981161877601427]\n [1.5715361948410418, 1.5715361953311315, 1.57153619629489, 1.5715361976997\n826, 1.5715361994977792, 1.571536201626338, 1.571536204009821, 1.5715362065\n614462, 1.5715362091858556, 1.5715362117823382  …  1.9247785400997206, 1.92\n53926733129951, 1.926022344707277, 1.926643291184795, 1.9272311943883393, 1\n.9277626997857489, 1.9282164458524176, 1.9285740360607109, 1.92882088655398\n73, 1.9289468947014914]\n [1.5684925853534752, 1.5684925853540483, 1.5684925853552447, 1.56849258535\n7125, 1.5684925853597242, 1.5684925853630174, 1.5684925853669094, 1.5684925\n853712433, 1.5684925853758194, 1.5684925853804146  …  1.9259264057842067, 1\n.9258966605641663, 1.9258662870639163, 1.9258364529304535, 1.92580831012103\n66, 1.925782949722734, 1.9257613584940534, 1.9257443790768893, 1.9257326756\n936477, 1.925726706942093]\n ⋮\n [3.519620884001627, 3.5196209320997647, 3.5196209820910895, 3.519621032110\n1122, 3.5196210801507464, 3.5196211241431548, 3.5196211620586335, 3.5196211\n92036574, 3.5196212125280093, 3.5196212224289765  …  0.9122143221397975, 0.\n9122143221401331, 0.9122143221409135, 0.912214322140921, 0.9122143221408562\n, 0.9122143221405419, 0.9122143221403283, 0.9122143221397983, 0.91221432213\n941, 0.9122143221386628]\n [2.6927687450844022, 2.692768793182424, 2.692768843173625, 2.6927688931925\n88, 2.6927689412331732, 2.6927689852255514, 2.692769023140844, 2.6927690531\n18851, 2.692769073610191, 2.692769083511124  …  1.1449286955907596, 1.14492\n86955911178, 1.1449286955915916, 1.1449286955916638, 1.1449286955916267, 1.\n1449286955914064, 1.1449286955911533, 1.144928695590697, 1.1449286955902385\n, 1.1449286955895766]\n [1.6638910873620831, 1.663891135459961, 1.663891185450922, 1.6638912354696\n964, 1.6638912835102115, 1.6638913275024467, 1.6638913654175496, 1.66389139\n53954915, 1.6638914158866707, 1.6638914257875743  …  1.6489243165014276, 1.\n6489243165018714, 1.6489243165020488, 1.648924316502046, 1.6489243165021266\n, 1.6489243165019023, 1.6489243165019143, 1.6489243165013963, 1.64892431650\n0767, 1.6489243165002527]\n [1.1678842944971668, 1.1678843425948444, 1.1678843925856235, 1.16788444260\n42179, 1.1678844906445345, 1.1678845346366145, 1.1678845725515745, 1.167884\n602529421, 1.1678846230205415, 1.1678846329214068  …  2.0516734038388442, 2\n.0516734038391453, 2.0516734038392626, 2.0516734038392577, 2.05167340383931\n45, 2.0516734038391613, 2.0516734038391777, 2.0516734038388256, 2.051673403\n8383984, 2.0516734038380546]\n [0.6069466972096277, 0.6069467453083509, 0.6069467952970033, 0.60694684531\n44846, 0.6069468933526092, 0.6069469373461568, 0.6069469752616932, 0.606947\n00523755, 0.606947025727838, 0.6069470356287272  …  2.7995778606854413, 2.7\n995778606865453, 2.799577860686138, 2.799577860686269, 2.799577860686521, 2\n.7995778606861785, 2.7995778606871626, 2.799577860686091, 2.799577860687871\n, 2.799577860687257]\n [0.47215555277672316, 0.4721556008742116, 0.47215565086411865, 0.472155700\n88207404, 0.4721557489214685, 0.4721557929135511, 0.4721558308283381, 0.472\n15586080552696, 0.4721558812963327, 0.47215589119712137  …  3.1676671971764\n154, 3.16766719717659, 3.167667197176464, 3.1676671971764727, 3.16766719717\n6529, 3.1676671971764807, 3.167667197176733, 3.1676671971765695, 3.16766719\n71770274, 3.1676671971769923]\n [0.4055628704418776, 0.4055629185389692, 0.405562968529316, 0.405563018547\n4488, 0.40556306658728697, 0.4055631105788928, 0.4055631484934412, 0.405563\n1784710878, 0.4055631989620743, 0.40556320886283254  …  3.603368151456505, \n3.603368151456402, 3.6033681514563685, 3.6033681514563423, 3.60336815145633\n8, 3.6033681514563765, 3.6033681514563987, 3.603368151456506, 3.60336815145\n6546, 3.6033681514566753]\n [0.3995929112700888, 0.3995929593673295, 0.39959300935761466, 0.3995930593\n7575146, 0.39959310741552356, 0.39959315140729207, 0.39959318932193655, 0.3\n995932192994949, 0.3995932397904544, 0.39959324969122934  …  3.910174923881\n8027, 3.9101749238817978, 3.9101749238817582, 3.91017492388175, 3.910174923\n881759, 3.910174923881765, 3.9101749238818266, 3.910174923881835, 3.9101749\n238819465, 3.910174923881991]\n [0.42180482514855694, 0.42180487324580856, 0.421804923236389, 0.4218049732\n5473093, 0.42180502129478975, 0.4218050652865224, 0.42180510320119247, 0.42\n18051331789871, 0.4218051536700632, 0.4218051635708545  …  4.32769488090108\n9, 4.327694880901067, 4.327694880901113, 4.3276948809011175, 4.327694880901\n103, 4.327694880901107, 4.327694880901029, 4.327694880901046, 4.32769488090\n09035, 4.327694880900876]","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Visualizing the solution (works best in a terminal):","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"\n@gif for t in sol1.t[1]:0.1:sol1.t[end]\n    off = N^2\n    solt = sol1(t)\n    plt1 = surface(reshape(solt[1:off], N, N), zlims=(0, 5), leg=false)\n    surface!(plt1, reshape(solt[off+1:end], N, N), zlims=(0, 5), leg=false)\n    display(plt1)\nend","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-2:-Optimizing-the-BRUSS-Code","page":"SciML Workshop Exercise Solutions","title":"Part 2: Optimizing the BRUSS Code","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function brusselator_2d_loop(du, u, p, t)\n    A, B, α, xyd = p\n    dx = step(xyd)\n    N = length(xyd)\n    α = α/dx^2\n    limit = a -> let N=N\n        a == N+1 ? 1 :\n        a == 0 ? N :\n        a\n    end\n    II = LinearIndices((N, N, 2))\n\n    @inbounds begin\n        for I in CartesianIndices((N, N))\n            x = xyd[I[1]]\n            y = xyd[I[2]]\n            i = I[1]\n            j = I[2]\n            ip1 = limit(i+1)\n            im1 = limit(i-1)\n            jp1 = limit(j+1)\n            jm1 = limit(j-1)\n\n            ii1 = II[i,j,1]\n            ii2 = II[i,j,2]\n\n            du[II[i,j,1]] = α*(u[II[im1,j,1]] + u[II[ip1,j,1]] + u[II[i,jp1,1]] + u[II[i,jm1,1]] - 4u[ii1]) +\n            B + u[ii1]^2*u[ii2] - (A + 1)*u[ii1] + brusselator_f(x, y, t)\n\n            du[II[i,j,2]] = α*(u[II[im1,j,2]] + u[II[ip1,j,2]] + u[II[i,jp1,2]] + u[II[i,jm1,2]] - 4u[II[i,j,2]]) +\n            A*u[ii1] - u[ii1]^2*u[ii2]\n        end\n    end\n    nothing\nend\n\nprob2 = ODEProblem(brusselator_2d_loop, u0, tspan, p)\n\nsol2 = @time solve(prob2, TRBDF2())","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"8.669444 seconds (9.99 M allocations: 678.160 MiB, 0.52% gc time)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"sol2_2 = @time solve(prob2, CVODE_BDF())","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"35.178275 seconds (1.79 M allocations: 118.117 MiB)\nretcode: Success\nInterpolation: 3rd order Hermite\nt: 259-element Array{Float64,1}:\n  0.0\n  5.653338356947935e-11\n  5.65390369078363e-7\n  2.572950290187468e-6\n  4.580510211296573e-6\n  7.750405709122968e-6\n  1.4302881311757801e-5\n  4.0134710329210774e-5\n  6.596653934666375e-5\n  9.179836836411672e-5\n  ⋮\n 20.115148615356873\n 20.37146777739318\n 20.627786939429484\n 20.88410610146579\n 21.140425263502095\n 21.3967444255384\n 21.653063587574707\n 21.909382749611012\n 22.0\nu: 259-element Array{Array{Float64,1},1}:\n [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  2.5250877095783344, \n2.2620667554742258, 1.9735248771761977, 1.665005111992191, 1.34336401668221\n03, 1.0172186542655526, 0.6977464117458191, 0.4003323380813969, 0.148922584\n53196738, 0.0]\n [6.598117452446044e-8, 6.598117452452795e-8, 6.59811745246415e-8, 6.598117\n452477602e-8, 6.59811745249205e-8, 6.598117452506815e-8, 6.598117452521404e\n-8, 6.598117452535298e-8, 6.598117452548406e-8, 6.598117452560301e-8  …  2.\n52508769326683, 2.26206674160907, 1.9735248663224956, 1.6650051048635588, 1\n.3433640142351067, 1.0172186578909652, 0.6977464237297119, 0.40033236307490\n11, 0.1489226402117897, 8.090751419307918e-8]\n [0.0006587624140132232, 0.0006587624209141625, 0.0006587624326779875, 0.00\n06587624465990196, 0.000658762461542147, 0.000658762476747418, 0.0006587624\n918359335, 0.000658762506258849, 0.0006587625198234356, 0.00065876253213972\n14  …  2.524924606099231, 2.261928123190901, 1.9734163705350949, 1.66493387\n301444, 1.343339621372235, 1.0172550391384978, 0.697866520902045, 0.4005832\n5044085197, 0.14947914535482773, 0.0008077938023952315]\n [0.0029885797701746284, 0.002988579862875722, 0.002988580024412284, 0.0029\n885802153883506, 0.0029885804198764242, 0.002988580626391515, 0.00298858083\n42275124, 0.0029885810313851017, 0.0029885812191603584, 0.00298858138811432\n6  …  2.5243457007698074, 2.261436153310274, 1.9730314375969087, 1.66468138\n01159555, 1.3432536595673659, 1.0173853107174544, 0.6982952263862713, 0.401\n48198029752397, 0.1514529070863203, 0.003664729223250155]\n [0.005306141508030984, 0.005306142690205768, 0.005306142257972833, 0.00530\n6142797468204, 0.005306143401977575, 0.00530614493691719, 0.005306148087986\n683, 0.0053061452495214295, 0.005306149230355061, 0.005306149723653397  …  \n2.5237671078891086, 2.2609445550730123, 1.972646967738447, 1.66442950038285\n24, 1.3431685811161493, 1.0175170325180882, 0.698726972801953, 0.4023908498\n594301, 0.15342343126294944, 0.0065066953025461555]\n [0.008938531142281401, 0.00893853412998814, 0.008938533324753955, 0.008938\n534851373863, 0.008938536624027108, 0.008938540672423655, 0.008938548169476\n477, 0.00893854209409423, 0.008938551523646868, 0.008938552952542707  …  2.\n5228542226523203, 2.2601691664198333, 1.9720409392385245, 1.664033168895644\n7, 1.3430362416837864, 1.0177283298803772, 0.6994157785454703, 0.4038476392\n5678996, 0.15652765095572066, 0.010961135026978663]\n [0.016344145375892745, 0.016344150679504905, 0.016344153382255998, 0.01634\n4159160398462, 0.01634416578191356, 0.016344175003834897, 0.016344186710899\n49, 0.016344185944460035, 0.01634419915335025, 0.01634420450260158  …  2.52\n09699686322784, 2.2585696653032357, 1.9707923492854083, 1.6632194124484905,\n 1.3427706997876703, 1.0181786440181924, 0.7008691316897557, 0.406937430466\n94203, 0.16291636532495113, 0.020043247383951576]\n [0.04433812091521405, 0.04433815867165508, 0.04433820623536491, 0.04433827\n157330291, 0.044338347135081634, 0.044338431939997466, 0.044338515477739565\n, 0.04433857623295058, 0.044338655086562505, 0.04433871696545116  …  2.5135\n78240692516, 2.252307885072983, 1.9659255801385158, 1.66008673108698, 1.341\n8375910046947, 1.0201544536483305, 0.7070145269795118, 0.4198921130658216, \n0.18773948635125548, 0.054381120820077296]\n [0.07058737985116977, 0.07058664484029947, 0.0705875413280103, 0.070587855\n81917236, 0.0705879729541195, 0.070587289183245, 0.07058596349206522, 0.070\n58829612748044, 0.07058625771406031, 0.0705864535189533  …  2.5062449271565\n765, 2.2461167960972164, 1.961149034074087, 1.6570783972413137, 1.341096371\n9495257, 1.0224707341431893, 0.7138163912529947, 0.4338374639900661, 0.2119\n8260672435237, 0.08658995681881776]\n [0.09534502498283606, 0.09534358538038319, 0.09534532706763858, 0.09534608\n102785042, 0.09534625281411645, 0.09534489421692781, 0.09534277774807996, 0\n.0953468096914476, 0.09534337195439287, 0.09534381035303054  …  2.498970563\n5047277, 2.2399977238708053, 1.9564660515271148, 1.6542026515183286, 1.3405\n654586114462, 1.0251552440356688, 0.7212413308882024, 0.44843068771835926, \n0.23564736424496766, 0.1169787925933724]\n ⋮\n [0.6323810451914815, 0.632427052649651, 0.6324748742136165, 0.632522725663\n7151, 0.632568687588502, 0.6326107791949938, 0.6326470583214443, 0.63267574\n42982498, 0.6326953532738601, 0.632704828378052  …  2.770008193556327, 2.77\n0008208734769, 2.7700082189120816, 2.7700082237279133, 2.7700082230441634, \n2.7700082168913203, 2.7700082054620894, 2.770008189124797, 2.77000816842502\n84, 2.7700081440708226]\n [0.5226275087207661, 0.5226734342910327, 0.5227211719697351, 0.52276894073\n76451, 0.5228148244346382, 0.5228568454418254, 0.5228930645349704, 0.522921\n7036079294, 0.5229412808642269, 0.5229507408309406  …  3.0270587055167733, \n3.0270586753006343, 3.0270586550848355, 3.027058645472268, 3.02705864680864\n9, 3.027058659063031, 3.0270586818168277, 3.0270587143052663, 3.02705875544\n77606, 3.0270588038594153]\n [0.4579604087410305, 0.458006296802263, 0.4580539960946591, 0.458101726935\n9897, 0.45814757462705746, 0.458189563162972, 0.45822575460980086, 0.458254\n3720215345, 0.4582739347433197, 0.458283387662069  …  3.2613243481002447, 3\n.2613242970972784, 3.261324263504071, 3.2613242471006543, 3.261324249141863\n7, 3.261324269879769, 3.261324308306207, 3.2613243629016937, 3.261324432013\n5792, 3.2613245136746594]\n [0.4243249949117141, 0.4243708716334364, 0.4244185592849013, 0.42446627872\n460485, 0.42451211572444175, 0.42455409459691923, 0.42459027785523756, 0.42\n46188889172981, 0.42463844725967403, 0.42464789817336857  …  3.476979389713\n562, 3.4769793324322897, 3.476979294466571, 3.476979276125042, 3.4769792785\n14862, 3.476979301782493, 3.4769793449316233, 3.476979406359194, 3.47697948\n4132899, 3.4769795758778326]\n [0.4100847046913288, 0.4101305921364255, 0.4101782907401593, 0.41022602107\n792533, 0.41027186852471176, 0.4103138568061762, 0.41035004810598086, 0.410\n37866551793173, 0.4103982280350711, 0.4104076810589709  …  3.67907975182885\n67, 3.6790797004957008, 3.679079666185172, 3.679079649844482, 3.67907965210\n2726, 3.679079672926244, 3.679079711585095, 3.6790797667656774, 3.679079836\n642917, 3.679079918887027]\n [0.4073307682105559, 0.4073766856477378, 0.4074244149682815, 0.40747217562\n354593, 0.4075180518070638, 0.40756006601996625, 0.40759627938780474, 0.407\n62491406752893, 0.4076444882216691, 0.407653946842301  …  3.87153703747294,\n 3.8715370027640295, 3.8715369794090573, 3.871536968411483, 3.8715369700022\n073, 3.8715369840696034, 3.8715370102065285, 3.871537047588856, 3.871537094\n929266, 3.871537150541017]\n [0.4116592888096325, 0.41170525037260386, 0.4117530249037378, 0.4118008301\n185253, 0.41184674845518116, 0.41188880071685885, 0.4119250464392734, 0.411\n9537063944312, 0.41197329765271995, 0.4119827644270476  …  4.05641774845540\n05, 4.05641773820175, 4.056417731164946, 4.056417727958729, 4.0564177284843\n43, 4.056417732631651, 4.056417740353393, 4.056417751458394, 4.056417765516\n157, 4.056417781927513]\n [0.421178883717942, 0.42122490081186037, 0.42127273224506245, 0.4213205935\n2132606, 0.42136656486420737, 0.42140866497435914, 0.421444951375888, 0.421\n4736430958104, 0.42149325587312986, 0.4215027328817772  …  4.23412681426794\n4, 4.234126834790803, 4.234126848384466, 4.234126854951361, 4.2341268540976\n16, 4.234126845769279, 4.234126830318249, 4.234126808309182, 4.234126780420\n57, 4.234126747488131]\n [0.4255569709603833, 0.42560301293838904, 0.42565086989133055, 0.425698756\n25778114, 0.4257447512526154, 0.4257868727264482, 0.42582317727042507, 0.42\n585188312176897, 0.42587150553824715, 0.42588098706735406  …  4.29522520924\n0007, 4.295225243549162, 4.295225266516079, 4.295225277416021, 4.2952252758\n90809, 4.295225261987599, 4.295225236161456, 4.2952251992579855, 4.29522515\n2494508, 4.295225097441233]","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-3:-Exploiting-Jacobian-Sparsity-with-Color-Differentiation","page":"SciML Workshop Exercise Solutions","title":"Part 3: Exploiting Jacobian Sparsity with Color Differentiation","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"using SparseDiffTools, SparsityDetection\n\nsparsity_pattern = jacobian_sparsity(brusselator_2d_loop,similar(u0),u0,p,2.0)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Explored path: SparsityDetection.Path(Bool[], 1)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"jac_sp = sparse(sparsity_pattern)\njac = Float64.(jac_sp)\ncolors = matrix_colors(jac)\nprob3 = ODEProblem(ODEFunction(brusselator_2d_loop, colorvec=colors,jac_prototype=jac_sp), u0, tspan, p)\nsol3 = @time solve(prob3, TRBDF2())","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Error: InexactError: Bool(-38444.40000000001)","category":"page"},{"location":"exercises/02-workshop_solutions/#(Optional)-Part-4:-Structured-Jacobians","page":"SciML Workshop Exercise Solutions","title":"(Optional) Part 4: Structured Jacobians","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#(Optional)-Part-5:-Automatic-Symbolicification-and-Analytical-Jacobian","page":"SciML Workshop Exercise Solutions","title":"(Optional) Part 5: Automatic Symbolicification and Analytical Jacobian","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-6:-Utilizing-Preconditioned-GMRES-Linear-Solvers","page":"SciML Workshop Exercise Solutions","title":"Part 6: Utilizing Preconditioned-GMRES Linear Solvers","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"using DiffEqOperators\nusing Sundials\nusing AlgebraicMultigrid: ruge_stuben, aspreconditioner, smoothed_aggregation\nprob6 = ODEProblem(ODEFunction(brusselator_2d_loop, jac_prototype=JacVecOperator{Float64}(brusselator_2d_loop, u0)), u0, tspan, p)\nII = Matrix{Float64}(I, N, N)\nOp = kron(Matrix{Float64}(I, 2, 2), kron(D2, II) + kron(II, D2))\nWapprox = -I+Op\n#ml = ruge_stuben(Wapprox)\nml = smoothed_aggregation(Wapprox)\nprecond = aspreconditioner(ml)\nsol_trbdf2 = @time solve(prob6, TRBDF2(linsolve=LinSolveGMRES())); # no preconditioner","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"11.528428 seconds (12.99 M allocations: 4.895 GiB, 2.71% gc time)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"sol_trbdf2 = @time solve(prob6, TRBDF2(linsolve=LinSolveGMRES(Pl=lu(Wapprox)))); # sparse LU","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"3.489017 seconds (6.15 M allocations: 716.016 MiB, 1.73% gc time)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"sol_trbdf2 = @time solve(prob6, TRBDF2(linsolve=LinSolveGMRES(Pl=precond))); # AMG","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"3.107065 seconds (6.18 M allocations: 536.155 MiB, 2.83% gc time)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"sol_cvodebdf = @time solve(prob2, CVODE_BDF(linear_solver=:GMRES));","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"1.651483 seconds (1.90 M allocations: 204.526 MiB)\nretcode: Success\nInterpolation: 3rd order Hermite\nt: 1928-element Array{Float64,1}:\n  0.0\n  5.653338356947935e-11\n  5.65390369078363e-7\n  2.57289768832925e-6\n  4.5804050075801365e-6\n  7.750237020809387e-6\n  1.430297275427241e-5\n  3.947737124517274e-5\n  6.465176973607307e-5\n  8.982616822697341e-5\n  ⋮\n 21.74842347830861\n 21.75377749261479\n 21.770859233529922\n 21.787940974445053\n 21.800484442937336\n 21.813027911429618\n 21.844693963335253\n 21.950342098966686\n 22.0\nu: 1928-element Array{Array{Float64,1},1}:\n [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  2.5250877095783344, \n2.2620667554742258, 1.9735248771761977, 1.665005111992191, 1.34336401668221\n03, 1.0172186542655526, 0.6977464117458191, 0.4003323380813969, 0.148922584\n53196738, 0.0]\n [6.598117452445592e-8, 6.598117452452327e-8, 6.598117452463697e-8, 6.59811\n7452477148e-8, 6.598117452491596e-8, 6.598117452506346e-8, 6.59811745252089\n2e-8, 6.598117452534844e-8, 6.598117452547893e-8, 6.598117452559789e-8  …  \n2.52508769326683, 2.26206674160907, 1.9735248663224956, 1.6650051048635588,\n 1.3433640142351067, 1.0172186578909652, 0.6977464237297119, 0.400332363074\n9011, 0.1489226402117897, 8.090751419307378e-8]\n [0.0006587624172964451, 0.0006587624240399749, 0.0006587624354243716, 0.00\n06587624488920072, 0.0006587624633585051, 0.0006587624781271849, 0.00065876\n24926919035, 0.000658762506662457, 0.0006587625197283628, 0.000658762531638\n6175  …  2.5249246059817017, 2.2619281230446204, 1.973416370341658, 1.66493\n38727357148, 1.3433396209127182, 1.0172550381632066, 0.69786651676992, 0.40\n05832569059138, 0.14947914564976048, 0.0008077937954087897]\n [0.0029885190994651673, 0.0029885191897600113, 0.0029885193423737177, 0.00\n29885195232632685, 0.002988519717653178, 0.002988519916140473, 0.0029885201\n11906188, 0.002988520299697163, 0.0029885204753350315, 0.002988520635442596\n3  …  2.524345713343465, 2.261436162970071, 1.973031443407278, 1.6646813805\n594152, 1.343253651586457, 1.017385285060445, 0.698295128369312, 0.40148209\n36914462, 0.15145286366257169, 0.0036646545802277134]\n [0.005306022356073513, 0.005306022621712586, 0.0053060230717453995, 0.0053\n06023607201543, 0.005306024183137538, 0.005306024771435465, 0.0053060253517\n8454, 0.005306025908561257, 0.005306026429347995, 0.005306026904112427  …  \n2.5237671339498102, 2.260944575638989, 1.9726469809636227, 1.66442950338789\n62, 1.343168568455559, 1.0175169867522391, 0.6987268229191962, 0.4023910083\n0343055, 0.15342334401815053, 0.0065065496316772335]\n [0.00893834350995413, 0.00893834427987621, 0.00893834558850756, 0.00893834\n7153465821, 0.008938348839052852, 0.008938350561768801, 0.00893835226170432\n, 0.008938353892881468, 0.008938355418797277, 0.008938356809979058  …  2.52\n28542649298107, 2.2601692000771423, 1.9720409612790466, 1.66403317465477, 1\n.3430362221641639, 1.017728256881341, 0.6994155885173241, 0.403847823621840\n9, 0.15652751916175822, 0.01096090625912015]\n [0.01634429202116057, 0.01634429489952914, 0.016344299822335723, 0.0163443\n0576423857, 0.016344312182172048, 0.016344318748721217, 0.01634432523215556\n5, 0.01634433145550153, 0.01634433727856935, 0.016344342588309163  …  2.520\n9699337854867, 2.258569632374003, 1.970792317068139, 1.6632193768804995, 1.\n3427706450978134, 1.0181785268879573, 0.7008693575988351, 0.406937285311047\n1, 0.16291664462188093, 0.0200434281564615]\n [0.043646263363862924, 0.043646292669642976, 0.04364634410002619, 0.043646\n408299418085, 0.043646478690166544, 0.0436465511401205, 0.04364662287963492\n, 0.04364669185715508, 0.043646756468291935, 0.04364681542761546  …  2.5137\n65529699384, 2.2524662162038327, 1.96604803719552, 1.6601642835144645, 1.34\n18578790218518, 1.0201021423806298, 0.7068529962881926, 0.41955020644048985\n, 0.1871136496191611, 0.05353236358962729]\n [0.0692823968869293, 0.06928248583818256, 0.06928264396753456, 0.069282844\n55502629, 0.06928306665139533, 0.06928329638678168, 0.06928352441574115, 0.\n06928374395054913, 0.06928394975415433, 0.06928413765698549  …  2.506616550\n182622, 2.2464297079132223, 1.9613890075261213, 1.6572267432709649, 1.34112\n728871286, 1.0223507377796497, 0.7134630924575552, 0.43311194946272524, 0.2\n1076011686633297, 0.08498786962833081]\n [0.09349042837387436, 0.09349061562324566, 0.09349095207267255, 0.09349138\n44519549, 0.09349186761490513, 0.0934923699926786, 0.09349286998656095, 0.0\n9349335206219281, 0.09349380438256111, 0.09349421759820462  …  2.4995234731\n16373, 2.240461415578458, 1.956818523753225, 1.65441487227758, 1.3405970544\n326884, 1.0249482572805424, 0.720666723995856, 0.447302887948819, 0.2338561\n2858767357, 0.11470081104803237]\n ⋮\n [0.3797955575005551, 0.3798129120680182, 0.37983160912795294, 0.3798515167\n9769735, 0.3798700744173499, 0.3798877958739413, 0.37990413586835, 0.379917\n73881418767, 0.3799267950426437, 0.3799309569353526  …  3.4574052823485664,\n 3.4573936286619094, 3.457386402854468, 3.4573827565631308, 3.4573831040940\n81, 3.4573876418782974, 3.457395923872096, 3.4574086494131495, 3.4574240121\n578605, 3.4574420811420903]\n [0.37958401654816143, 0.3796201588394765, 0.37965786768047793, 0.379695834\n60132494, 0.3797327833587292, 0.379767041189448, 0.37979645035002474, 0.379\n81940648060253, 0.37983513643422023, 0.3798427397648622  …  3.4617077059990\n3, 3.4616995134797413, 3.4616938254044576, 3.4616910792093196, 3.4616914818\n578866, 3.4616948057305494, 3.46170100881632, 3.4617097544879343, 3.4617206\n586988303, 3.4617334162991207]\n [0.37898131515329514, 0.37904455623143324, 0.3791102395621268, 0.379171848\n92573214, 0.3792278014621423, 0.37927854226433344, 0.3793222968917526, 0.37\n935935408014265, 0.3793873038928219, 0.37940252613199893  …  3.475400682841\n286, 3.4754021781703925, 3.475405250938518, 3.4754068566952996, 3.475406283\n915746, 3.475404220521274, 3.475401075649539, 3.4754010132857456, 3.4754017\n445012275, 3.4754014416136703]\n [0.3784028728681648, 0.37847935063114085, 0.37855821248433963, 0.378635433\n8343628, 0.3787103744504435, 0.37877900390104313, 0.3788373625105384, 0.378\n88198986151156, 0.37891190751041437, 0.37892669234514176  …  3.489080362945\n1366, 3.489089294219412, 3.489094650501359, 3.489097497162135, 3.4890973438\n878747, 3.489093753047733, 3.489087808019096, 3.4890784385409153, 3.4890666\n40825046, 3.489052679244454]\n [0.37802806562457314, 0.3781081068261598, 0.37819023494543214, 0.378268702\n7300955, 0.37834355080180027, 0.37841307565234206, 0.37847181048385786, 0.3\n785172210264568, 0.37854884544138667, 0.3785659311574103  …  3.499071751303\n758, 3.4990834581052974, 3.4990920535881895, 3.499096339156102, 3.499095815\n52635, 3.4990905269259645, 3.49908103431579, 3.4990696874410214, 3.49905517\n5741332, 3.4990372237525125]\n [0.3776909382220414, 0.37776351115109563, 0.37783859475543263, 0.377912506\n00268866, 0.37798520447195416, 0.37805140767486484, 0.37810798564087067, 0.\n37815118643386414, 0.3781792196305945, 0.37819286030587723  …  3.5090277181\n657115, 3.5090394826004574, 3.5090464815977596, 3.509050187200965, 3.509049\n8417172786, 3.509045416275706, 3.5090377144093337, 3.509024825081179, 3.509\n0089285477553, 3.508989993790065]\n [0.3768537939605036, 0.376915458761548, 0.3769793531358606, 0.377042729545\n79915, 0.37710281438118, 0.3771570791988641, 0.37720388440231123, 0.3772415\n338113573, 0.37726733457251116, 0.3772798488606232  …  3.5341352486353617, \n3.5341466559569223, 3.534154680705109, 3.534158571433794, 3.534157981996896\n2, 3.5341533014526756, 3.5341445069751627, 3.534132413334222, 3.53411749417\n5883, 3.5340999041834755]\n [0.3740747443719409, 0.3741028206103584, 0.3741325900228058, 0.37416663902\n824293, 0.3742006984167679, 0.3742310255447786, 0.3742579572053362, 0.37427\n89270608717, 0.3742919258904212, 0.37429598291067795  …  3.6178769692717765\n, 3.6178851739555844, 3.617889139403817, 3.6178908996243493, 3.617890994937\n32, 3.617888791395569, 3.6178843129218543, 3.617874139997575, 3.61786105897\n74163, 3.617847139077364]\n [0.37278515952965974, 0.3728179321140629, 0.3728522412070423, 0.3728876482\n7093895, 0.37291708637372784, 0.37294295966405455, 0.37296625674297096, 0.3\n7298877738348996, 0.3730068685691214, 0.3730153360421533  …  3.657191327231\n621, 3.6571972377609487, 3.65720344716516, 3.6572059278358457, 3.6572051957\n615703, 3.6572021410971995, 3.6571953691210877, 3.657189705548747, 3.657182\n8565260756, 3.6571749711705777]","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-7:-Exploring-IMEX-and-Exponential-Integrator-Techniques-(E)","page":"SciML Workshop Exercise Solutions","title":"Part 7: Exploring IMEX and Exponential Integrator Techniques (E)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function laplacian2d(du, u, p, t)\n    A, B, α, xyd = p\n    dx = step(xyd)\n    N = length(xyd)\n    du = reshape(du, N, N, 2)\n    u = reshape(u, N, N, 2)\n    @inbounds begin\n        α = α/dx^2\n        limit = a -> let N=N\n            a == N+1 ? 1 :\n            a == 0 ? N :\n            a\n        end\n        for I in CartesianIndices((N, N))\n            x = xyd[I[1]]\n            y = xyd[I[2]]\n            i = I[1]\n            j = I[2]\n            ip1 = limit(i+1)\n            im1 = limit(i-1)\n            jp1 = limit(j+1)\n            jm1 = limit(j-1)\n            du[i,j,1] = α*(u[im1,j,1] + u[ip1,j,1] + u[i,jp1,1] + u[i,jm1,1] - 4u[i,j,1])\n            du[i,j,2] = α*(u[im1,j,2] + u[ip1,j,2] + u[i,jp1,2] + u[i,jm1,2] - 4u[i,j,2])\n        end\n    end\n    nothing\nend\nfunction brusselator_reaction(du, u, p, t)\n    A, B, α, xyd = p\n    dx = step(xyd)\n    N = length(xyd)\n    du = reshape(du, N, N, 2)\n    u = reshape(u, N, N, 2)\n    @inbounds begin\n        for I in CartesianIndices((N, N))\n            x = xyd[I[1]]\n            y = xyd[I[2]]\n            i = I[1]\n            j = I[2]\n            du[i,j,1] = B + u[i,j,1]^2*u[i,j,2] - (A + 1)*u[i,j,1] + brusselator_f(x, y, t)\n            du[i,j,2] = A*u[i,j,1] - u[i,j,1]^2*u[i,j,2]\n        end\n    end\n    nothing\nend\nprob7 = SplitODEProblem(laplacian2d, brusselator_reaction, u0, tspan, p)\nsol7 = @time solve(prob7, KenCarp4())","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"6.407620 seconds (11.98 M allocations: 783.753 MiB, 1.66% gc time)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"M = MatrixFreeOperator((du,u,p)->laplacian2d(du, u, p, 0), (p,), size=(2*N^2, 2*N^2), opnorm=1000)\nprob7_2 = SplitODEProblem(M, brusselator_reaction, u0, tspan, p)\nsol7_2 = @time solve(prob7_2, ETDRK4(krylov=true), dt=1)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"2.917810 seconds (8.83 M allocations: 560.794 MiB, 4.01% gc time)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"prob7_3 = SplitODEProblem(DiffEqArrayOperator(Op), brusselator_reaction, u0, tspan, p)\nsol7_3 = solve(prob7_3, KenCarp4());","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"retcode: Success\nInterpolation: 3rd order Hermite\nt: 411-element Array{Float64,1}:\n  0.0\n  2.888065882181688e-5\n  0.00031768724703998567\n  0.0027059840153272462\n  0.008731809471821457\n  0.02179419538626385\n  0.046044933347512154\n  0.08666612492700337\n  0.14668700100553306\n  0.2429330434920095\n  ⋮\n 21.642678211001897\n 21.669167858631038\n 21.69565750626018\n 21.745650901936376\n 21.842907495920542\n 21.862544058930474\n 21.883418684049154\n 21.924650607598824\n 22.0\nu: 411-element Array{Array{Float64,1},1}:\n [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  2.5250877095783344, \n2.2620667554742258, 1.9735248771761977, 1.665005111992191, 1.34336401668221\n03, 1.0172186542655526, 0.6977464117458191, 0.4003323380813969, 0.148922584\n53196738, 0.0]\n [0.00338181359279749, 0.003381814525055848, 0.0033818161026810765, 0.00338\n18179763281625, 0.0033818199908016255, 0.003381822048157553, 0.003381824077\n5272284, 0.0033818260243597817, 0.00338182784528272, 0.003381829505247768  \n…  2.524255066788988, 2.261359157113013, 1.9729712293922774, 1.664641937979\n7444, 1.3432403152050174, 1.0174058169618412, 0.6983623120712237, 0.4016217\n8277595556, 0.1517635265052733, 0.004115818959992079]\n [0.03568250376202336, 0.03568266931785142, 0.035682955832227074, 0.0356833\n0729754052, 0.03568368941345571, 0.03568408140938937, 0.03568446895364048, \n0.035684841242777064, 0.035685189766591796, 0.03568550768135772  …  2.51599\n73402014577, 2.2543598849568935, 1.967523764161279, 1.6611194391842758, 1.3\n421496263916268, 1.0195052150551678, 0.704979868148862, 0.4156649097840782,\n 0.17979934864987152, 0.04350153844352491]\n [0.2388870086712341, 0.23890840746265182, 0.23894852951279852, 0.239002926\n71217413, 0.23906668747399049, 0.23913531679710034, 0.23920518662122434, 0.\n2392735177564327, 0.2393382102869443, 0.23939766131788623  …  2.45177455071\n75612, 2.2013122441306154, 1.9285687665074842, 1.6402584486989873, 1.345213\n7788742935, 1.0552180035855303, 0.7857635817095209, 0.5558670473603251, 0.3\n8607263451905216, 0.29539374940409546]\n [0.5564106150796982, 0.5566108464330898, 0.5569986710045511, 0.55755022257\n69137, 0.5582336728011149, 0.5590119152749861, 0.559846526329856, 0.5606997\n95457231, 0.561537663173318, 0.5623298108904917  …  2.3212076996976343, 2.1\n072090690298686, 1.880355997024359, 1.6487387710243555, 1.4216785859442722,\n 1.2094079500272332, 1.0225411460886549, 0.8713229853793858, 0.764708535522\n895, 0.7095402391463423]\n [0.9342714734084758, 0.9349598918146564, 0.936310382519549, 0.938262165081\n3462, 0.9407415908113002, 0.9436441970638244, 0.9468551430516244, 0.9502481\n957941415, 0.9536902430916663, 0.957050094472094  …  2.1614414096004184, 2.\n027111451991201, 1.8887980771792972, 1.751800690784729, 1.6215018392791603,\n 1.5031551617020042, 1.4016704666279294, 1.321363816947498, 1.2657330373145\n712, 1.2372638912267229]\n [1.2566772231894945, 1.2576431810047317, 1.2595383902093107, 1.26229311347\n9925, 1.2658028435853461, 1.2699372640323565, 1.274540022703064, 1.27943691\n0349005, 1.2844410563581503, 1.2893600761202952  …  2.0368655159549163, 1.9\n851294449856716, 1.9322949399059546, 1.8803923426225904, 1.8314233258837715\n, 1.7872824916440149, 1.749687377223869, 1.7201110332114784, 1.699714353288\n5108, 1.689307976958115]\n [1.4173304157928486, 1.4178104626035777, 1.4187536323652747, 1.42012345899\n5461, 1.421869253600005, 1.4239236083651097, 1.4262077943444462, 1.42863463\n98967849, 1.4311109979822425, 1.4335434070534994  …  1.984707244631404, 1.9\n744843346627017, 1.9640642411192235, 1.9538390653254547, 1.9442016835060763\n, 1.9355229382392862, 1.9281377603979366, 1.9223312732585927, 1.91833313347\n7084, 1.9162957064303392]\n [1.4079292375651262, 1.4080181845337447, 1.4081926434529766, 1.40844579737\n3808, 1.40876792341743, 1.4091467072462807, 1.4095677840064875, 1.410015143\n058539, 1.410471755723265, 1.4109202040012978  …  2.006848717030137, 2.0058\n633341206855, 2.004859241773954, 2.003874429852624, 2.0029462538824254, 2.0\n02109807224481, 2.0013971225351015, 2.000835759821026, 2.000448425718132, 2\n.0002507800301195]\n [1.3008722049712922, 1.3008801828116636, 1.3008945778368928, 1.30091484490\n6319, 1.3009396166641172, 1.3009679104321659, 1.3009992327229458, 1.3010331\n324351492, 1.3010682282392434, 1.3011028322919374  …  2.084972574467494, 2.\n0849211490150776, 2.0848702925700606, 2.0848214163333547, 2.08477743413165,\n 2.084738198481765, 2.0847036216234702, 2.084673859207271, 2.08465246394274\n, 2.0846409823084646]\n ⋮\n [0.39890859367367754, 0.3993441673525077, 0.3997975806788334, 0.4002518902\n321085, 0.4006888182480096, 0.4010893923770546, 0.40143496888258334, 0.4017\n0842611233254, 0.401895469313635, 0.40198591841037423  …  3.974042467040040\n7, 3.9740400700975256, 3.974038463649698, 3.974037701900219, 3.974037809267\n5783, 3.9740387819095946, 3.974040587360848, 3.974043164462041, 3.974046422\n7965795, 3.974050246993257]\n [0.399359295339172, 0.39974889839511, 0.40014696627279867, 0.4005384174406\n543, 0.4009068845049872, 0.40123752344283037, 0.40151687180652956, 0.401733\n60655661844, 0.401879356549643, 0.4019484860747507  …  3.9932059688091033, \n3.9932038478068232, 3.9932024382289315, 3.9932017744025847, 3.9932018738678\n297, 3.99320272691542, 3.993204321872256, 3.993206602084878, 3.993209523141\n2905, 3.9932129859626735]\n [0.3993686665009743, 0.39980665253816694, 0.4002705836448292, 0.4007431063\n3130167, 0.40120406441906215, 0.4016317190585153, 0.4020041495019104, 0.402\n30097607591025, 0.40250515220793087, 0.4026046039165201  …  4.0122858125097\n78, 4.012284245475603, 4.012283191763723, 4.01228269079853, 4.0122827626693\n17, 4.012283404160809, 4.012284589905506, 4.012286273787084, 4.012288391829\n275, 4.012290860181647]\n [0.4010117037388889, 0.4014585319070676, 0.40192471908753297, 0.4023929107\n571625, 0.40284400510226775, 0.4032581888842881, 0.4036158867371329, 0.4038\n991410242888, 0.4040929782391569, 0.40418678544141134  …  4.048074184182981\n5, 4.048072793476128, 4.048071860809855, 4.0480714180078925, 4.048071480580\n622, 4.04807204591452, 4.048073094164494, 4.0480745886306035, 4.04807647493\n2387, 4.048078682581573]\n [0.4040391360250253, 0.4044781455356283, 0.40493508964458735, 0.4053928897\n130187, 0.40583313109968033, 0.4062367046948323, 0.4065848385324651, 0.4068\n602985846021, 0.40704869896301227, 0.40713979724380694  …  4.11688589803744\n4, 4.116885469878567, 4.116885180300814, 4.116885042860157, 4.1168850632805\n38, 4.1168852404840575, 4.116885566552351, 4.116886026211559, 4.11688659676\n3158, 4.116887250002496]\n [0.4047700956071005, 0.40519815829045214, 0.4056399542593235, 0.4060787935\n4982956, 0.40649646573647547, 0.4068752731237485, 0.4071985546331393, 0.407\n45169655229097, 0.40762327673507454, 0.4077054230583039  …  4.1306436987736\n2, 4.130643465603472, 4.130643313409505, 4.130643244570406, 4.1306432586828\n51, 4.130643353557858, 4.130643529891911, 4.130643781395985, 4.130644101166\n296, 4.130644470170689]\n [0.405168629966455, 0.4055798821600529, 0.40601390501288664, 0.40645506728\n755565, 0.4068852428751017, 0.4072847292800238, 0.4076332639179229, 0.40791\n16747690355, 0.40810359543776764, 0.40819724273804125  …  4.145219717875681\n, 4.145219791546891, 4.145219834102426, 4.14521985299266, 4.145219852795447\n, 4.145219832891524, 4.145219787681931, 4.145219708636722, 4.14521958516251\n4, 4.145219403944229]\n [0.40704121426682677, 0.40748978803601077, 0.4079566870477457, 0.408424669\n7332447, 0.40887498057174415, 0.4092881700600071, 0.40964487371286185, 0.40\n9927358248609, 0.4101206777465779, 0.41021423546960456  …  4.17385578570464\n1, 4.17385633196801, 4.173856695023444, 4.173856867186141, 4.17385684409214\n35, 4.173856625935988, 4.173856217791514, 4.173855628428838, 4.173854869192\n83, 4.173853955130709]\n [0.4104280757891703, 0.4108700639501849, 0.41132984460416, 0.4117903516752\n1066, 0.41223306465343723, 0.41263893115959094, 0.41298899290397084, 0.4132\n6603039541165, 0.4134554904299645, 0.4135471107118313  …  4.225664869407304\n, 4.225666277355228, 4.225667215715375, 4.22566766028349, 4.225667599839396\n, 4.225667035917906, 4.225665982952057, 4.225664468355488, 4.22566253340619\n55, 4.225660233615377]","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-8:-Work-Precision-Diagrams-for-Benchmarking-Solver-Choices","page":"SciML Workshop Exercise Solutions","title":"Part 8: Work-Precision Diagrams for Benchmarking Solver Choices","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"using DiffEqDevTools\nabstols = 0.1 .^ (5:8)\nreltols = 0.1 .^ (1:4)\nsol = solve(prob3,CVODE_BDF(linear_solver=:GMRES),abstol=1/10^7,reltol=1/10^10)\ntest_sol = TestSolution(sol)\nprobs = [prob2, prob3, prob6]\nsetups = [Dict(:alg=>CVODE_BDF(),:prob_choice => 1),\n          Dict(:alg=>CVODE_BDF(linear_solver=:GMRES), :prob_choice => 1),\n          Dict(:alg=>TRBDF2(), :prob_choice => 1),\n          Dict(:alg=>TRBDF2(linsolve=LinSolveGMRES(Pl=precond)), :prob_choice => 3),\n          Dict(:alg=>TRBDF2(), :prob_choice => 2)\n         ]\nlabels = [\"CVODE_BDF (dense)\" \"CVODE_BDF (GMRES)\" \"TRBDF2 (dense)\" \"TRBDF2 (sparse)\" \"TRBDF2 (GMRES)\"]\nwp = WorkPrecisionSet(probs,abstols,reltols,setups;appxsol=[test_sol,test_sol,test_sol],save_everystep=false,numruns=3,\n  names=labels, print_names=true, seconds=0.5)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"CVODE_BDF (dense)\nCVODE_BDF (GMRES)\nTRBDF2 (dense)\nTRBDF2 (sparse)\nTRBDF2 (GMRES)\nError: InexactError: Bool(-38444.40000000001)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"plot(wp)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Error: UndefVarError: wp not defined","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-9:-GPU-Parallelism-for-PDEs-(E)","page":"SciML Workshop Exercise Solutions","title":"Part 9: GPU-Parallelism for PDEs (E)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-10:-Adjoint-Sensitivity-Analysis-for-Gradients-of-PDEs","page":"SciML Workshop Exercise Solutions","title":"Part 10: Adjoint Sensitivity Analysis for Gradients of PDEs","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Problem-5:-Global-Parameter-Sensitivity-and-Optimality-with-GPU-and-Distributed-Ensembles-(B)","page":"SciML Workshop Exercise Solutions","title":"Problem 5: Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-1:-Implementing-the-Henon-Heiles-System-(B)","page":"SciML Workshop Exercise Solutions","title":"Part 1: Implementing the Henon-Heiles System (B)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function henon(dz,z,p,t)\n  p₁, p₂, q₁, q₂ = z[1], z[2], z[3], z[4]\n  dp₁ = -q₁*(1 + 2q₂)\n  dp₂ = -q₂-(q₁^2 - q₂^2)\n  dq₁ = p₁\n  dq₂ = p₂\n\n  dz .= [dp₁, dp₂, dq₁, dq₂]\n  return nothing\nend\n\nu₀ = [0.1, 0.0, 0.0, 0.5]\nprob = ODEProblem(henon, u₀, (0., 1000.))\nsol = solve(prob, Vern9(), abstol=1e-14, reltol=1e-14)\n\nplot(sol, vars=[(3,4,1)], tspan=(0,100))","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/#(Optional)-Part-2:-Alternative-Dynamical-Implmentations-of-Henon-Heiles-(B)","page":"SciML Workshop Exercise Solutions","title":"(Optional) Part 2: Alternative Dynamical Implmentations of Henon-Heiles (B)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function henon(ddz,dz,z,p,t)\n  p₁, p₂ = dz[1], dz[2]\n  q₁, q₂ = z[1], z[2]\n  ddq₁ = -q₁*(1 + 2q₂)\n  ddq₂ = -q₂-(q₁^2 - q₂^2)\n\n  ddz .= [ddq₁, ddq₂]\nend\n\np₀ = u₀[1:2]\nq₀ = u₀[3:4]\nprob2 = SecondOrderODEProblem(henon, p₀, q₀, (0., 1000.))\nsol = solve(prob2, DPRKN6(), abstol=1e-10, reltol=1e-10)\n\nplot(sol, vars=[(3,4)], tspan=(0,100))\n\nH(p, q, params) = 1/2 * (p[1]^2 + p[2]^2) + 1/2 * (q[1]^2 + q[2]^2 + 2q[1]^2 * q[2] - 2/3*q[2]^3)\n\nprob3 = HamiltonianProblem(H, p₀, q₀, (0., 1000.))\nsol = solve(prob3, DPRKN6(), abstol=1e-10, reltol=1e-10)\n\nplot(sol, vars=[(3,4)], tspan=(0,100))","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-3:-Parallelized-Ensemble-Solving","page":"SciML Workshop Exercise Solutions","title":"Part 3: Parallelized Ensemble Solving","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"In order to solve with an ensamble we need some initial conditions.","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function generate_ics(E,n)\n  # The hardcoded values bellow can be estimated by looking at the\n  # figures in the Henon-Heiles 1964 article\n  qrange = range(-0.4, stop = 1.0, length = n)\n  prange = range(-0.5, stop = 0.5, length = n)\n  z0 = Vector{Vector{typeof(E)}}()\n  for q in qrange\n    V = H([0,0],[0,q],nothing)\n    V ≥ E && continue\n    for p in prange\n      T = 1/2*p^2\n      T + V ≥ E && continue\n      z = [√(2(E-V-T)), p, 0, q]\n      push!(z0, z)\n    end\n  end\n  return z0\nend\n\nz0 = generate_ics(0.125, 10)\n\nfunction prob_func(prob,i,repeat)\n  @. prob.u0 = z0[i]\n  prob\nend\n\nensprob = EnsembleProblem(prob, prob_func=prob_func)\nsim = solve(ensprob, Vern9(), EnsembleThreads(), trajectories=length(z0))\n\nplot(sim, vars=(3,4), tspan=(0,10))","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-4:-Parallelized-GPU-Ensemble-Solving","page":"SciML Workshop Exercise Solutions","title":"Part 4: Parallelized GPU Ensemble Solving","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"In order to use GPU parallelization we must make all inputs (initial conditions, tspan, etc.) Float32 and the function definition should be in the in-place form, avoid bound checking and return nothing.","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"using DiffEqGPU\n\nfunction henon_gpu(dz,z,p,t)\n  @inbounds begin\n    dz[1] = -z[3]*(1 + 2z[4])\n    dz[2] = -z[4]-(z[3]^2 - z[4]^2)\n    dz[3] = z[1]\n    dz[4] = z[2]\n  end\n  return nothing\nend\n\nz0 = generate_ics(0.125f0, 50)\nprob_gpu = ODEProblem(henon_gpu, Float32.(u₀), (0.f0, 1000.f0))\nensprob = EnsembleProblem(prob_gpu, prob_func=prob_func)\nsim = solve(ensprob, Tsit5(), EnsembleGPUArray(), trajectories=length(z0))","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"EnsembleSolution Solution of length 1440 with uType:\nDiffEqBase.ODESolution{Float32,2,Array{SubArray{Float32,1,Array{Float32,2},\nTuple{Base.Slice{Base.OneTo{Int64}},Int64},true},1},Nothing,Nothing,Array{F\nloat32,1},Nothing,DiffEqBase.ODEProblem{Array{Float32,1},Tuple{Float32,Floa\nt32},true,DiffEqBase.NullParameters,DiffEqBase.ODEFunction{true,typeof(Main\n.##WeaveSandBox#2247.henon_gpu),LinearAlgebra.UniformScaling{Bool},Nothing,\nNothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Not\nhing,Nothing},Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tu\nple{}}},DiffEqBase.StandardODEProblem},OrdinaryDiffEq.Tsit5,DiffEqBase.Line\narInterpolation{Array{Float32,1},Array{SubArray{Float32,1,Array{Float32,2},\nTuple{Base.Slice{Base.OneTo{Int64}},Int64},true},1}},DiffEqBase.DEStats}","category":"page"},{"location":"exercises/02-workshop_solutions/#Problem-6:-Training-Neural-Stochastic-Differential-Equations-with-GPU-acceleration-(I)","page":"SciML Workshop Exercise Solutions","title":"Problem 6: Training Neural Stochastic Differential Equations with GPU acceleration (I)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-1:-Constructing-and-Training-a-Basic-Neural-ODE","page":"SciML Workshop Exercise Solutions","title":"Part 1: Constructing and Training a Basic Neural ODE","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-2:-GPU-accelerating-the-Neural-ODE-Process","page":"SciML Workshop Exercise Solutions","title":"Part 2: GPU-accelerating the Neural ODE Process","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-3:-Defining-and-Training-a-Mixed-Neural-ODE","page":"SciML Workshop Exercise Solutions","title":"Part 3: Defining and Training a Mixed Neural ODE","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-4:-Constructing-a-Basic-Neural-SDE","page":"SciML Workshop Exercise Solutions","title":"Part 4: Constructing a Basic Neural SDE","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-5:-Optimizing-the-training-behavior-with-minibatching-(E)","page":"SciML Workshop Exercise Solutions","title":"Part 5: Optimizing the training behavior with minibatching (E)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Information-on-the-Build","page":"SciML Workshop Exercise Solutions","title":"Information on the Build","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Appendix","page":"SciML Workshop Exercise Solutions","title":"Appendix","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"This tutorial is part of the SciMLTutorials.jl repository, found at: https://github.com/SciMLTutorials/SciMLTutorials.jl.  For more information on doing scientific machine learning (SciML) with open source software, check out https://sciml.ai/.","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"exercises\",\"02-workshop_solutions.jmd\")","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Computer Information:","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Julia Version 1.4.2\nCommit 44fa15b150* (2020-05-23 18:35 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Core(TM) i7-9700K CPU @ 3.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-8.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_LOAD_PATH = /builds/JuliaGPU/DiffEqTutorials.jl:\n  JULIA_DEPOT_PATH = /builds/JuliaGPU/DiffEqTutorials.jl/.julia\n  JULIA_CUDA_MEMORY_LIMIT = 2147483648\n  JULIA_NUM_THREADS = 8\n","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Package Information:","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Status `/builds/JuliaGPU/DiffEqTutorials.jl/tutorials/exercises/Project.toml`\n[2169fc97-5a83-5252-b627-83903c6c433c] AlgebraicMultigrid 0.3.0\n[6e4b80f9-dd63-53aa-95a3-0cdb28fa8baf] BenchmarkTools 0.5.0\n[f3b72e0c-5b89-59e1-b016-84e28bfd966d] DiffEqDevTools 2.24.0\n[aae7a2af-3d4f-5e19-a356-7da93b79d9d0] DiffEqFlux 1.17.0\n[071ae1c0-96b5-11e9-1965-c90190d839ea] DiffEqGPU 1.3.0\n[9fdde737-9c7f-55bf-ade8-46b3f136cc48] DiffEqOperators 4.10.0\n[0c46a032-eb83-5123-abaf-570d42b7fbaa] DifferentialEquations 6.15.0\n[587475ba-b771-5e3f-ad9e-33799f191a9c] Flux 0.10.4\n[429524aa-4258-5aef-a3af-852621145aeb] Optim 0.22.0\n[91a5bcdd-55d7-5caf-9e0b-520d859cae80] Plots 1.5.6\n[47a9eef4-7e08-11e9-0b38-333d64bd3804] SparseDiffTools 1.9.1\n[684fba80-ace3-11e9-3d08-3bc7ed6f96df] SparsityDetection 0.3.3\n[c3572dad-4567-51f8-b174-8c6c989267f4] Sundials 4.2.5","category":"page"},{"location":"models/01-classical_physics/#Classical-Physics-Models","page":"Classical Physics Models","title":"Classical Physics Models","text":"","category":"section"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"If you're getting some cold feet to jump in to DiffEq land, here are some handcrafted differential equations mini problems to hold your hand along the beginning of your journey.","category":"page"},{"location":"models/01-classical_physics/#First-order-linear-ODE","page":"Classical Physics Models","title":"First order linear ODE","text":"","category":"section"},{"location":"models/01-classical_physics/#Radioactive-Decay-of-Carbon-14","page":"Classical Physics Models","title":"Radioactive Decay of Carbon-14","text":"","category":"section"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"f(tu) = fracdudt","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"The Radioactive decay problem is the first order linear ODE problem of an exponential with a negative coefficient, which represents the half-life of the process in question. Should the coefficient be positive, this would represent a population growth equation.","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"using OrdinaryDiffEq, Plots\ngr()\n\n#Half-life of Carbon-14 is 5,730 years.\nC₁ = 5.730\n\n#Setup\nu₀ = 1.0\ntspan = (0.0, 1.0)\n\n#Define the problem\nradioactivedecay(u,p,t) = -C₁*u\n\n#Pass to solver\nprob = ODEProblem(radioactivedecay,u₀,tspan)\nsol = solve(prob,Tsit5())\n\n#Plot\nplot(sol,linewidth=2,title =\"Carbon-14 half-life\", xaxis = \"Time in thousands of years\", yaxis = \"Percentage left\", label = \"Numerical Solution\")\nplot!(sol.t, t->exp(-C₁*t),lw=3,ls=:dash,label=\"Analytical Solution\")","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"(Image: )","category":"page"},{"location":"models/01-classical_physics/#Second-Order-Linear-ODE","page":"Classical Physics Models","title":"Second Order Linear ODE","text":"","category":"section"},{"location":"models/01-classical_physics/#Simple-Harmonic-Oscillator","page":"Classical Physics Models","title":"Simple Harmonic Oscillator","text":"","category":"section"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Another classical example is the harmonic oscillator, given by $ \\ddot{x} + \\omega^2 x = 0 $ with the known analytical solution $ \\begin{align} x(t) &= A\\cos(\\omega t - \\phi) \\\nv(t) &= -A\\omega\\sin(\\omega t - \\phi), \\end{align} $ where $ A = \\sqrt{c1 + c2} \\qquad\\text{and}\\qquad \\tan \\phi = \\frac{c2}{c1} $ with c_1 c_2 constants determined by the initial conditions such that c_1 is the initial position and omega c_2 is the initial velocity.","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Instead of transforming this to a system of ODEs to solve with ODEProblem, we can use SecondOrderODEProblem as follows.","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"# Simple Harmonic Oscillator Problem\nusing OrdinaryDiffEq, Plots\n\n#Parameters\nω = 1\n\n#Initial Conditions\nx₀ = [0.0]\ndx₀ = [π/2]\ntspan = (0.0, 2π)\n\nϕ = atan((dx₀[1]/ω)/x₀[1])\nA = √(x₀[1]^2 + dx₀[1]^2)\n\n#Define the problem\nfunction harmonicoscillator(ddu,du,u,ω,t)\n    ddu .= -ω^2 * u\nend\n\n#Pass to solvers\nprob = SecondOrderODEProblem(harmonicoscillator, dx₀, x₀, tspan, ω)\nsol = solve(prob, DPRKN6())\n\n#Plot\nplot(sol, vars=[2,1], linewidth=2, title =\"Simple Harmonic Oscillator\", xaxis = \"Time\", yaxis = \"Elongation\", label = [\"x\" \"dx\"])\nplot!(t->A*cos(ω*t-ϕ), lw=3, ls=:dash, label=\"Analytical Solution x\")\nplot!(t->-A*ω*sin(ω*t-ϕ), lw=3, ls=:dash, label=\"Analytical Solution dx\")","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"(Image: )","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Note that the order of the variables (and initial conditions) is dx, x. Thus, if we want the first series to be x, we have to flip the order with vars=[2,1].","category":"page"},{"location":"models/01-classical_physics/#Second-Order-Non-linear-ODE","page":"Classical Physics Models","title":"Second Order Non-linear ODE","text":"","category":"section"},{"location":"models/01-classical_physics/#Simple-Pendulum","page":"Classical Physics Models","title":"Simple Pendulum","text":"","category":"section"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"We will start by solving the pendulum problem. In the physics class, we often solve this problem by small angle approximation, i.e. $ sin(\\theta) \\approx \\theta$, because otherwise, we get an elliptic integral which doesn't have an analytic solution. The linearized form is","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"ddottheta + fracgLtheta = 0","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"But we have numerical ODE solvers! Why not solve the real pendulum?","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"ddottheta + fracgLsin(theta) = 0","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Notice that now we have a second order ODE. In order to use the same method as above, we nee to transform it into a system of first order ODEs by employing the notation dtheta = dottheta.","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"\nbeginalign*\ndottheta = dtheta \ndotdtheta = - fracgLsin(theta)\nendalign*\n\n\njulia\n Simple Pendulum Problem\nusing OrdinaryDiffEq Plots\n\nConstants\nconst g = 981\nL = 10\n\nInitial Conditions\nu₀ = 0π2\ntspan = (0063)\n\nDefine the problem\nfunction simplependulum(duupt)\n    θ = u1\n    dθ = u2\n    du1 = dθ\n    du2 = -(gL)*sin(θ)\nend\n\nPass to solvers\nprob = ODEProblem(simplependulum u₀ tspan)\nsol = solve(probTsit5())\n\nPlot\nplot(sollinewidth=2title =Simple Pendulum Problem xaxis = Time yaxis = Height label = theta dtheta)\n\n\n(figures01-classical_physics_3_1png)\n\n\n\nSo now we know that behaviour of the position versus time However it will be useful to us to look at the phase space of the pendulum ie and representation of all possible states of the system in question (the pendulum) by looking at its velocity and position Phase space analysis is ubiquitous in the analysis of dynamical systems and thus we will provide a few facilities for it\n\njulia\np = plot(solvars = (12) xlims = (-99) title = Phase Space Plot xaxis = Velocity yaxis = Position leg=false)\nfunction phase_plot(prob u0 p tspan=2pi)\n    _prob = ODEProblem(probfu0(00tspan))\n    sol = solve(_probVern9())  Use Vern9 solver for higher accuracy\n    plot(psolvars = (12) xlims = nothing ylims = nothing)\nend\nfor i in -4pipi24π\n    for j in -4pipi24π\n        phase_plot(prob ji p)\n    end\nend\nplot(pxlims = (-99))\n\n\n(figures01-classical_physics_4_1png)\n\n\n\n Double Pendulum\n\nA more complicated example is given by the double pendulum The equations governing\nits motion are given by the following (taken from this StackOverflow question(httpsmathematicastackexchangecomquestions40122help-to-plot-poincarC3A9-section-for-double-pendulum))\n\nfracddt\nbeginpmatrix\nalpha  l_alpha  beta  l_beta\nendpmatrix=\nbeginpmatrix\n2fracl_alpha - (1+cosbeta)l_beta3-cos 2beta \n-2sinalpha - sin(alpha + beta) \n2frac-(1+cosbeta)l_alpha + (3+2cosbeta)l_beta3-cos2beta\n-sin(alpha+beta) - 2sin(beta)frac(l_alpha-l_beta)l_beta3-cos2beta + 2sin(2beta)fracl_alpha^2-2(1+cosbeta)l_alpha l_beta + (3+2cosbeta)l_beta^2(3-cos2beta)^2\nendpmatrix","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"#Double Pendulum Problem\nusing OrdinaryDiffEq, Plots\n\n#Constants and setup\nconst m₁, m₂, L₁, L₂ = 1, 2, 1, 2\ninitial = [0, π/3, 0, 3pi/5]\ntspan = (0.,50.)\n\n#Convenience function for transforming from polar to Cartesian coordinates\nfunction polar2cart(sol;dt=0.02,l1=L₁,l2=L₂,vars=(2,4))\n    u = sol.t[1]:dt:sol.t[end]\n\n    p1 = l1*map(x->x[vars[1]], sol.(u))\n    p2 = l2*map(y->y[vars[2]], sol.(u))\n\n    x1 = l1*sin.(p1)\n    y1 = l1*-cos.(p1)\n    (u, (x1 + l2*sin.(p2),\n     y1 - l2*cos.(p2)))\nend\n\n#Define the Problem\nfunction double_pendulum(xdot,x,p,t)\n    xdot[1]=x[2]\n    xdot[2]=-((g*(2*m₁+m₂)*sin(x[1])+m₂*(g*sin(x[1]-2*x[3])+2*(L₂*x[4]^2+L₁*x[2]^2*cos(x[1]-x[3]))*sin(x[1]-x[3])))/(2*L₁*(m₁+m₂-m₂*cos(x[1]-x[3])^2)))\n    xdot[3]=x[4]\n    xdot[4]=(((m₁+m₂)*(L₁*x[2]^2+g*cos(x[1]))+L₂*m₂*x[4]^2*cos(x[1]-x[3]))*sin(x[1]-x[3]))/(L₂*(m₁+m₂-m₂*cos(x[1]-x[3])^2))\nend\n\n#Pass to Solvers\ndouble_pendulum_problem = ODEProblem(double_pendulum, initial, tspan)\nsol = solve(double_pendulum_problem, Vern7(), abs_tol=1e-10, dt=0.05);","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"#Obtain coordinates in Cartesian Geometry\nts, ps = polar2cart(sol, l1=L₁, l2=L₂, dt=0.01)\nplot(ps...)","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"(Image: )","category":"page"},{"location":"models/01-classical_physics/#Poincaré-section","page":"Classical Physics Models","title":"Poincaré section","text":"","category":"section"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"In this case the phase space is 4 dimensional and it cannot be easily visualized. Instead of looking at the full phase space, we can look at Poincaré sections, which are sections through a higher-dimensional phase space diagram. This helps to understand the dynamics of interactions and is wonderfully pretty.","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"The Poincaré section in this is given by the collection of (βl_β) when α=0 and fracdαdt0.","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"#Constants and setup\nusing OrdinaryDiffEq\ninitial2 = [0.01, 0.005, 0.01, 0.01]\ntspan2 = (0.,500.)\n\n#Define the problem\nfunction double_pendulum_hamiltonian(udot,u,p,t)\n    α  = u[1]\n    lα = u[2]\n    β  = u[3]\n    lβ = u[4]\n    udot .=\n    [2(lα-(1+cos(β))lβ)/(3-cos(2β)),\n    -2sin(α) - sin(α+β),\n    2(-(1+cos(β))lα + (3+2cos(β))lβ)/(3-cos(2β)),\n    -sin(α+β) - 2sin(β)*(((lα-lβ)lβ)/(3-cos(2β))) + 2sin(2β)*((lα^2 - 2(1+cos(β))lα*lβ + (3+2cos(β))lβ^2)/(3-cos(2β))^2)]\nend\n\n# Construct a ContiunousCallback\ncondition(u,t,integrator) = u[1]\naffect!(integrator) = nothing\ncb = ContinuousCallback(condition,affect!,nothing,\n                        save_positions = (true,false))\n\n# Construct Problem\npoincare = ODEProblem(double_pendulum_hamiltonian, initial2, tspan2)\nsol2 = solve(poincare, Vern9(), save_everystep = false, save_start=false, save_end=false, callback=cb, abstol=1e-16, reltol=1e-16,)\n\nfunction poincare_map(prob, u₀, p; callback=cb)\n    _prob = ODEProblem(prob.f, u₀, prob.tspan)\n    sol = solve(_prob, Vern9(), save_everystep = false, save_start=false, save_end=false, callback=cb, abstol=1e-16, reltol=1e-16)\n    scatter!(p, sol, vars=(3,4), markersize = 3, msw=0)\nend","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"poincare_map (generic function with 1 method)","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"lβrange = -0.02:0.0025:0.02\np = scatter(sol2, vars=(3,4), leg=false, markersize = 3, msw=0)\nfor lβ in lβrange\n    poincare_map(poincare, [0.01, 0.01, 0.01, lβ], p)\nend\nplot(p, xlabel=\"\\\\beta\", ylabel=\"l_\\\\beta\", ylims=(0, 0.03))","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"(Image: )","category":"page"},{"location":"models/01-classical_physics/#Hénon-Heiles-System","page":"Classical Physics Models","title":"Hénon-Heiles System","text":"","category":"section"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"The Hénon-Heiles potential occurs when non-linear motion of a star around a galactic center with the motion restricted to a plane.","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"\nbeginalign\nfracd^2xdt^2=-fracpartial Vpartial x\nfracd^2ydt^2=-fracpartial Vpartial y\nendalign\n\n\nwhere\n\nV(xy)=frac 12(x^2+y^2)+lambda left(x^2y-frac y^33right)","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"We pick lambda=1 in this case, so","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"V(xy) = frac12(x^2+y^2+2x^2y-frac23y^3)","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Then the total energy of the system can be expressed by","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"E = T+V = V(xy)+frac12(dotx^2+doty^2)","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"The total energy should conserve as this system evolves.","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"using OrdinaryDiffEq, Plots\n\n#Setup\ninitial = [0.,0.1,0.5,0]\ntspan = (0,100.)\n\n#Remember, V is the potential of the system and T is the Total Kinetic Energy, thus E will\n#the total energy of the system.\nV(x,y) = 1//2 * (x^2 + y^2 + 2x^2*y - 2//3 * y^3)\nE(x,y,dx,dy) = V(x,y) + 1//2 * (dx^2 + dy^2);\n\n#Define the function\nfunction Hénon_Heiles(du,u,p,t)\n    x  = u[1]\n    y  = u[2]\n    dx = u[3]\n    dy = u[4]\n    du[1] = dx\n    du[2] = dy\n    du[3] = -x - 2x*y\n    du[4] = y^2 - y -x^2\nend\n\n#Pass to solvers\nprob = ODEProblem(Hénon_Heiles, initial, tspan)\nsol = solve(prob, Vern9(), abs_tol=1e-16, rel_tol=1e-16);","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"# Plot the orbit\nplot(sol, vars=(1,2), title = \"The orbit of the Hénon-Heiles system\", xaxis = \"x\", yaxis = \"y\", leg=false)","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"(Image: )","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"#Optional Sanity check - what do you think this returns and why?\n@show sol.retcode\n\n#Plot -\nplot(sol, vars=(1,3), title = \"Phase space for the Hénon-Heiles system\", xaxis = \"Position\", yaxis = \"Velocity\")\nplot!(sol, vars=(2,4), leg = false)","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"sol.retcode = :Success","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"(Image: )","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"#We map the Total energies during the time intervals of the solution (sol.u here) to a new vector\n#pass it to the plotter a bit more conveniently\nenergy = map(x->E(x...), sol.u)\n\n#We use @show here to easily spot erratic behaviour in our system by seeing if the loss in energy was too great.\n@show ΔE = energy[1]-energy[end]\n\n#Plot\nplot(sol.t, energy .- energy[1], title = \"Change in Energy over Time\", xaxis = \"Time in iterations\", yaxis = \"Change in Energy\")","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"ΔE = energy[1] - energy[end] = -3.098606125834236e-5","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"(Image: )","category":"page"},{"location":"models/01-classical_physics/#Symplectic-Integration","page":"Classical Physics Models","title":"Symplectic Integration","text":"","category":"section"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"To prevent energy drift, we can instead use a symplectic integrator. We can directly define and solve the SecondOrderODEProblem:","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"function HH_acceleration!(dv,v,u,p,t)\n    x,y  = u\n    dx,dy = dv\n    dv[1] = -x - 2x*y\n    dv[2] = y^2 - y -x^2\nend\ninitial_positions = [0.0,0.1]\ninitial_velocities = [0.5,0.0]\nprob = SecondOrderODEProblem(HH_acceleration!,initial_velocities,initial_positions,tspan)\nsol2 = solve(prob, KahanLi8(), dt=1/10);","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Notice that we get the same results:","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"# Plot the orbit\nplot(sol2, vars=(3,4), title = \"The orbit of the Hénon-Heiles system\", xaxis = \"x\", yaxis = \"y\", leg=false)","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"(Image: )","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"plot(sol2, vars=(3,1), title = \"Phase space for the Hénon-Heiles system\", xaxis = \"Position\", yaxis = \"Velocity\")\nplot!(sol2, vars=(4,2), leg = false)","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"(Image: )","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"but now the energy change is essentially zero:","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"energy = map(x->E(x[3], x[4], x[1], x[2]), sol2.u)\n#We use @show here to easily spot erratic behaviour in our system by seeing if the loss in energy was too great.\n@show ΔE = energy[1]-energy[end]\n\n#Plot\nplot(sol2.t, energy .- energy[1], title = \"Change in Energy over Time\", xaxis = \"Time in iterations\", yaxis = \"Change in Energy\")","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"ΔE = energy[1] - energy[end] = 9.048317650695026e-15","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"(Image: )","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"And let's try to use a Runge-Kutta-Nyström solver to solve this. Note that Runge-Kutta-Nyström isn't symplectic.","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"sol3 = solve(prob, DPRKN6());\nenergy = map(x->E(x[3], x[4], x[1], x[2]), sol3.u)\n@show ΔE = energy[1]-energy[end]\ngr()\nplot(sol3.t, energy .- energy[1], title = \"Change in Energy over Time\", xaxis = \"Time in iterations\", yaxis = \"Change in Energy\")","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"ΔE = energy[1] - energy[end] = -2.723253093667166e-6","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"(Image: )","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Note that we are using the DPRKN6 sovler at reltol=1e-3 (the default), yet it has a smaller energy variation than Vern9 at abs_tol=1e-16, rel_tol=1e-16. Therefore, using specialized solvers to solve its particular problem is very efficient.","category":"page"},{"location":"models/01-classical_physics/#Appendix","page":"Classical Physics Models","title":"Appendix","text":"","category":"section"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"tutorials/models\",\"01-classical_physics.jmd\")","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Computer Information:","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Julia Version 1.6.2\nCommit 1b93d53fc4 (2021-07-14 15:36 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, znver2)\nEnvironment:\n  JULIA_DEPOT_PATH = /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n  JULIA_NUM_THREADS = 16\n","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Package Information:","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"      Status `/var/lib/buildkite-agent/builds/1-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/models/Project.toml`\n  [479239e8] Catalyst v6.12.1\n  [459566f4] DiffEqCallbacks v2.16.1\n  [f3b72e0c] DiffEqDevTools v2.27.2\n  [055956cb] DiffEqPhysics v3.9.0\n  [0c46a032] DifferentialEquations v6.17.1\n  [31c24e10] Distributions v0.24.18\n  [587475ba] Flux v0.12.1\n  [f6369f11] ForwardDiff v0.10.18\n  [23fbe1c1] Latexify v0.15.5\n  [961ee093] ModelingToolkit v5.17.3\n  [2774e3e8] NLsolve v4.5.1\n  [315f7962] NeuralPDE v3.10.1\n  [429524aa] Optim v1.3.0\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [91a5bcdd] Plots v1.15.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [789caeaf] StochasticDiffEq v6.34.1\n  [37e2e46d] LinearAlgebra\n  [2f01184e] SparseArrays","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"And the full manifest:","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"      Status `/var/lib/buildkite-agent/builds/1-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/models/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.16.0\n  [621f4979] AbstractFFTs v1.0.1\n  [1520ce14] AbstractTrees v0.3.4\n  [79e6a3ab] Adapt v3.3.0\n  [ec485272] ArnoldiMethod v0.1.0\n  [4fba245c] ArrayInterface v3.1.15\n  [4c555306] ArrayLayouts v0.7.0\n  [13072b0f] AxisAlgorithms v1.0.0\n  [ab4f0b2a] BFloat16s v0.1.0\n  [aae01518] BandedMatrices v0.16.9\n  [764a87c0] BoundaryValueDiffEq v2.7.1\n  [fa961155] CEnum v0.4.1\n  [00ebfdb7] CSTParser v2.5.0\n  [052768ef] CUDA v2.6.3\n  [479239e8] Catalyst v6.12.1\n  [082447d4] ChainRules v0.7.65\n  [d360d2e6] ChainRulesCore v0.9.44\n  [b630d9fa] CheapThreads v0.2.5\n  [944b1d66] CodecZlib v0.7.0\n  [35d6a980] ColorSchemes v3.12.1\n  [3da002f7] ColorTypes v0.11.0\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [a80b9123] CommonMark v0.8.1\n  [38540f10] CommonSolve v0.2.0\n  [bbf7d656] CommonSubexpressions v0.3.0\n  [34da2185] Compat v3.30.0\n  [8f4d0f93] Conda v1.5.2\n  [88cd18e8] ConsoleProgressMonitor v0.1.2\n  [187b0558] ConstructionBase v1.2.1\n  [d38c429a] Contour v0.5.7\n  [a8cc5b0e] Crayons v4.0.4\n  [8a292aeb] Cuba v2.2.0\n  [667455a9] Cubature v1.5.1\n  [9a962f9c] DataAPI v1.6.0\n  [82cc6244] DataInterpolations v3.3.1\n  [864edb3b] DataStructures v0.18.9\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [bcd4f6db] DelayDiffEq v5.31.0\n  [2b5f629d] DiffEqBase v6.62.2\n  [459566f4] DiffEqCallbacks v2.16.1\n  [f3b72e0c] DiffEqDevTools v2.27.2\n  [5a0ffddc] DiffEqFinancial v2.4.0\n  [aae7a2af] DiffEqFlux v1.37.0\n  [c894b116] DiffEqJump v6.14.2\n  [77a26b50] DiffEqNoiseProcess v5.7.3\n  [055956cb] DiffEqPhysics v3.9.0\n  [41bf760c] DiffEqSensitivity v6.45.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.0.2\n  [0c46a032] DifferentialEquations v6.17.1\n  [c619ae07] DimensionalPlotRecipes v1.2.0\n  [b4f34e82] Distances v0.10.3\n  [31c24e10] Distributions v0.24.18\n  [ced4e74d] DistributionsAD v0.6.26\n  [ffbed154] DocStringExtensions v0.8.4\n  [e30172f5] Documenter v0.26.3\n  [d4d017d3] ExponentialUtilities v1.8.4\n  [e2ba6199] ExprTools v0.1.3\n  [c87230d0] FFMPEG v0.4.0\n  [7a1cc6ca] FFTW v1.4.1\n  [7034ab61] FastBroadcast v0.1.8\n  [9aa1b823] FastClosures v0.3.2\n  [1a297f60] FillArrays v0.11.7\n  [6a86dc24] FiniteDiff v2.8.0\n  [53c48c17] FixedPointNumbers v0.8.4\n  [587475ba] Flux v0.12.1\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.18\n  [069b7b12] FunctionWrappers v1.1.2\n  [d9f16b24] Functors v0.2.1\n  [0c68f7d7] GPUArrays v6.4.1\n  [61eb1bfa] GPUCompiler v0.10.0\n  [28b8d3ca] GR v0.57.4\n  [a75be94c] GalacticOptim v1.2.0\n  [5c1252a2] GeometryBasics v0.3.12\n  [af5da776] GlobalSensitivity v1.0.0\n  [42e2da0e] Grisu v1.0.2\n  [19dc6840] HCubature v1.5.0\n  [cd3eb016] HTTP v0.9.9\n  [eafb193a] Highlights v0.4.5\n  [0e44f5e4] Hwloc v2.0.0\n  [7073ff75] IJulia v1.23.2\n  [b5f81e59] IOCapture v0.1.1\n  [7869d1d1] IRTools v0.4.2\n  [615f187c] IfElse v0.1.0\n  [d25df0c9] Inflate v0.1.2\n  [83e8ac13] IniFile v0.5.0\n  [a98d9a8b] Interpolations v0.13.2\n  [c8e1da08] IterTools v1.3.0\n  [42fd0dbc] IterativeSolvers v0.9.1\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.3.0\n  [682c06a0] JSON v0.21.1\n  [98e50ef6] JuliaFormatter v0.13.7\n  [e5e0dc1b] Juno v0.8.4\n  [5ab0869b] KernelDensity v0.6.3\n  [929cbde3] LLVM v3.7.1\n  [b964fa9f] LaTeXStrings v1.2.1\n  [2ee39098] LabelledArrays v1.6.1\n  [23fbe1c1] Latexify v0.15.5\n  [a5e1c1ea] LatinHypercubeSampling v1.8.0\n  [73f95e8e] LatticeRules v0.0.1\n  [1d6d02ad] LeftChildRightSiblingTrees v0.1.2\n  [093fc24a] LightGraphs v1.3.5\n  [d3d80556] LineSearches v7.1.1\n  [2ab3a3ac] LogExpFunctions v0.2.4\n  [e6f89c97] LoggingExtras v0.4.6\n  [bdcacae8] LoopVectorization v0.12.23\n  [1914dd2f] MacroTools v0.5.6\n  [739be429] MbedTLS v1.0.3\n  [442fdcdd] Measures v0.3.1\n  [e89f7d12] Media v0.5.0\n  [c03570c3] Memoize v0.4.4\n  [e1d29d7a] Missings v1.0.0\n  [961ee093] ModelingToolkit v5.17.3\n  [4886b29c] MonteCarloIntegration v0.0.2\n  [46d2c3a1] MuladdMacro v0.2.2\n  [f9640e96] MultiScaleArrays v1.8.1\n  [ffc61752] Mustache v1.0.10\n  [d41bc354] NLSolversBase v7.8.0\n  [2774e3e8] NLsolve v4.5.1\n  [872c559c] NNlib v0.7.19\n  [77ba4419] NaNMath v0.3.5\n  [315f7962] NeuralPDE v3.10.1\n  [8913a72c] NonlinearSolve v0.3.8\n  [6fe1bfb0] OffsetArrays v1.9.0\n  [429524aa] Optim v1.3.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [90014a1f] PDMats v0.11.0\n  [65888b18] ParameterizedFunctions v5.10.0\n  [d96e819e] Parameters v0.12.2\n  [69de0a69] Parsers v1.1.0\n  [ccf2f8ad] PlotThemes v2.0.1\n  [995b91a9] PlotUtils v1.0.10\n  [91a5bcdd] Plots v1.15.2\n  [e409e4f3] PoissonRandom v0.4.0\n  [f517fe37] Polyester v0.3.1\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [21216c6a] Preferences v1.2.2\n  [33c8b6b6] ProgressLogging v0.1.4\n  [92933f4c] ProgressMeter v1.6.2\n  [1fd47b50] QuadGK v2.4.1\n  [67601950] Quadrature v1.8.1\n  [8a4e6c94] QuasiMonteCarlo v0.2.2\n  [74087812] Random123 v1.3.1\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.4.0\n  [c84ed2f1] Ratios v0.4.0\n  [3cdcf5f2] RecipesBase v1.1.1\n  [01d81517] RecipesPipeline v0.3.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [f2c3362d] RecursiveFactorization v0.1.12\n  [189a3867] Reexport v1.0.0\n  [ae029012] Requires v1.1.3\n  [ae5879a3] ResettableStacks v1.1.0\n  [37e2e3b7] ReverseDiff v1.9.0\n  [79098fc4] Rmath v0.7.0\n  [47965b36] RootedTrees v1.0.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.2\n  [476501e8] SLEEFPirates v0.6.20\n  [1bc83da4] SafeTestsets v0.0.1\n  [0bca4576] SciMLBase v1.13.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [6c6a2e73] Scratch v1.0.3\n  [efcf1570] Setfield v0.7.0\n  [992d4aef] Showoff v1.0.3\n  [699a6c99] SimpleTraits v0.9.3\n  [ed01d8cd] Sobol v1.5.0\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.0\n  [47a9eef4] SparseDiffTools v1.13.2\n  [276daf66] SpecialFunctions v1.4.1\n  [860ef19b] StableRNGs v1.0.0\n  [aedffcd0] Static v0.2.4\n  [90137ffa] StaticArrays v1.2.0\n  [82ae8749] StatsAPI v1.0.0\n  [2913bbd2] StatsBase v0.33.8\n  [4c63d2b9] StatsFuns v0.9.8\n  [9672c7b4] SteadyStateDiffEq v1.6.2\n  [789caeaf] StochasticDiffEq v6.34.1\n  [7792a7ef] StrideArraysCore v0.1.11\n  [09ab397b] StructArrays v0.5.1\n  [c3572dad] Sundials v4.4.3\n  [d1185830] SymbolicUtils v0.11.2\n  [0c5d862f] Symbolics v0.1.25\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.4.2\n  [5d786b92] TerminalLoggers v0.1.3\n  [8290d209] ThreadingUtilities v0.4.4\n  [a759f4b9] TimerOutputs v0.5.9\n  [0796e94c] Tokenize v0.5.16\n  [9f7883ad] Tracker v0.2.16\n  [3bb67fe8] TranscodingStreams v0.9.5\n  [592b5752] Trapz v2.0.2\n  [a2a6695c] TreeViews v0.3.0\n  [5c2747f8] URIs v1.3.0\n  [3a884ed6] UnPack v1.0.2\n  [1986cc42] Unitful v1.7.0\n  [3d5dd08c] VectorizationBase v0.20.11\n  [81def892] VersionParsing v1.2.0\n  [19fa3120] VertexSafeGraphs v0.1.2\n  [44d3d7a6] Weave v0.10.8\n  [efce3f68] WoodburyMatrices v0.5.3\n  [ddb6d928] YAML v0.4.6\n  [c2297ded] ZMQ v1.2.1\n  [a5390f91] ZipFile v0.9.3\n  [e88e6eb3] Zygote v0.6.11\n  [700de1a5] ZygoteRules v0.2.1\n  [6e34b625] Bzip2_jll v1.0.6+5\n  [83423d85] Cairo_jll v1.16.0+6\n  [3bed1096] Cuba_jll v4.2.1+0\n  [7bc98958] Cubature_jll v1.0.4+0\n  [5ae413db] EarCut_jll v2.1.5+1\n  [2e619515] Expat_jll v2.2.10+0\n  [b22a6f82] FFMPEG_jll v4.3.1+4\n  [f5851436] FFTW_jll v3.3.9+7\n  [a3f928ae] Fontconfig_jll v2.13.1+14\n  [d7e528f0] FreeType2_jll v2.10.1+5\n  [559328eb] FriBidi_jll v1.0.5+6\n  [0656b61e] GLFW_jll v3.3.4+0\n  [d2c73de3] GR_jll v0.57.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.1+0\n  [e33a78d0] Hwloc_jll v2.4.1+0\n  [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2\n  [aacddb02] JpegTurbo_jll v2.0.1+3\n  [c1c5ebd0] LAME_jll v3.100.0+3\n  [dd4b983a] LZO_jll v2.10.1+0\n  [dd192d2f] LibVPX_jll v1.9.0+1\n  [e9f186c6] Libffi_jll v3.2.2+0\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+0\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.1.0+2\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [856f044c] MKL_jll v2021.1.1+1\n  [e7412a2a] Ogg_jll v1.3.4+2\n  [458c3c95] OpenSSL_jll v1.1.1+6\n  [efe28fd5] OpenSpecFun_jll v0.5.4+0\n  [91d4177d] Opus_jll v1.3.1+3\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.2+0\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.0+1\n  [a2964d1f] Wayland_jll v1.17.0+4\n  [2381bf8a] Wayland_protocols_jll v1.18.0+4\n  [02c8fc9c] XML2_jll v2.9.12+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.2+6\n  [3161d3a3] Zstd_jll v1.5.0+0\n  [0ac62f75] libass_jll v0.14.0+4\n  [f638f0a6] libfdk_aac_jll v0.1.6+4\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.6+6\n  [1270edf5] x264_jll v2020.7.14+2\n  [dfaa095f] x265_jll v3.0.0+3\n  [d8fb68d0] xkbcommon_jll v0.9.1+5\n  [0dad84c5] ArgTools\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [4af54fe1] LazyArtifacts\n  [b27032c2] LibCURL\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions\n  [44cfe95a] Pkg\n  [de0858da] Printf\n  [9abbd945] Profile\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML\n  [a4e569a6] Tar\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll\n  [deac9b47] LibCURL_jll\n  [29816b5a] LibSSH2_jll\n  [c8ffd9c3] MbedTLS_jll\n  [14a3606d] MozillaCACerts_jll\n  [4536629a] OpenBLAS_jll\n  [bea87d4a] SuiteSparse_jll\n  [83775a58] Zlib_jll\n  [8e850ede] nghttp2_jll\n  [3f19e933] p7zip_jll","category":"page"},{"location":"ode_extras/03-ode_minmax/#Finding-Maxima-and-Minima-of-DiffEq-Solutions","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"","category":"section"},{"location":"ode_extras/03-ode_minmax/#Setup","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Setup","text":"","category":"section"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"In this tutorial we will show how to use Optim.jl to find the maxima and minima of solutions. Let's take a look at the double pendulum:","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"#Constants and setup\nusing OrdinaryDiffEq\ninitial = [0.01, 0.01, 0.01, 0.01]\ntspan = (0.,100.)\n\n#Define the problem\nfunction double_pendulum_hamiltonian(udot,u,p,t)\n    α  = u[1]\n    lα = u[2]\n    β  = u[3]\n    lβ = u[4]\n    udot .=\n    [2(lα-(1+cos(β))lβ)/(3-cos(2β)),\n    -2sin(α) - sin(α+β),\n    2(-(1+cos(β))lα + (3+2cos(β))lβ)/(3-cos(2β)),\n    -sin(α+β) - 2sin(β)*(((lα-lβ)lβ)/(3-cos(2β))) + 2sin(2β)*((lα^2 - 2(1+cos(β))lα*lβ + (3+2cos(β))lβ^2)/(3-cos(2β))^2)]\nend\n\n#Pass to solvers\npoincare = ODEProblem(double_pendulum_hamiltonian, initial, tspan)","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"ODEProblem with uType Vector{Float64} and tType Float64. In-place: true\ntimespan: (0.0, 100.0)\nu0: 4-element Vector{Float64}:\n 0.01\n 0.01\n 0.01\n 0.01","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"sol = solve(poincare, Tsit5())","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"retcode: Success\nInterpolation: specialized 4th order \"free\" interpolation\nt: 193-element Vector{Float64}:\n   0.0\n   0.08332584852065579\n   0.24175300587841853\n   0.4389533535703127\n   0.6797301355043014\n   0.9647629621490508\n   1.3179425637594349\n   1.7031226016307728\n   2.0678503967116617\n   2.4717899847517866\n   ⋮\n  95.8457309586563\n  96.3577910122243\n  96.92913461915474\n  97.44679415429573\n  97.96248479179103\n  98.51183391850897\n  99.0608253308051\n  99.58284388126884\n 100.0\nu: 193-element Vector{Vector{Float64}}:\n [0.01, 0.01, 0.01, 0.01]\n [0.009170687380405334, 0.006669000455384281, 0.012420525490765841, 0.00826\n6408515192909]\n [0.007673275265972504, 0.00037461737897660443, 0.016442590227730397, 0.004\n636827483318277]\n [0.006125974419239289, -0.007305450189721187, 0.019967371084231897, -0.000\n3364979830896869]\n [0.004966110662711131, -0.01630851653373806, 0.021440659476204722, -0.0067\n05037098400474]\n [0.0047955683310194714, -0.026238103489235838, 0.01882432520883759, -0.013\n913364556753736]\n [0.0060546798253553686, -0.03712455187908053, 0.010055702788069564, -0.021\n038127478647375]\n [0.007900784412908646, -0.04667606960847394, -0.002673581831574513, -0.025\n18303627203377]\n [0.008276510489473166, -0.05278433365633976, -0.012731546444725367, -0.025\n25804037623962]\n [0.00552349681674124, -0.05525250414492613, -0.016843881882621835, -0.0218\n98963191274153]\n ⋮\n [-0.014886751154788403, 0.04233275827248491, 0.0136282832580092, 0.0180290\n82291419467]\n [-0.008190258536393156, 0.054422679804409874, 0.009448013826704854, 0.0177\n4006800908217]\n [0.004124711787695587, 0.05674878820505975, -0.00515418739191979, 0.017596\n983103942972]\n [0.013079718118471138, 0.048077043077395416, -0.01377066122508919, 0.01828\n6648610391296]\n [0.015316040241448815, 0.03163095955755212, -0.008956991644884404, 0.01711\n8404049844594]\n [0.011115490017375213, 0.00992901822063005, 0.007297481421219374, 0.010353\n371812537674]\n [0.005713878919291721, -0.011787427051187821, 0.02050806401368854, -0.0023\n10458905852316]\n [0.004211439726126673, -0.029911199361470703, 0.018750446422905413, -0.015\n650712294907165]\n [0.005741239607321043, -0.04165385985159563, 0.007413270184094278, -0.0233\n4897852528026]","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"In time, the solution looks like:","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"using Plots; gr()\nplot(sol, vars=[(0,3),(0,4)], leg=false, plotdensity=10000)","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"(Image: )","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"while it has the well-known phase-space plot:","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"plot(sol, vars=(3,4), leg=false)","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"(Image: )","category":"page"},{"location":"ode_extras/03-ode_minmax/#Local-Optimization","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Local Optimization","text":"","category":"section"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"Let's fine out what some of the local maxima and minima are. Optim.jl can be used to minimize functions, and the solution type has a continuous interpolation which can be used. Let's look for the local optima for the 4th variable around t=20. Thus our optimization function is:","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"f = (t) -> sol(t,idxs=4)","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"#1 (generic function with 1 method)","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"first(t) is the same as t[1] which transforms the array of size 1 into a number. idxs=4 is the same as sol(first(t))[4] but does the calculation without a temporary array and thus is faster. To find a local minima, we can simply call Optim on this function. Let's find a local minimum:","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"using Optim\nopt = optimize(f,18.0,22.0)","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"Results of Optimization Algorithm\n * Algorithm: Brent's Method\n * Search Interval: [18.000000, 22.000000]\n * Minimizer: 1.863213e+01\n * Minimum: -2.793164e-02\n * Iterations: 11\n * Convergence: max(|x - x_upper|, |x - x_lower|) <= 2*(1.5e-08*|x|+2.2e-16\n): true\n * Objective Function Calls: 12","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"From this printout we see that the minimum is at t=18.63 and the value is -2.79e-2. We can get these in code-form via:","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"println(opt.minimizer)\nprintln(opt.minimum)","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"18.632127451866573\n-0.02793163565154488","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"To get the maximum, we just minimize the negative of the function:","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"f = (t) -> -sol(first(t),idxs=4)\nopt2 = optimize(f,0.0,22.0)","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"Results of Optimization Algorithm\n * Algorithm: Brent's Method\n * Search Interval: [0.000000, 22.000000]\n * Minimizer: 1.399975e+01\n * Minimum: -2.269411e-02\n * Iterations: 13\n * Convergence: max(|x - x_upper|, |x - x_lower|) <= 2*(1.5e-08*|x|+2.2e-16\n): true\n * Objective Function Calls: 14","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"Let's add the maxima and minima to the plots:","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"plot(sol, vars=(0,4), plotdensity=10000)\nscatter!([opt.minimizer],[opt.minimum],label=\"Local Min\")\nscatter!([opt2.minimizer],[-opt2.minimum],label=\"Local Max\")","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"(Image: )","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"Brent's method will locally minimize over the full interval. If we instead want a local maxima nearest to a point, we can use BFGS(). In this case, we need to optimize a vector [t], and thus dereference it to a number using first(t).","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"f = (t) -> -sol(first(t),idxs=4)\nopt = optimize(f,[20.0],BFGS())","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"* Status: success\n\n * Candidate solution\n    Final objective value:     -2.588588e-02\n\n * Found with\n    Algorithm:     BFGS\n\n * Convergence measures\n    |x - x'|               = 1.11e-04 ≰ 0.0e+00\n    |x - x'|/|x'|          = 4.78e-06 ≰ 0.0e+00\n    |f(x) - f(x')|         = 1.68e-10 ≰ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 6.49e-09 ≰ 0.0e+00\n    |g(x)|                 = 8.44e-12 ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   0  (vs limit Inf)\n    Iterations:    4\n    f(x) calls:    16\n    ∇f(x) calls:   16","category":"page"},{"location":"ode_extras/03-ode_minmax/#Global-Optimization","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Global Optimization","text":"","category":"section"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"If we instead want to find global maxima and minima, we need to look somewhere else. For this there are many choices. A pure Julia option is BlackBoxOptim.jl, but I will use NLopt.jl. Following the NLopt.jl tutorial but replacing their function with out own:","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"import NLopt, ForwardDiff\n\ncount = 0 # keep track of # function evaluations\n\nfunction g(t::Vector, grad::Vector)\n  if length(grad) > 0\n    #use ForwardDiff for the gradients\n    grad[1] = ForwardDiff.derivative((t)->sol(first(t),idxs=4),t)\n  end\n  sol(first(t),idxs=4)\nend\nopt = NLopt.Opt(:GN_ORIG_DIRECT_L, 1)\nNLopt.lower_bounds!(opt, [0.0])\nNLopt.upper_bounds!(opt, [40.0])\nNLopt.xtol_rel!(opt,1e-8)\nNLopt.min_objective!(opt, g)\n(minf,minx,ret) = NLopt.optimize(opt,[20.0])\nprintln(minf,\" \",minx,\" \",ret)\nNLopt.max_objective!(opt, g)\n(maxf,maxx,ret) = NLopt.optimize(opt,[20.0])\nprintln(maxf,\" \",maxx,\" \",ret)","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"Error: ArgumentError: Package ForwardDiff not found in current path:\n- Run `import Pkg; Pkg.add(\"ForwardDiff\")` to install the ForwardDiff packa\nge.","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"plot(sol, vars=(0,4), plotdensity=10000)\nscatter!([minx],[minf],label=\"Global Min\")\nscatter!([maxx],[maxf],label=\"Global Max\")","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"Error: UndefVarError: minx not defined","category":"page"},{"location":"ode_extras/03-ode_minmax/#Appendix","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Appendix","text":"","category":"section"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"tutorials/ode_extras\",\"03-ode_minmax.jmd\")","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"Computer Information:","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"Julia Version 1.6.2\nCommit 1b93d53fc4 (2021-07-14 15:36 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, znver2)\nEnvironment:\n  JULIA_DEPOT_PATH = /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n  JULIA_NUM_THREADS = 16\n","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"Package Information:","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"      Status `/var/lib/buildkite-agent/builds/5-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/ode_extras/Project.toml`\n  [f3b72e0c] DiffEqDevTools v2.27.2\n  [0c46a032] DifferentialEquations v6.17.1\n  [961ee093] ModelingToolkit v5.17.3\n  [76087f3c] NLopt v0.6.2\n  [2774e3e8] NLsolve v4.5.1\n  [429524aa] Optim v1.3.0\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [91a5bcdd] Plots v1.15.2\n  [30cb0354] SciMLTutorials v0.9.0\n  [37e2e46d] LinearAlgebra\n  [2f01184e] SparseArrays","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"And the full manifest:","category":"page"},{"location":"ode_extras/03-ode_minmax/","page":"Finding Maxima and Minima of DiffEq Solutions","title":"Finding Maxima and Minima of DiffEq Solutions","text":"      Status `/var/lib/buildkite-agent/builds/5-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/ode_extras/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.16.0\n  [1520ce14] AbstractTrees v0.3.4\n  [79e6a3ab] Adapt v3.3.0\n  [ec485272] ArnoldiMethod v0.1.0\n  [4fba245c] ArrayInterface v3.1.15\n  [4c555306] ArrayLayouts v0.7.0\n  [aae01518] BandedMatrices v0.16.9\n  [6e4b80f9] BenchmarkTools v1.0.0\n  [764a87c0] BoundaryValueDiffEq v2.7.1\n  [fa961155] CEnum v0.4.1\n  [00ebfdb7] CSTParser v2.5.0\n  [d360d2e6] ChainRulesCore v0.9.44\n  [b630d9fa] CheapThreads v0.2.5\n  [523fee87] CodecBzip2 v0.7.2\n  [944b1d66] CodecZlib v0.7.0\n  [35d6a980] ColorSchemes v3.12.1\n  [3da002f7] ColorTypes v0.11.0\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [a80b9123] CommonMark v0.8.1\n  [38540f10] CommonSolve v0.2.0\n  [bbf7d656] CommonSubexpressions v0.3.0\n  [34da2185] Compat v3.30.0\n  [8f4d0f93] Conda v1.5.2\n  [187b0558] ConstructionBase v1.2.1\n  [d38c429a] Contour v0.5.7\n  [a8cc5b0e] Crayons v4.0.4\n  [9a962f9c] DataAPI v1.6.0\n  [864edb3b] DataStructures v0.18.9\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [bcd4f6db] DelayDiffEq v5.31.0\n  [2b5f629d] DiffEqBase v6.62.2\n  [459566f4] DiffEqCallbacks v2.16.1\n  [f3b72e0c] DiffEqDevTools v2.27.2\n  [5a0ffddc] DiffEqFinancial v2.4.0\n  [c894b116] DiffEqJump v6.14.2\n  [77a26b50] DiffEqNoiseProcess v5.7.3\n  [055956cb] DiffEqPhysics v3.9.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.0.2\n  [0c46a032] DifferentialEquations v6.17.1\n  [c619ae07] DimensionalPlotRecipes v1.2.0\n  [b4f34e82] Distances v0.10.3\n  [31c24e10] Distributions v0.24.18\n  [ffbed154] DocStringExtensions v0.8.4\n  [e30172f5] Documenter v0.26.3\n  [d4d017d3] ExponentialUtilities v1.8.4\n  [e2ba6199] ExprTools v0.1.3\n  [c87230d0] FFMPEG v0.4.0\n  [7034ab61] FastBroadcast v0.1.8\n  [9aa1b823] FastClosures v0.3.2\n  [1a297f60] FillArrays v0.11.7\n  [6a86dc24] FiniteDiff v2.8.0\n  [53c48c17] FixedPointNumbers v0.8.4\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.18\n  [069b7b12] FunctionWrappers v1.1.2\n  [28b8d3ca] GR v0.57.4\n  [5c1252a2] GeometryBasics v0.3.12\n  [42e2da0e] Grisu v1.0.2\n  [cd3eb016] HTTP v0.9.9\n  [eafb193a] Highlights v0.4.5\n  [0e44f5e4] Hwloc v2.0.0\n  [7073ff75] IJulia v1.23.2\n  [b5f81e59] IOCapture v0.1.1\n  [615f187c] IfElse v0.1.0\n  [d25df0c9] Inflate v0.1.2\n  [83e8ac13] IniFile v0.5.0\n  [c8e1da08] IterTools v1.3.0\n  [42fd0dbc] IterativeSolvers v0.9.1\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.3.0\n  [682c06a0] JSON v0.21.1\n  [7d188eb4] JSONSchema v0.3.3\n  [98e50ef6] JuliaFormatter v0.13.7\n  [b964fa9f] LaTeXStrings v1.2.1\n  [2ee39098] LabelledArrays v1.6.1\n  [23fbe1c1] Latexify v0.15.5\n  [093fc24a] LightGraphs v1.3.5\n  [d3d80556] LineSearches v7.1.1\n  [2ab3a3ac] LogExpFunctions v0.2.4\n  [bdcacae8] LoopVectorization v0.12.23\n  [1914dd2f] MacroTools v0.5.6\n  [b8f27783] MathOptInterface v0.9.22\n  [fdba3010] MathProgBase v0.7.8\n  [739be429] MbedTLS v1.0.3\n  [442fdcdd] Measures v0.3.1\n  [e1d29d7a] Missings v1.0.0\n  [961ee093] ModelingToolkit v5.17.3\n  [46d2c3a1] MuladdMacro v0.2.2\n  [f9640e96] MultiScaleArrays v1.8.1\n  [ffc61752] Mustache v1.0.10\n  [d8a4904e] MutableArithmetics v0.2.19\n  [d41bc354] NLSolversBase v7.8.0\n  [76087f3c] NLopt v0.6.2\n  [2774e3e8] NLsolve v4.5.1\n  [77ba4419] NaNMath v0.3.5\n  [8913a72c] NonlinearSolve v0.3.8\n  [6fe1bfb0] OffsetArrays v1.9.0\n  [429524aa] Optim v1.3.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [90014a1f] PDMats v0.11.0\n  [65888b18] ParameterizedFunctions v5.10.0\n  [d96e819e] Parameters v0.12.2\n  [69de0a69] Parsers v1.1.0\n  [ccf2f8ad] PlotThemes v2.0.1\n  [995b91a9] PlotUtils v1.0.10\n  [91a5bcdd] Plots v1.15.2\n  [e409e4f3] PoissonRandom v0.4.0\n  [f517fe37] Polyester v0.3.1\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [21216c6a] Preferences v1.2.2\n  [1fd47b50] QuadGK v2.4.1\n  [74087812] Random123 v1.3.1\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.4.0\n  [3cdcf5f2] RecipesBase v1.1.1\n  [01d81517] RecipesPipeline v0.3.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [f2c3362d] RecursiveFactorization v0.1.12\n  [189a3867] Reexport v1.0.0\n  [ae029012] Requires v1.1.3\n  [ae5879a3] ResettableStacks v1.1.0\n  [79098fc4] Rmath v0.7.0\n  [47965b36] RootedTrees v1.0.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.2\n  [476501e8] SLEEFPirates v0.6.20\n  [1bc83da4] SafeTestsets v0.0.1\n  [0bca4576] SciMLBase v1.13.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [6c6a2e73] Scratch v1.0.3\n  [efcf1570] Setfield v0.7.0\n  [992d4aef] Showoff v1.0.3\n  [699a6c99] SimpleTraits v0.9.3\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.0\n  [47a9eef4] SparseDiffTools v1.13.2\n  [276daf66] SpecialFunctions v1.4.1\n  [aedffcd0] Static v0.2.4\n  [90137ffa] StaticArrays v1.2.0\n  [82ae8749] StatsAPI v1.0.0\n  [2913bbd2] StatsBase v0.33.8\n  [4c63d2b9] StatsFuns v0.9.8\n  [9672c7b4] SteadyStateDiffEq v1.6.2\n  [789caeaf] StochasticDiffEq v6.34.1\n  [7792a7ef] StrideArraysCore v0.1.11\n  [09ab397b] StructArrays v0.5.1\n  [c3572dad] Sundials v4.4.3\n  [d1185830] SymbolicUtils v0.11.2\n  [0c5d862f] Symbolics v0.1.25\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.4.2\n  [8290d209] ThreadingUtilities v0.4.4\n  [a759f4b9] TimerOutputs v0.5.9\n  [0796e94c] Tokenize v0.5.16\n  [3bb67fe8] TranscodingStreams v0.9.5\n  [a2a6695c] TreeViews v0.3.0\n  [5c2747f8] URIs v1.3.0\n  [3a884ed6] UnPack v1.0.2\n  [1986cc42] Unitful v1.7.0\n  [3d5dd08c] VectorizationBase v0.20.11\n  [81def892] VersionParsing v1.2.0\n  [19fa3120] VertexSafeGraphs v0.1.2\n  [44d3d7a6] Weave v0.10.8\n  [ddb6d928] YAML v0.4.6\n  [c2297ded] ZMQ v1.2.1\n  [a5390f91] ZipFile v0.9.3\n  [700de1a5] ZygoteRules v0.2.1\n  [6e34b625] Bzip2_jll v1.0.6+5\n  [83423d85] Cairo_jll v1.16.0+6\n  [5ae413db] EarCut_jll v2.1.5+1\n  [2e619515] Expat_jll v2.2.10+0\n  [b22a6f82] FFMPEG_jll v4.3.1+4\n  [a3f928ae] Fontconfig_jll v2.13.1+14\n  [d7e528f0] FreeType2_jll v2.10.1+5\n  [559328eb] FriBidi_jll v1.0.5+6\n  [0656b61e] GLFW_jll v3.3.4+0\n  [d2c73de3] GR_jll v0.57.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.1+0\n  [e33a78d0] Hwloc_jll v2.4.1+0\n  [aacddb02] JpegTurbo_jll v2.0.1+3\n  [c1c5ebd0] LAME_jll v3.100.0+3\n  [dd4b983a] LZO_jll v2.10.1+0\n  [dd192d2f] LibVPX_jll v1.9.0+1\n  [e9f186c6] Libffi_jll v3.2.2+0\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+0\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.1.0+2\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [079eb43e] NLopt_jll v2.7.0+0\n  [e7412a2a] Ogg_jll v1.3.4+2\n  [458c3c95] OpenSSL_jll v1.1.1+6\n  [efe28fd5] OpenSpecFun_jll v0.5.4+0\n  [91d4177d] Opus_jll v1.3.1+3\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.2+0\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.0+1\n  [a2964d1f] Wayland_jll v1.17.0+4\n  [2381bf8a] Wayland_protocols_jll v1.18.0+4\n  [02c8fc9c] XML2_jll v2.9.12+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.2+6\n  [3161d3a3] Zstd_jll v1.5.0+0\n  [0ac62f75] libass_jll v0.14.0+4\n  [f638f0a6] libfdk_aac_jll v0.1.6+4\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.6+6\n  [1270edf5] x264_jll v2020.7.14+2\n  [dfaa095f] x265_jll v3.0.0+3\n  [d8fb68d0] xkbcommon_jll v0.9.1+5\n  [0dad84c5] ArgTools\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [b27032c2] LibCURL\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions\n  [44cfe95a] Pkg\n  [de0858da] Printf\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML\n  [a4e569a6] Tar\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll\n  [deac9b47] LibCURL_jll\n  [29816b5a] LibSSH2_jll\n  [c8ffd9c3] MbedTLS_jll\n  [14a3606d] MozillaCACerts_jll\n  [4536629a] OpenBLAS_jll\n  [bea87d4a] SuiteSparse_jll\n  [83775a58] Zlib_jll\n  [8e850ede] nghttp2_jll\n  [3f19e933] p7zip_jll","category":"page"},{"location":"perturbation/01-perturbation_algebraic/#Mixed-Symbolic/Numerical-Methods-for-Perturbation-Theory-Algebraic-Equations","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"","category":"section"},{"location":"perturbation/01-perturbation_algebraic/#Background","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Background","text":"","category":"section"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Symbolics.jl is a fast and modern Computer Algebra System (CAS) written in the Julia Programming Language. It is an integral part of the SciML ecosystem of differential equation solvers and scientific machine learning packages. While Symbolics.jl is primarily designed for modern scientific computing (e.g., auto-differentiation, machine learning), it is a powerful CAS and can also be useful for classic scientific computing. One such application is using the perturbation theory to solve algebraic and differential equations.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Perturbation methods are a collection of techniques to solve intractable problems that generally don't have a closed solution but depend on a tunable parameter and have closed or easy solutions for some values of the parameter. The main idea is to assume a solution as a power series in the tunable parameter (say ϵ), such that ϵ = 0 corresponds to an easy solution.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"We will discuss the general steps of the perturbation methods to solve algebraic (this tutorial) and differential equations (Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations).","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"The hallmark of the perturbation method is the generation of long and convoluted intermediate equations, which are subjected to algorithmic and mechanical manipulations. Therefore, these problems are well suited for CAS. In fact, CAS softwares have been used to help with the perturbation calculations since the early 1970s.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"In this tutorial our goal is to show how to use a mix of symbolic manipulations (Symbolics.jl) and numerical methods (DifferentialEquations.jl) to solve simple perturbation problems.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/#Solving-the-Quintic","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Solving the Quintic","text":"","category":"section"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"We start with the \"hello world!\" analog of the perturbation problems, solving the quintic (fifth-order) equations. We want to find a real valued x such that x^5 + x = 1. According to the Abel's theorem, a general quintic equation does not have a closed form solution. Of course, we can easily solve this equation numerically; for example, by using the Newton's method. We use the following implementation of the Newton's method:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"using Symbolics, SymbolicUtils\n\nfunction solve_newton(f, x, x₀; abstol=1e-8, maxiter=50)\n    xₙ = Float64(x₀)\n    fₙ₊₁ = x - f / Symbolics.derivative(f, x)\n\n    for i = 1:maxiter\n        xₙ₊₁ = substitute(fₙ₊₁, Dict(x => xₙ))\n        if abs(xₙ₊₁ - xₙ) < abstol\n            return xₙ₊₁\n        else\n            xₙ = xₙ₊₁\n        end\n    end\n    return xₙ₊₁\nend","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"solve_newton (generic function with 1 method)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"In this code, Symbolics.derivative(eq, x) does exactly what it names implies: it calculates the symbolic derivative of eq (a Symbolics.jl expression) with respect to x (a Symbolics.jl variable). We use Symbolics.substitute(eq, D) to evaluate the update formula by substituting variables or sub-expressions (defined in a dictionary D) in eq. It should be noted that substitute is the workhorse of our code and will be used multiple times in the rest of these tutorials. solve_newton is written with simplicity and clarity, and not performance, in mind but suffices for our purpose.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Let's go back to our quintic. We can define a Symbolics variable as @variables x and then solve the equation solve_newton(x^5 + x - 1, x, 1.0) (here, x₀ = 0 is our first guess). The answer is 0.7549. Now, let's see how we can solve the same problem using the perturbation methods.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"We introduce a tuning parameter epsilon into our equation: x^5 + epsilon x = 1. If epsilon = 1, we get our original problem. For epsilon = 0, the problem transforms to an easy one: x^5 = 1 which has an exact real solution x = 1 (and four complex solutions which we ignore here). We expand x as a power series on epsilon:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"$","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"x(\\epsilon) = a0 + a1 \\epsilon + a_2 \\epsilon^2 + O(\\epsilon^3)   \\,. $","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"a_0","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"is the solution of the easy equation, therefore a_0 = 1. Substituting into the original problem,","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"$","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"(a0 + a1 \\epsilon + a2 \\epsilon^2)^5 + \\epsilon (a0 + a1 \\epsilon + a2 \\epsilon^2) - 1 = 0   \\,. $","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Expanding the equations, we get $   \\epsilon (1 + 5 a1) + \\epsilon^2 (a1 + 5 a2 + 10 a12) + 𝑂(\\epsilon^3) = 0   \\,. $","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"This equation should hold for each power of epsilon. Therefore,","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"$","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"1 + 5 a_1 = 0   \\,, $","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"and","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"$","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"a1 + 5 a2 + 10 a_1^2 = 0   \\,. $","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"This system of equations does not initially seem to be linear because of the presence of terms like 10 a_1^2, but upon closer inspection is found to be in fact linear (this is a feature of the perturbation methods). In addition, the system is in a triangular form, meaning the first equation depends only on a_1, the second one on a_1 and a_2, such that we can replace the result of a_1 from the first one into the second equation and remove the non-linear term. We solve the first equation to get a_1 = -frac15. Substituting in the second one and solve for a_2:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"$","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"a_2 = \\frac{(-\\frac{1}{5} + 10(-(\\frac{1}{5})²)}{5}  = -\\frac{1}{25}   \\,. $","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Finally,","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"$","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"x(\\epsilon) = 1 - \\frac{\\epsilon}{5} - \\frac{\\epsilon^2}{25} + O(\\epsilon^3)   \\,. $","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Solving the original problem, x(1) = 076, compared to 0.7548 calculated numerically. We can improve the accuracy by including more terms in the expansion of x. However, the calculations, while straightforward, become messy and intractable to do manually very quickly. This is why a CAS is very helpful to solve perturbation problems.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Now, let's see how we can do these calculations in Julia. Let n be the order of the expansion. We start by defining the symbolic variables:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"n = 2\n@variables ϵ a[1:n]","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"2-element Vector{Any}:\n ϵ\n  Symbolics.Num[a₁, a₂]","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Then, we define","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"x = 1 + a[1]*ϵ + a[2]*ϵ^2","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"1 + a₁*ϵ + a₂*(ϵ^2)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"The next step is to substitute x in the problem equation","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"  eq = x^5 + ϵ*x - 1","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"ϵ*(1 + a₁*ϵ + a₂*(ϵ^2)) + (1 + a₁*ϵ + a₂*(ϵ^2))^5 - 1","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"The expanded form of eq is","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"expand(eq)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"ϵ + a₁*(ϵ^2) + a₂*(ϵ^3) + (a₁^5)*(ϵ^5) + (a₂^5)*(ϵ^10) + 5a₁*ϵ + 5a₂*(ϵ^2) \n+ 10(a₁^2)*(ϵ^2) + 10(a₁^3)*(ϵ^3) + 5(a₁^4)*(ϵ^4) + 10(a₂^2)*(ϵ^4) + 10(a₂^\n3)*(ϵ^6) + 5(a₂^4)*(ϵ^8) + 20a₁*a₂*(ϵ^3) + 30a₁*(a₂^2)*(ϵ^5) + 20a₁*(a₂^3)*\n(ϵ^7) + 5a₁*(a₂^4)*(ϵ^9) + 30a₂*(a₁^2)*(ϵ^4) + 20a₂*(a₁^3)*(ϵ^5) + 5a₂*(a₁^\n4)*(ϵ^6) + 30(a₁^2)*(a₂^2)*(ϵ^6) + 10(a₁^2)*(a₂^3)*(ϵ^8) + 10(a₁^3)*(a₂^2)*\n(ϵ^7)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"We need a way to get the coefficients of different powers of ϵ. Function collect_powers(eq, x, ns) returns the powers of variable x in expression eq. Argument ns is the range of the powers.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"function collect_powers(eq, x, ns; max_power=100)\n    eq = substitute(expand(eq), Dict(x^j => 0 for j=last(ns)+1:max_power))\n\n    eqs = []\n    for i in ns\n        powers = Dict(x^j => (i==j ? 1 : 0) for j=1:last(ns))\n        push!(eqs, substitute(eq, powers))\n    end\n    eqs\nend","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"collect_powers (generic function with 1 method)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"To return the coefficients of ϵ and ϵ^2 in eq, we can write","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"eqs = collect_powers(eq, ϵ, 1:2)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"2-element Vector{Any}:\n             1 + 5a₁\n a₁ + 5a₂ + 10(a₁^2)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"A few words on how collect_powers works, It uses substitute to find the coefficient of a given power of x by passing a Dict with all powers of x set to 0, except the target power which is set to 1. For example, the following expression returns the coefficient of ϵ^2 in eq,","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"substitute(expand(eq), Dict(\n  ϵ => 0,\n  ϵ^2 => 1,\n  ϵ^3 => 0,\n  ϵ^4 => 0,\n  ϵ^5 => 0,\n  ϵ^6 => 0,\n  ϵ^7 => 0,\n  ϵ^8 => 0)\n)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"a₁ + 5a₂ + 10(a₁^2)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Back to our problem. Having the coefficients of the powers of ϵ, we can set each equation in eqs to 0 (remember, we rearrange the problem such that eq is 0) and solve the system of linear equations to find the numerical values of the coefficients. Symbolics.jl has a function Symbolics.solve_for that can solve systems of linear equations. However, the presence of higher order terms in eqs prevents Symbolics.solve_for(eqs .~ 0, a) from workings properly. Instead, we can exploit the fact that our system is in a triangular form and start by solving eqs[1] for a₁ and then substitute this in eqs[2] and solve for a₂ (as continue the same process for higher order terms).  This cascading process is done by function solve_coef(eqs, ps):","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"function solve_coef(eqs, ps)\n    vals = Dict()\n\n    for i = 1:length(ps)\n        eq = substitute(eqs[i], vals)\n        vals[ps[i]] = Symbolics.solve_for(eq ~ 0, ps[i])\n    end\n    vals\nend","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"solve_coef (generic function with 1 method)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Here, eqs is an array of expressions (assumed to be equal to 0) and ps is an array of variables. The result is a dictionary of variable => value pairs. We apply solve_coef to eqs to get the numerical values of the parameters:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"solve_coef(eqs, a)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Dict{Any, Any} with 2 entries:\n  a₂ => -0.04\n  a₁ => -0.2","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Finally, we substitute back the values of a in the definition of x as a function of 𝜀. Note that 𝜀 is a number (usually Float64), whereas ϵ is a symbolic variable.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"X = 𝜀 -> 1 + a[1]*𝜀 + a[2]*𝜀^2","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"#9 (generic function with 1 method)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Therefore, the solution to our original problem becomes X(1), which is equal to 0.76. We can use larger values of n to improve the accuracy of estimations.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"n x\n1 0.8\n2 0.76\n3 0.752\n4 0.752\n5 0.7533\n6 0.7543\n7 0.7548\n8 0.7550","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Remember the numerical value is 0.7549. The two functions collect_powers and solve_coef(eqs, a) are used in all the examples in this and the next tutorial.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/#Solving-the-Kepler's-Equation","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Solving the Kepler's Equation","text":"","category":"section"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Historically, the perturbation methods were first invented to solve orbital calculations of the Moon and the planets. In homage to this history, our second example has a celestial theme. Our goal is solve the Kepler's equation:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"$","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"E - e\\sin(E) = M   \\,. $","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"where e is the eccentricity of the elliptical orbit, M is the mean anomaly, and E (unknown) is the eccentric anomaly (the angle between the position of a planet in an elliptical orbit and the point of periapsis). This equation is central to solving two-body Keplerian orbits.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Similar to the first example, it is easy to solve this problem using the Newton's method. For example, let e = 001671 (the eccentricity of the Earth) and M = pi2. We have solve_newton(x - e*sin(x) - M, x, M) equals to 1.5875 (compared to π/2 = 1.5708). Now, we try to solve the same problem using the perturbation techniques (see function test_kepler).","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"For e = 0, we get E = M. Therefore, we can use e as our perturbation parameter. For consistency with other problems, we also rename e to epsilon and E to x.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"From here on, we use the helper function def_taylor to define Taylor's series by calling it as x = def_taylor(ϵ, a, 1), where the arguments are, respectively, the perturbation variable, an array of coefficients (starting from the coefficient of epsilon^1), and an optional constant term.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"def_taylor(x, ps) = sum([a*x^i for (i,a) in enumerate(ps)])\ndef_taylor(x, ps, p₀) = p₀ + def_taylor(x, ps)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"def_taylor (generic function with 2 methods)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"We start by defining the variables (assuming n = 3):","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"n = 3\n@variables ϵ M a[1:n]\nx = def_taylor(ϵ, a, M)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"M + a₁*ϵ + a₂*(ϵ^2) + a₃*(ϵ^3)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"We further simplify by substituting sin with its power series using the expand_sin helper function:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"expand_sin(x, n) = sum([(isodd(k) ? -1 : 1)*(-x)^(2k-1)/factorial(2k-1) for k=1:n])","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"expand_sin (generic function with 1 method)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"To test,","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"expand_sin(0.1, 10) ≈ sin(0.1)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"true","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"The problem equation is","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"eq = x - ϵ * expand_sin(x, n) - M","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"a₁*ϵ + a₂*(ϵ^2) + a₃*(ϵ^3) - (ϵ*(M + a₁*ϵ + a₂*(ϵ^2) + a₃*(ϵ^3) + 0.1666666\n6666666666((-M - (a₁*ϵ) - (a₂*(ϵ^2)) - (a₃*(ϵ^3)))^3) - (0.0083333333333333\n33((-M - (a₁*ϵ) - (a₂*(ϵ^2)) - (a₃*(ϵ^3)))^5))))","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"We follow the same process as the first example. We collect the coefficients of the powers of ϵ","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"eqs = collect_powers(eq, ϵ, 1:n)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"3-element Vector{Any}:\n a₁ + 0.16666666666666666(M^3) - M - (0.008333333333333333(M^5))\n a₂ + 0.5a₁*(M^2) - a₁ - (0.041666666666666664a₁*(M^4))\n a₃ + 0.5M*(a₁^2) + 0.5a₂*(M^2) - a₂ - (0.041666666666666664a₂*(M^4)) - (0.\n08333333333333333(M^3)*(a₁^2))","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"and then solve for a:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"vals = solve_coef(eqs, a)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Dict{Any, Any} with 3 entries:\n  a₂ => M + 0.00833333(M^5) + 0.0416667(M + 0.00833333(M^5) - (0.166667(M^3\n)))*…\n  a₃ => M + 0.00833333(M^5) + 0.0416667(M + 0.00833333(M^5) - (0.166667(M^3\n)))*…\n  a₁ => M + 0.00833333(M^5) - (0.166667(M^3))","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Finally, we substitute vals back in x:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"x′ = substitute(x, vals)\nX = (𝜀, 𝑀) -> substitute(x′, Dict(ϵ => 𝜀, M => 𝑀))\nX(0.01671, π/2)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"1.5875853629172587","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"The result is 1.5876, compared to the numerical value of 1.5875. It is customary to order X based on the powers of 𝑀 instead of 𝜀. We can calculate this series as collect_powers(sol, M, 0:3). The result (after manual cleanup) is","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"(1 + 𝜀 + 𝜀^2 + 𝜀^3)*𝑀\n- (𝜀 + 4*𝜀^2 + 10*𝜀^3)*𝑀^3/6\n+ (𝜀 + 16*𝜀^2 + 91*𝜀^3)*𝑀^5/120","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Comparing the formula to the one for 𝐸 in the Wikipedia article on the Kepler's equation:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"$","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"E = \\frac{1}{1-\\epsilon}M     -\\frac{\\epsilon}{(1-\\epsilon)^4} \\frac{M^3}{3!} + \\frac{(9\\epsilon^2     + \\epsilon)}{(1-\\epsilon)^7}\\frac{M^5}{5!}\\cdots $","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"The first deviation is in the coefficient of epsilon^3 M^5.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/#Appendix","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Appendix","text":"","category":"section"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"tutorials/perturbation\",\"01-perturbation_algebraic.jmd\")","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Computer Information:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Julia Version 1.6.2\nCommit 1b93d53fc4 (2021-07-14 15:36 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, znver2)\nEnvironment:\n  JULIA_DEPOT_PATH = /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n  JULIA_NUM_THREADS = 16\n","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Package Information:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"      Status `/var/lib/buildkite-agent/builds/2-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/perturbation/Project.toml`\n  [0c46a032] DifferentialEquations v6.17.1\n  [961ee093] ModelingToolkit v5.17.3\n  [91a5bcdd] Plots v1.15.2\n  [30cb0354] SciMLTutorials v0.9.0\n  [d1185830] SymbolicUtils v0.11.2\n  [0c5d862f] Symbolics v0.1.25","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"And the full manifest:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"      Status `/var/lib/buildkite-agent/builds/2-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/perturbation/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.16.0\n  [1520ce14] AbstractTrees v0.3.4\n  [79e6a3ab] Adapt v3.3.0\n  [ec485272] ArnoldiMethod v0.1.0\n  [4fba245c] ArrayInterface v3.1.15\n  [4c555306] ArrayLayouts v0.7.0\n  [aae01518] BandedMatrices v0.16.9\n  [764a87c0] BoundaryValueDiffEq v2.7.1\n  [fa961155] CEnum v0.4.1\n  [00ebfdb7] CSTParser v2.5.0\n  [d360d2e6] ChainRulesCore v0.9.44\n  [b630d9fa] CheapThreads v0.2.5\n  [35d6a980] ColorSchemes v3.12.1\n  [3da002f7] ColorTypes v0.11.0\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [a80b9123] CommonMark v0.8.1\n  [38540f10] CommonSolve v0.2.0\n  [bbf7d656] CommonSubexpressions v0.3.0\n  [34da2185] Compat v3.30.0\n  [8f4d0f93] Conda v1.5.2\n  [187b0558] ConstructionBase v1.2.1\n  [d38c429a] Contour v0.5.7\n  [a8cc5b0e] Crayons v4.0.4\n  [9a962f9c] DataAPI v1.6.0\n  [864edb3b] DataStructures v0.18.9\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [bcd4f6db] DelayDiffEq v5.31.0\n  [2b5f629d] DiffEqBase v6.62.2\n  [459566f4] DiffEqCallbacks v2.16.1\n  [5a0ffddc] DiffEqFinancial v2.4.0\n  [c894b116] DiffEqJump v6.14.2\n  [77a26b50] DiffEqNoiseProcess v5.7.3\n  [055956cb] DiffEqPhysics v3.9.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.0.2\n  [0c46a032] DifferentialEquations v6.17.1\n  [c619ae07] DimensionalPlotRecipes v1.2.0\n  [b4f34e82] Distances v0.10.3\n  [31c24e10] Distributions v0.24.18\n  [ffbed154] DocStringExtensions v0.8.4\n  [e30172f5] Documenter v0.26.3\n  [d4d017d3] ExponentialUtilities v1.8.4\n  [e2ba6199] ExprTools v0.1.3\n  [c87230d0] FFMPEG v0.4.0\n  [7034ab61] FastBroadcast v0.1.8\n  [9aa1b823] FastClosures v0.3.2\n  [1a297f60] FillArrays v0.11.7\n  [6a86dc24] FiniteDiff v2.8.0\n  [53c48c17] FixedPointNumbers v0.8.4\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.18\n  [069b7b12] FunctionWrappers v1.1.2\n  [28b8d3ca] GR v0.57.4\n  [5c1252a2] GeometryBasics v0.3.12\n  [42e2da0e] Grisu v1.0.2\n  [cd3eb016] HTTP v0.9.9\n  [eafb193a] Highlights v0.4.5\n  [0e44f5e4] Hwloc v2.0.0\n  [7073ff75] IJulia v1.23.2\n  [b5f81e59] IOCapture v0.1.1\n  [615f187c] IfElse v0.1.0\n  [d25df0c9] Inflate v0.1.2\n  [83e8ac13] IniFile v0.5.0\n  [c8e1da08] IterTools v1.3.0\n  [42fd0dbc] IterativeSolvers v0.9.1\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.3.0\n  [682c06a0] JSON v0.21.1\n  [98e50ef6] JuliaFormatter v0.13.7\n  [b964fa9f] LaTeXStrings v1.2.1\n  [2ee39098] LabelledArrays v1.6.1\n  [23fbe1c1] Latexify v0.15.5\n  [093fc24a] LightGraphs v1.3.5\n  [d3d80556] LineSearches v7.1.1\n  [2ab3a3ac] LogExpFunctions v0.2.4\n  [bdcacae8] LoopVectorization v0.12.23\n  [1914dd2f] MacroTools v0.5.6\n  [739be429] MbedTLS v1.0.3\n  [442fdcdd] Measures v0.3.1\n  [e1d29d7a] Missings v1.0.0\n  [961ee093] ModelingToolkit v5.17.3\n  [46d2c3a1] MuladdMacro v0.2.2\n  [f9640e96] MultiScaleArrays v1.8.1\n  [ffc61752] Mustache v1.0.10\n  [d41bc354] NLSolversBase v7.8.0\n  [2774e3e8] NLsolve v4.5.1\n  [77ba4419] NaNMath v0.3.5\n  [8913a72c] NonlinearSolve v0.3.8\n  [6fe1bfb0] OffsetArrays v1.9.0\n  [429524aa] Optim v1.3.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [90014a1f] PDMats v0.11.0\n  [65888b18] ParameterizedFunctions v5.10.0\n  [d96e819e] Parameters v0.12.2\n  [69de0a69] Parsers v1.1.0\n  [ccf2f8ad] PlotThemes v2.0.1\n  [995b91a9] PlotUtils v1.0.10\n  [91a5bcdd] Plots v1.15.2\n  [e409e4f3] PoissonRandom v0.4.0\n  [f517fe37] Polyester v0.3.1\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [21216c6a] Preferences v1.2.2\n  [1fd47b50] QuadGK v2.4.1\n  [74087812] Random123 v1.3.1\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.4.0\n  [3cdcf5f2] RecipesBase v1.1.1\n  [01d81517] RecipesPipeline v0.3.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [f2c3362d] RecursiveFactorization v0.1.12\n  [189a3867] Reexport v1.0.0\n  [ae029012] Requires v1.1.3\n  [ae5879a3] ResettableStacks v1.1.0\n  [79098fc4] Rmath v0.7.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.2\n  [476501e8] SLEEFPirates v0.6.20\n  [1bc83da4] SafeTestsets v0.0.1\n  [0bca4576] SciMLBase v1.13.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [6c6a2e73] Scratch v1.0.3\n  [efcf1570] Setfield v0.7.0\n  [992d4aef] Showoff v1.0.3\n  [699a6c99] SimpleTraits v0.9.3\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.0\n  [47a9eef4] SparseDiffTools v1.13.2\n  [276daf66] SpecialFunctions v1.4.1\n  [aedffcd0] Static v0.2.4\n  [90137ffa] StaticArrays v1.2.0\n  [82ae8749] StatsAPI v1.0.0\n  [2913bbd2] StatsBase v0.33.8\n  [4c63d2b9] StatsFuns v0.9.8\n  [9672c7b4] SteadyStateDiffEq v1.6.2\n  [789caeaf] StochasticDiffEq v6.34.1\n  [7792a7ef] StrideArraysCore v0.1.11\n  [09ab397b] StructArrays v0.5.1\n  [c3572dad] Sundials v4.4.3\n  [d1185830] SymbolicUtils v0.11.2\n  [0c5d862f] Symbolics v0.1.25\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.4.2\n  [8290d209] ThreadingUtilities v0.4.4\n  [a759f4b9] TimerOutputs v0.5.9\n  [0796e94c] Tokenize v0.5.16\n  [a2a6695c] TreeViews v0.3.0\n  [5c2747f8] URIs v1.3.0\n  [3a884ed6] UnPack v1.0.2\n  [1986cc42] Unitful v1.7.0\n  [3d5dd08c] VectorizationBase v0.20.11\n  [81def892] VersionParsing v1.2.0\n  [19fa3120] VertexSafeGraphs v0.1.2\n  [44d3d7a6] Weave v0.10.8\n  [ddb6d928] YAML v0.4.6\n  [c2297ded] ZMQ v1.2.1\n  [700de1a5] ZygoteRules v0.2.1\n  [6e34b625] Bzip2_jll v1.0.6+5\n  [83423d85] Cairo_jll v1.16.0+6\n  [5ae413db] EarCut_jll v2.1.5+1\n  [2e619515] Expat_jll v2.2.10+0\n  [b22a6f82] FFMPEG_jll v4.3.1+4\n  [a3f928ae] Fontconfig_jll v2.13.1+14\n  [d7e528f0] FreeType2_jll v2.10.1+5\n  [559328eb] FriBidi_jll v1.0.5+6\n  [0656b61e] GLFW_jll v3.3.4+0\n  [d2c73de3] GR_jll v0.57.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.1+0\n  [e33a78d0] Hwloc_jll v2.4.1+0\n  [aacddb02] JpegTurbo_jll v2.0.1+3\n  [c1c5ebd0] LAME_jll v3.100.0+3\n  [dd4b983a] LZO_jll v2.10.1+0\n  [dd192d2f] LibVPX_jll v1.9.0+1\n  [e9f186c6] Libffi_jll v3.2.2+0\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+0\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.1.0+2\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [e7412a2a] Ogg_jll v1.3.4+2\n  [458c3c95] OpenSSL_jll v1.1.1+6\n  [efe28fd5] OpenSpecFun_jll v0.5.4+0\n  [91d4177d] Opus_jll v1.3.1+3\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.2+0\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.0+1\n  [a2964d1f] Wayland_jll v1.17.0+4\n  [2381bf8a] Wayland_protocols_jll v1.18.0+4\n  [02c8fc9c] XML2_jll v2.9.12+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.2+6\n  [3161d3a3] Zstd_jll v1.5.0+0\n  [0ac62f75] libass_jll v0.14.0+4\n  [f638f0a6] libfdk_aac_jll v0.1.6+4\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.6+6\n  [1270edf5] x264_jll v2020.7.14+2\n  [dfaa095f] x265_jll v3.0.0+3\n  [d8fb68d0] xkbcommon_jll v0.9.1+5\n  [0dad84c5] ArgTools\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [b27032c2] LibCURL\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions\n  [44cfe95a] Pkg\n  [de0858da] Printf\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML\n  [a4e569a6] Tar\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll\n  [deac9b47] LibCURL_jll\n  [29816b5a] LibSSH2_jll\n  [c8ffd9c3] MbedTLS_jll\n  [14a3606d] MozillaCACerts_jll\n  [4536629a] OpenBLAS_jll\n  [bea87d4a] SuiteSparse_jll\n  [83775a58] Zlib_jll\n  [8e850ede] nghttp2_jll\n  [3f19e933] p7zip_jll","category":"page"},{"location":"test/","page":"-","title":"-","text":"","category":"page"},{"location":"test/","page":"-","title":"-","text":"author: \"Chris Rackauckas\" title: \"Test\" –-","category":"page"},{"location":"test/","page":"-","title":"-","text":"This is a test of the builder system.","category":"page"},{"location":"test/#Appendix","page":"-","title":"Appendix","text":"","category":"section"},{"location":"test/","page":"-","title":"-","text":"This tutorial is part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl.  For more information on doing scientific machine learning (SciML) with open source software, check out https://sciml.ai/.","category":"page"},{"location":"test/","page":"-","title":"-","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"test/","page":"-","title":"-","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\".\",\"Testing/test.jmd\")","category":"page"},{"location":"test/","page":"-","title":"-","text":"Computer Information:","category":"page"},{"location":"test/","page":"-","title":"-","text":"Julia Version 1.6.1\nCommit 6aaedecc44 (2021-04-23 05:59 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin18.7.0)\n  CPU: Intel(R) Core(TM) i5-5350U CPU @ 1.80GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, broadwell)\nEnvironment:\n  JULIA_LOAD_PATH = @:/var/folders/lv/kg1z6t3s4wdf1sss2p42dr200000gn/T/jl_NMW2d4\n","category":"page"},{"location":"test/","page":"-","title":"-","text":"      Status `~/.julia/dev/SciMLTutorials/tutorials/Testing/Project.toml`\n  [30cb0354] SciMLTutorials v0.8.0","category":"page"},{"location":"test/","page":"-","title":"-","text":"And the full manifest:","category":"page"},{"location":"test/","page":"-","title":"-","text":"      Status `~/.julia/dev/SciMLTutorials/tutorials/Testing/Manifest.toml`\n  [621f4979] AbstractFFTs v1.0.1\n  [79e6a3ab] Adapt v3.3.0\n  [d360d2e6] ChainRulesCore v0.9.44\n  [35d6a980] ColorSchemes v3.12.1\n  [3da002f7] ColorTypes v0.11.0\n  [5ae59095] Colors v0.12.8\n  [34da2185] Compat v3.30.0\n  [8f4d0f93] Conda v1.5.2\n  [d38c429a] Contour v0.5.7\n  [717857b8] DSP v0.6.10\n  [9a962f9c] DataAPI v1.6.0\n  [864edb3b] DataStructures v0.18.9\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [ffbed154] DocStringExtensions v0.8.4\n  [e2ba6199] ExprTools v0.1.3\n  [8f5d6c58] EzXML v1.1.0\n  [c87230d0] FFMPEG v0.4.0\n  [7a1cc6ca] FFTW v1.4.1\n  [53c48c17] FixedPointNumbers v0.8.4\n  [59287772] Formatting v0.4.2\n  [28b8d3ca] GR v0.57.4\n  [5c1252a2] GeometryBasics v0.3.12\n  [42e2da0e] Grisu v1.0.2\n  [cd3eb016] HTTP v0.9.8\n  [eafb193a] Highlights v0.4.5\n  [7073ff75] IJulia v1.23.2\n  [83e8ac13] IniFile v0.5.0\n  [d8418881] Intervals v1.5.0\n  [c8e1da08] IterTools v1.3.0\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.3.0\n  [682c06a0] JSON v0.21.1\n  [b964fa9f] LaTeXStrings v1.2.1\n  [23fbe1c1] Latexify v0.15.5\n  [2ab3a3ac] LogExpFunctions v0.2.4\n  [1914dd2f] MacroTools v0.5.6\n  [739be429] MbedTLS v1.0.3\n  [442fdcdd] Measures v0.3.1\n  [e1d29d7a] Missings v1.0.0\n  [78c3b35d] Mocking v0.7.1\n  [ffc61752] Mustache v1.0.10\n  [77ba4419] NaNMath v0.3.5\n  [6fe1bfb0] OffsetArrays v1.8.0\n  [bac558e1] OrderedCollections v1.4.1\n  [69de0a69] Parsers v1.1.0\n  [ccf2f8ad] PlotThemes v2.0.1\n  [995b91a9] PlotUtils v1.0.10\n  [91a5bcdd] Plots v1.15.2\n  [f27b6e38] Polynomials v1.2.1\n  [21216c6a] Preferences v1.2.2\n  [3cdcf5f2] RecipesBase v1.1.1\n  [01d81517] RecipesPipeline v0.3.2\n  [189a3867] Reexport v1.0.0\n  [ae029012] Requires v1.1.3\n  [30cb0354] SciMLTutorials v0.8.0\n  [6c6a2e73] Scratch v1.0.3\n  [992d4aef] Showoff v1.0.3\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.0\n  [276daf66] SpecialFunctions v1.4.1\n  [90137ffa] StaticArrays v1.2.0\n  [82ae8749] StatsAPI v1.0.0\n  [2913bbd2] StatsBase v0.33.8\n  [09ab397b] StructArrays v0.5.1\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.4.2\n  [f269a46b] TimeZones v1.5.5\n  [5c2747f8] URIs v1.3.0\n  [81def892] VersionParsing v1.2.0\n  [44d3d7a6] Weave v0.10.8\n  [ddb6d928] YAML v0.4.6\n  [c2297ded] ZMQ v1.2.1\n  [6e34b625] Bzip2_jll v1.0.6+5\n  [83423d85] Cairo_jll v1.16.0+6\n  [5ae413db] EarCut_jll v2.1.5+1\n  [2e619515] Expat_jll v2.2.10+0\n  [b22a6f82] FFMPEG_jll v4.3.1+4\n  [f5851436] FFTW_jll v3.3.9+7\n  [a3f928ae] Fontconfig_jll v2.13.1+14\n  [d7e528f0] FreeType2_jll v2.10.1+5\n  [559328eb] FriBidi_jll v1.0.5+6\n  [0656b61e] GLFW_jll v3.3.4+0\n  [d2c73de3] GR_jll v0.57.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.1+0\n  [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2\n  [aacddb02] JpegTurbo_jll v2.0.1+3\n  [c1c5ebd0] LAME_jll v3.100.0+3\n  [dd4b983a] LZO_jll v2.10.0+3\n  [dd192d2f] LibVPX_jll v1.9.0+1\n  [e9f186c6] Libffi_jll v3.2.2+0\n  [d4300ac3] Libgcrypt_jll v1.8.5+4\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.36.0+3\n  [94ce4f54] Libiconv_jll v1.16.1+0\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.1.0+2\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [856f044c] MKL_jll v2021.1.1+1\n  [e7412a2a] Ogg_jll v1.3.4+2\n  [458c3c95] OpenSSL_jll v1.1.1+6\n  [efe28fd5] OpenSpecFun_jll v0.5.4+0\n  [91d4177d] Opus_jll v1.3.1+3\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.0+0\n  [ea2cea3b] Qt5Base_jll v5.15.2+0\n  [a2964d1f] Wayland_jll v1.17.0+4\n  [2381bf8a] Wayland_protocols_jll v1.18.0+4\n  [02c8fc9c] XML2_jll v2.9.12+0\n  [aed1982a] XSLT_jll v1.1.33+4\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.2+6\n  [3161d3a3] Zstd_jll v1.5.0+0\n  [0ac62f75] libass_jll v0.14.0+4\n  [f638f0a6] libfdk_aac_jll v0.1.6+4\n  [b53b4c65] libpng_jll v1.6.37+6\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.6+6\n  [1270edf5] x264_jll v2020.7.14+2\n  [dfaa095f] x265_jll v3.0.0+3\n  [d8fb68d0] xkbcommon_jll v0.9.1+5\n  [0dad84c5] ArgTools\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads\n  [7b1f6079] FileWatching\n  [b77e0a4c] InteractiveUtils\n  [4af54fe1] LazyArtifacts\n  [b27032c2] LibCURL\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions\n  [44cfe95a] Pkg\n  [de0858da] Printf\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [fa267f1f] TOML\n  [a4e569a6] Tar\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll\n  [deac9b47] LibCURL_jll\n  [29816b5a] LibSSH2_jll\n  [c8ffd9c3] MbedTLS_jll\n  [14a3606d] MozillaCACerts_jll\n  [83775a58] Zlib_jll\n  [8e850ede] nghttp2_jll\n  [3f19e933] p7zip_jll","category":"page"},{"location":"introduction/05-formatting_plots/#Formatting-Plots","page":"Formatting Plots","title":"Formatting Plots","text":"","category":"section"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"Since the plotting functionality is implemented as a recipe to Plots.jl, all of the options open to Plots.jl can be used in our plots. In addition, there are special features specifically for differential equation plots. This tutorial will teach some of the most commonly used options. Let's first get the solution to some ODE. Here I will use one of the Lorenz ordinary differential equation. As with all commands in DifferentialEquations.jl, I got a plot of the solution by calling solve on the problem, and plot on the solution:","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"\nusing DifferentialEquations, Plots, ParameterizedFunctions\ngr()\nlorenz = @ode_def Lorenz begin\n  dx = σ*(y-x)\n  dy = ρ*x-y-x*z\n  dz = x*y-β*z\nend σ β ρ\n\np = [10.0,8/3,28]\nu0 = [1., 5., 10.]\ntspan = (0., 100.)\nprob = ODEProblem(lorenz, u0, tspan, p)\nsol = solve(prob)","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"retcode: Success\nInterpolation: automatic order switching interpolation\nt: 1341-element Array{Float64,1}:\n   0.0\n   0.0354861341350177\n   0.060663987304508726\n   0.10188870843348657\n   0.1448498679508511\n   0.19835698662820245\n   0.2504996228815297\n   0.3056774805827286\n   0.35452829390108126\n   0.40770996764610945\n   ⋮\n  99.40191484990574\n  99.47703618501833\n  99.5658234308723\n  99.64807844262198\n  99.72393302893481\n  99.80148021054468\n  99.87335069245553\n  99.95168876649775\n 100.0\nu: 1341-element Array{Array{Float64,1},1}:\n [1.0, 5.0, 10.0]\n [2.3156522358261684, 5.897559436807755, 9.406792559102836]\n [3.237795350433643, 7.041031570475972, 9.233678311348145]\n [4.993868184294177, 9.832941470623643, 9.626109614367385]\n [7.42118455058636, 13.9492707343288, 11.582332131961147]\n [11.459763300544093, 19.75311392425321, 18.104295519177246]\n [15.47610807576506, 21.51087067675479, 29.88726710651812]\n [16.447464107891538, 13.124038426772515, 40.97121918674208]\n [12.877766779212395, 2.6188678957805847, 41.25247282418837]\n [7.136964977854118, -3.093417466070861, 35.505128642604284]\n ⋮\n [4.7078175125017845, 7.13104508677844, 18.651036529533698]\n [6.95971825488835, 10.593018553812076, 18.7863316112588]\n [10.646351699805901, 14.856180479322331, 23.998423289322353]\n [12.889615395081899, 13.273612975413583, 32.38413265349776]\n [11.146319066255193, 6.620076861975365, 34.91435700264157]\n [7.21823680615282, 2.4325891343715225, 31.07382292211859]\n [4.528555141302391, 1.9195182135779243, 26.403651898710038]\n [3.35872786591478, 2.855562241006029, 22.042971594934365]\n [3.3579402595045926, 3.829807498655525, 19.879219936458707]","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"\nplot(sol)","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"(Image: )","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"Now let's change it to a phase plot. As discussed in the plot functions page, we can use the vars command to choose the variables to plot. Let's plot variable x vs variable y vs variable z:","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"\nplot(sol,vars=(1, 2, 3))","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"(Image: )","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"We can also choose to plot the timeseries for a single variable:","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"\nplot(sol,vars=[:x])","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"(Image: )","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"Notice that we were able to use the variable names because we had defined the problem with the macro. But in general, we can use the indices. The previous plots would be:","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"\nplot(sol,vars=(1,2,3))\nplot(sol,vars=[1])","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"(Image: )","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"Common options are to add titles, axis, and labels. For example:","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"\nplot(sol,linewidth=5,title=\"Solution to the linear ODE with a thick line\",\nxaxis=\"Time (t)\",yaxis=\"u(t) (in mm)\",label=[\"X\",\"Y\",\"Z\"])","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"(Image: )","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"Notice that series recipes apply to the solution type as well. For example, we can use a scatter plot on the timeseries:","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"\nscatter(sol,vars=[:x])","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"(Image: )","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"This shows that the recipe is using the interpolation to smooth the plot. It becomes abundantly clear when we turn it off using denseplot=false:","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"\nplot(sol,vars=(1,2,3),denseplot=false)","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"(Image: )","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"When this is done, only the values the timestep hits are plotted. Using the interpolation usually results in a much nicer looking plot so it's recommended, and since the interpolations have similar orders to the numerical methods, their results are trustworthy on the full interval. We can control the number of points used in the interpolation's plot using the plotdensity command:","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"\nplot(sol,vars=(1,2,3),plotdensity=100)","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"(Image: )","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"That's plotting the entire solution using 100 points spaced evenly in time.","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"\nplot(sol,vars=(1,2,3),plotdensity=10000)","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"(Image: )","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"That's more like it! By default it uses 100*length(sol), where the length is the number of internal steps it had to take. This heuristic usually does well, but unusually difficult equations it can be relaxed (since it will take small steps), and for equations with events / discontinuities raising the plot density can help resolve the discontinuity.","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"Lastly notice that we can compose plots. Let's show where the 100 points are using a scatter plot:","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"\nplot(sol,vars=(1,2,3))\nscatter!(sol,vars=(1,2,3),plotdensity=100)","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"(Image: )","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"We can instead work with an explicit plot object. This form can be better for building a complex plot in a loop.","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"\np = plot(sol,vars=(1,2,3))\nscatter!(p,sol,vars=(1,2,3),plotdensity=100)\ntitle!(\"I added a title\")","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"(Image: )","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"You can do all sorts of things. Have fun!","category":"page"},{"location":"introduction/05-formatting_plots/#Appendix","page":"Formatting Plots","title":"Appendix","text":"","category":"section"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"This tutorial is part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl.  For more information on doing scientific machine learning (SciML) with open source software, check out https://sciml.ai/.","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"introduction\",\"05-formatting_plots.jmd\")","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"Computer Information:","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"Julia Version 1.4.2\nCommit 44fa15b150* (2020-05-23 18:35 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Core(TM) i7-9700K CPU @ 3.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-8.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_LOAD_PATH = /builds/JuliaGPU/DiffEqTutorials.jl:\n  JULIA_DEPOT_PATH = /builds/JuliaGPU/DiffEqTutorials.jl/.julia\n  JULIA_CUDA_MEMORY_LIMIT = 2147483648\n  JULIA_NUM_THREADS = 8\n","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"Package Information:","category":"page"},{"location":"introduction/05-formatting_plots/","page":"Formatting Plots","title":"Formatting Plots","text":"Status `/builds/JuliaGPU/DiffEqTutorials.jl/tutorials/introduction/Project.toml`\n[6e4b80f9-dd63-53aa-95a3-0cdb28fa8baf] BenchmarkTools 0.5.0\n[0c46a032-eb83-5123-abaf-570d42b7fbaa] DifferentialEquations 6.15.0\n[65888b18-ceab-5e60-b2b9-181511a3b968] ParameterizedFunctions 5.6.0\n[91a5bcdd-55d7-5caf-9e0b-520d859cae80] Plots 1.6.3\n[90137ffa-7385-5640-81b9-e52037218182] StaticArrays 0.12.4\n[c3572dad-4567-51f8-b174-8c6c989267f4] Sundials 4.3.0\n[37e2e46d-f89d-539d-b4ee-838fcccc9c8e] LinearAlgebra","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/#Bayesian-Inference-on-a-Pendulum-using-DiffEqBayes.jl","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"","category":"section"},{"location":"model_inference/01-pendulum_bayesian_inference/#Set-up-simple-pendulum-problem","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Set up simple pendulum problem","text":"","category":"section"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"using DiffEqBayes, OrdinaryDiffEq, RecursiveArrayTools, Distributions, Plots, StatsPlots, BenchmarkTools, TransformVariables, CmdStan, DynamicHMC","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"Let's define our simple pendulum problem. Here our pendulum has a drag term ω and a length L.","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"(Image: pendulum)","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"We get first order equations by defining the first term as the velocity and the second term as the position, getting:","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"function pendulum(du,u,p,t)\n    ω,L = p\n    x,y = u\n    du[1] = y\n    du[2] = - ω*y -(9.8/L)*sin(x)\nend\n\nu0 = [1.0,0.1]\ntspan = (0.0,10.0)\nprob1 = ODEProblem(pendulum,u0,tspan,[1.0,2.5])","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"ODEProblem with uType Array{Float64,1} and tType Float64. In-place: true\ntimespan: (0.0, 10.0)\nu0: [1.0, 0.1]","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/#Solve-the-model-and-plot","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Solve the model and plot","text":"","category":"section"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"To understand the model and generate data, let's solve and visualize the solution with the known parameters:","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"sol = solve(prob1,Tsit5())\nplot(sol)","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"(Image: )","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"It's the pendulum, so you know what it looks like. It's periodic, but since we have not made a small angle assumption it's not exactly sin or cos. Because the true dampening parameter ω is 1, the solution does not decay over time, nor does it increase. The length L determines the period.","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/#Create-some-dummy-data-to-use-for-estimation","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Create some dummy data to use for estimation","text":"","category":"section"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"We now generate some dummy data to use for estimation","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"t = collect(range(1,stop=10,length=10))\nrandomized = VectorOfArray([(sol(t[i]) + .01randn(2)) for i in 1:length(t)])\ndata = convert(Array,randomized)","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"2×10 Array{Float64,2}:\n  0.0669231  -0.377851  0.119404   0.0795968  …  -0.01553     0.00535298\n -1.21411     0.344681  0.323712  -0.253243       0.0164092  -0.00897403","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"Let's see what our data looks like on top of the real solution","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"scatter!(data')","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"(Image: )","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"This data captures the non-dampening effect and the true period, making it perfect to attempting a Bayesian inference.","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/#Perform-Bayesian-Estimation","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Perform Bayesian Estimation","text":"","category":"section"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"Now let's fit the pendulum to the data. Since we know our model is correct, this should give us back the parameters that we used to generate the data! Define priors on our parameters. In this case, let's assume we don't have much information, but have a prior belief that ω is between 0.1 and 3.0, while the length of the pendulum L is probably around 3.0:","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"priors = [Uniform(0.1,3.0), Normal(3.0,1.0)]","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"2-element Array{Distributions.Distribution{Distributions.Univariate,Distrib\nutions.Continuous},1}:\n Distributions.Uniform{Float64}(a=0.1, b=3.0)\n Distributions.Normal{Float64}(μ=3.0, σ=1.0)","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"Finally let's run the estimation routine from DiffEqBayes.jl with the Turing.jl backend to check if we indeed recover the parameters!","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"bayesian_result = turing_inference(prob1,Tsit5(),t,data,priors;num_samples=10_000,\n                                   syms = [:omega,:L])","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"Chains MCMC chain (9000×15×1 Array{Float64,3}):\n\nIterations        = 1:9000\nThinning interval = 1\nChains            = 1\nSamples per chain = 9000\nparameters        = L, omega, σ[1]\ninternals         = acceptance_rate, hamiltonian_energy, hamiltonian_energy\n_error, is_accept, log_density, lp, max_hamiltonian_energy_error, n_steps, \nnom_step_size, numerical_error, step_size, tree_depth\n\nSummary Statistics\n  parameters      mean       std   naive_se      mcse         ess      rhat\n  \n      Symbol   Float64   Float64    Float64   Float64     Float64   Float64\n  \n                                                                           \n  \n           L    2.5036    0.2148     0.0023    0.0035   3703.0703    1.0000\n  \n       omega    1.0777    0.2217     0.0023    0.0048   2000.0506    1.0008\n  \n        σ[1]    0.1603    0.0390     0.0004    0.0007   3326.8139    0.9999\n  \n\nQuantiles\n  parameters      2.5%     25.0%     50.0%     75.0%     97.5%  \n      Symbol   Float64   Float64   Float64   Float64   Float64  \n                                                                \n           L    2.0761    2.3766    2.5024    2.6302    2.9287  \n       omega    0.7670    0.9384    1.0395    1.1706    1.6059  \n        σ[1]    0.1018    0.1325    0.1540    0.1812    0.2529","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"Notice that while our guesses had the wrong means, the learned parameters converged to the correct means, meaning that it learned good posterior distributions for the parameters. To look at these posterior distributions on the parameters, we can examine the chains:","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"plot(bayesian_result)","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"(Image: )","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"As a diagnostic, we will also check the parameter chains. The chain is the MCMC sampling process. The chain should explore parameter space and converge reasonably well, and we should be taking a lot of samples after it converges (it is these samples that form the posterior distribution!)","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"plot(bayesian_result, colordim = :parameter)","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"(Image: )","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"Notice that after awhile these chains converge to a \"fuzzy line\", meaning it found the area with the most likelihood and then starts to sample around there, which builds a posterior distribution around the true mean.","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"DiffEqBayes.jl allows the choice of using Stan.jl, Turing.jl and DynamicHMC.jl for MCMC, you can also use ApproxBayes.jl for Approximate Bayesian computation algorithms. Let's compare the timings across the different MCMC backends. We'll stick with the default arguments and 10,000 samples in each since there is a lot of room for micro-optimization specific to each package and algorithm combinations, you might want to do your own experiments for specific problems to get better understanding of the performance.","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"@btime bayesian_result = turing_inference(prob1,Tsit5(),t,data,priors;syms = [:omega,:L],num_samples=10_000)","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"2.710 s (23598867 allocations: 1.50 GiB)\nChains MCMC chain (9000×15×1 Array{Float64,3}):\n\nIterations        = 1:9000\nThinning interval = 1\nChains            = 1\nSamples per chain = 9000\nparameters        = L, omega, σ[1]\ninternals         = acceptance_rate, hamiltonian_energy, hamiltonian_energy\n_error, is_accept, log_density, lp, max_hamiltonian_energy_error, n_steps, \nnom_step_size, numerical_error, step_size, tree_depth\n\nSummary Statistics\n  parameters      mean       std   naive_se      mcse         ess      rhat\n  \n      Symbol   Float64   Float64    Float64   Float64     Float64   Float64\n  \n                                                                           \n  \n           L    2.5019    0.2081     0.0022    0.0034   3767.3721    1.0000\n  \n       omega    1.0773    0.2137     0.0023    0.0040   2973.1493    1.0001\n  \n        σ[1]    0.1593    0.0371     0.0004    0.0006   4173.1326    1.0004\n  \n\nQuantiles\n  parameters      2.5%     25.0%     50.0%     75.0%     97.5%  \n      Symbol   Float64   Float64   Float64   Float64   Float64  \n                                                                \n           L    2.0844    2.3770    2.5029    2.6269    2.9178  \n       omega    0.7660    0.9383    1.0424    1.1743    1.6056  \n        σ[1]    0.1032    0.1325    0.1538    0.1793    0.2468","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"@btime bayesian_result = stan_inference(prob1,t,data,priors;num_samples=10_000,printsummary=false)","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"Error: MethodError: no method matching iterate(::ModelingToolkit.ODESystem)\nClosest candidates are:\n  iterate(!Matched::Core.SimpleVector) at essentials.jl:603\n  iterate(!Matched::Core.SimpleVector, !Matched::Any) at essentials.jl:603\n  iterate(!Matched::ExponentialBackOff) at error.jl:253\n  ...","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"@btime bayesian_result = dynamichmc_inference(prob1,Tsit5(),t,data,priors;num_samples = 10_000)","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"6.027 s (40540072 allocations: 3.52 GiB)\n(posterior = NamedTuple{(:parameters, :σ),Tuple{Array{Float64,1},Array{Floa\nt64,1}}}[(parameters = [0.9925322562437633, 2.499846186491921], σ = [0.0059\n66804814045917, 0.008177933301622841]), (parameters = [0.9963837443808898, \n2.502334158254934], σ = [0.006778656235910425, 0.009222937077381753]), (par\nameters = [1.0036593578298718, 2.5036585671312954], σ = [0.0052096129327429\n53, 0.009389702547257326]), (parameters = [1.012182569162702, 2.49418373759\n8965], σ = [0.009352843917833122, 0.006784007433840137]), (parameters = [0.\n9776075654162109, 2.506917713604719], σ = [0.00819375792385741, 0.008509449\n758223278]), (parameters = [0.9711538245294002, 2.52311064587977], σ = [0.0\n08075286197741678, 0.008380689150424841]), (parameters = [1.030127379473760\n4, 2.4900769004417103], σ = [0.005671628576862689, 0.009404135319949877]), \n(parameters = [1.027662532372297, 2.47639876182845], σ = [0.005769289829077\n621, 0.010107438192968452]), (parameters = [1.02159465396289, 2.47247053938\n56765], σ = [0.005902386622399507, 0.009452950393124696]), (parameters = [1\n.022343560476168, 2.4776243412273726], σ = [0.0058799594731072675, 0.009630\n482440656476])  …  (parameters = [0.99920993073967, 2.507790860320399], σ =\n [0.011498727162582899, 0.009257041097492019]), (parameters = [1.0033967451\n562795, 2.5151332738328414], σ = [0.009519097562008954, 0.00920901544856593\n2]), (parameters = [0.9976601690281769, 2.507783954703131], σ = [0.00947878\n0454357206, 0.008575044597729732]), (parameters = [0.9944432965906622, 2.50\n63137783766347], σ = [0.006264533060570234, 0.00805770806170044]), (paramet\ners = [0.995789590567554, 2.507352981860877], σ = [0.005952805608239749, 0.\n008806071695367526]), (parameters = [1.0082385919204935, 2.497953403941628]\n, σ = [0.005182367418104671, 0.008522531747426976]), (parameters = [0.99962\n84152075758, 2.5189801260651614], σ = [0.009705763622756209, 0.010744838454\n615106]), (parameters = [1.0119656370109682, 2.494765752066562], σ = [0.004\n729975947126395, 0.007155123027207663]), (parameters = [1.0046646904759642,\n 2.4934723249796953], σ = [0.005248078221127134, 0.008421618259762318]), (p\narameters = [1.005881733899965, 2.5009460269940513], σ = [0.005481409918559\n183, 0.008388170512741225])], chain = [[-0.007495766955188785, 0.9162292045\n781582, -5.121543701879515, -4.8063158129028745], [-0.0036228100779651584, \n0.9172239595836579, -4.993976391966563, -4.686061737110957], [0.00365267866\n93412507, 0.917753088961152, -5.257249719116282, -4.66814166387209], [0.012\n108958905343204, 0.913961516396238, -4.6720748195944335, -4.993187284703021\n], [-0.022646951830213737, 0.9190539959828018, -4.804382643391568, -4.76657\n7996745424], [-0.029270404566869655, 0.9254925235842713, -4.818946968056696\n, -4.781825130348601], [0.029682463987115947, 0.9123135937112545, -5.172278\n975524333, -4.666605758791736], [0.02728683723620924, 0.9068053926743036, -\n5.155206285919641, -4.5944836714353015], [0.021364792718281282, 0.905217869\n1295568, -5.132398497592392, -4.6614283752915044], [0.022097600140248842, 0\n.9073001741472317, -5.13620540942405, -4.64282195674715]  …  [-0.0007903815\n295350864, 0.9194022302666618, -4.465518931253114, -4.682370817294514], [0.\n0033909892480041516, 0.9223257937313328, -4.654455228578712, -4.68757233469\n34475], [-0.0023425726538614036, 0.9193994765973328, -4.65869961504571, -4.\n7588990850422315], [-0.0055721993164947236, 0.9188130594802799, -5.07285122\n4845033, -4.821126122491971], [-0.004219298165150283, 0.9192276077735035, -\n5.123892639763714, -4.732313830031988], [0.008204839974368702, 0.9154717581\n833844, -5.262493296595247, -4.765041828828386], [-0.0003716538471601385, 0\n.9238541077264724, -4.63503538201953, -4.533329783471124], [0.0118946147660\n13212, 0.914194837848557, -5.353835161665349, -4.939926671543258], [0.00465\n384452294309, 0.9136762470772759, -5.249893322511043, -4.776953276823668], \n[0.0058645040311212536, 0.9166690710924666, -5.20639292670556, -4.780932837\n9729665]], tree_statistics = DynamicHMC.TreeStatisticsNUTS[DynamicHMC.TreeS\ntatisticsNUTS(50.56734359829101, 3, turning at positions -2:5, 0.9755240439\n296025, 7, DynamicHMC.Directions(0x60136a7d)), DynamicHMC.TreeStatisticsNUT\nS(53.21141797289948, 4, turning at positions -15:-30, 0.9303977362255577, 3\n1, DynamicHMC.Directions(0xf1231261)), DynamicHMC.TreeStatisticsNUTS(54.360\n60487933965, 4, turning at positions -1:14, 0.9893416328240263, 15, Dynamic\nHMC.Directions(0xe900c27e)), DynamicHMC.TreeStatisticsNUTS(52.0483617779477\n5, 5, turning at positions -21:10, 0.9309817421978657, 31, DynamicHMC.Direc\ntions(0xe9e3438a)), DynamicHMC.TreeStatisticsNUTS(49.87055132316347, 3, tur\nning at positions 11:14, 0.8572610926819243, 15, DynamicHMC.Directions(0x29\n4e978e)), DynamicHMC.TreeStatisticsNUTS(49.19262263342683, 2, turning at po\nsitions -2:1, 0.9759539124756529, 3, DynamicHMC.Directions(0xdbea4a09)), Dy\nnamicHMC.TreeStatisticsNUTS(48.43198128487201, 3, turning at positions -7:0\n, 0.981239057221168, 7, DynamicHMC.Directions(0x6fcc3a70)), DynamicHMC.Tree\nStatisticsNUTS(47.63166261616587, 2, turning at positions -3:0, 0.995085735\n1314513, 3, DynamicHMC.Directions(0xe54734a8)), DynamicHMC.TreeStatisticsNU\nTS(46.56863924159915, 3, turning at positions -5:-12, 0.905437436880739, 15\n, DynamicHMC.Directions(0xea3a9733)), DynamicHMC.TreeStatisticsNUTS(49.6833\n97905049375, 1, turning at positions -1:0, 1.0, 1, DynamicHMC.Directions(0x\n1fab498e))  …  DynamicHMC.TreeStatisticsNUTS(51.65316234412242, 4, turning \nat positions 3:18, 0.9415872806438115, 31, DynamicHMC.Directions(0xa9468a12\n)), DynamicHMC.TreeStatisticsNUTS(51.711606238318794, 3, turning at positio\nns -1:6, 0.8623986191786585, 7, DynamicHMC.Directions(0x51644e36)), Dynamic\nHMC.TreeStatisticsNUTS(51.919656641254015, 4, turning at positions -8:-23, \n0.9084259271209352, 31, DynamicHMC.Directions(0x3319ca68)), DynamicHMC.Tree\nStatisticsNUTS(53.202536402977834, 3, turning at positions 6:13, 0.96705305\n01687453, 15, DynamicHMC.Directions(0x5012713d)), DynamicHMC.TreeStatistics\nNUTS(52.73931670212959, 3, turning at positions -4:-11, 0.9929665212170776,\n 15, DynamicHMC.Directions(0x6329d9e4)), DynamicHMC.TreeStatisticsNUTS(54.1\n31036067725944, 3, turning at positions -4:-11, 0.9888188927167221, 15, Dyn\namicHMC.Directions(0x8b23b0b4)), DynamicHMC.TreeStatisticsNUTS(51.488325981\n24062, 4, turning at positions 0:15, 0.6147719493975838, 15, DynamicHMC.Dir\nections(0xfc3d19af)), DynamicHMC.TreeStatisticsNUTS(49.47067467051124, 4, t\nurning at positions -13:2, 0.9105644910181027, 15, DynamicHMC.Directions(0x\ncd45ce02)), DynamicHMC.TreeStatisticsNUTS(48.9855447707631, 3, turning at p\nositions -2:5, 0.5761761677703705, 7, DynamicHMC.Directions(0xd968714d)), D\nynamicHMC.TreeStatisticsNUTS(54.41136057897444, 3, turning at positions -3:\n4, 0.9945976434248669, 7, DynamicHMC.Directions(0x77185434))], κ = Gaussian\n kinetic energy (Diagonal), √diag(M⁻¹): [0.022077917058954552, 0.0202796088\n43069858, 0.2918638996850573, 0.24966858752333757], ϵ = 0.17395099027012478\n)","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/#An-Intro-to-Expectations-via-DiffEqUncertainty.jl","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"","category":"section"},{"location":"DiffEqUncertainty/01-expectation_introduction/#System-Model","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"System Model","text":"","category":"section"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"First, lets consider the following linear model.","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"u = p u","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nf(u,p,t) = p.*u","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"f (generic function with 1 method)","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"We then wish to solve this model on the timespan t=0.0 to t=10.0, with an intial condition u0=10.0 and parameter p=-0.3. We can then setup the differential equations, solve, and plot as follows","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nusing DifferentialEquations, Plots\nu0 = [10.0]\np = [-0.3]\ntspan = (0.0,10.0)\nprob = ODEProblem(f,u0,tspan,p)\nsol = solve(prob)\nplot(sol)\nylims!(0.0,10.0)","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"(Image: )","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"However, what if we wish to consider a random initial condition? Assume u0 is distributed uniformly from -10.0 to 10.0, i.e.,","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nusing Distributions\nu0_dist = [Uniform(-10.0,10.0)]","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"1-element Array{Distributions.Uniform{Float64},1}:\n Distributions.Uniform{Float64}(a=-10.0, b=10.0)","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"We can then run a Monte Carlo simulation of 100,000 trajectories by solving an EnsembleProblem. ","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nprob_func(prob,i,repeat) = remake(prob, u0 = rand.(u0_dist))\nensemble_prob = EnsembleProblem(prob,prob_func=prob_func)\n\nensemblesol = solve(ensemble_prob,Tsit5(),EnsembleThreads(),trajectories=100000)","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"EnsembleSolution Solution of length 100000 with uType:\nDiffEqBase.ODESolution{Float64,2,Array{Array{Float64,1},1},Nothing,Nothing,\nArray{Float64,1},Array{Array{Array{Float64,1},1},1},DiffEqBase.ODEProblem{A\nrray{Float64,1},Tuple{Float64,Float64},false,Array{Float64,1},DiffEqBase.OD\nEFunction{false,typeof(Main.##WeaveSandBox#751.f),LinearAlgebra.UniformScal\ning{Bool},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,N\nothing,Nothing,Nothing,Nothing},Base.Iterators.Pairs{Union{},Union{},Tuple{\n},NamedTuple{(),Tuple{}}},DiffEqBase.StandardODEProblem},OrdinaryDiffEq.Tsi\nt5,OrdinaryDiffEq.InterpolationData{DiffEqBase.ODEFunction{false,typeof(Mai\nn.##WeaveSandBox#751.f),LinearAlgebra.UniformScaling{Bool},Nothing,Nothing,\nNothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Not\nhing},Array{Array{Float64,1},1},Array{Float64,1},Array{Array{Array{Float64,\n1},1},1},OrdinaryDiffEq.Tsit5ConstantCache{Float64,Float64}},DiffEqBase.DES\ntats}","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"Plotting the first 250 trajectories produces","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nplot(ensemblesol, vars = (0,1), lw=1,alpha=0.1, label=nothing, idxs = 1:250)","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"(Image: )","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"Given the ensemble solution, we can then compute the expectation of a function gleft(cdotright) of the system state u at any time in the timespan, e.g. the state itself at t=4.0 as","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\ng(sol) = sol(4.0)\nmean([g(sol) for sol in ensemblesol])","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"1-element Array{Float64,1}:\n -0.007573120887912955","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"Alternatively, DiffEqUncertainty.jl offers a convenient interface for this type of calculation, expectation().","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nusing DiffEqUncertainty\nexpectation(g, prob, u0_dist, p, MonteCarlo(), Tsit5(); trajectories=100000)","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"1-element Array{Float64,1}:\n -0.0037433989352062547","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"expectation() takes the function of interest g, an ODEProblem, the initial conditions and parameters, and an AbstractExpectationAlgorithm. Here we use MonteCarlo() to use the Monte Carlo algorithm. Note that the initial conditions and parameters can be arrays that freely mix numeric and continuous distribution types from Distributions.jl. Recall, that u0_dist = [Uniform(-10.0,10.0)], while p = [-0.3]. From this specification, the expectation is solved as","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"mathbbEleftgleft(Xright)vert Xsim Pfright","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"where Pf is the \"push-forward\" density of the initial joint pdf f on initial conditions and parameters. ","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"Alternatively, we could solve the same problem using the Koopman() algorithm. ","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nexpectation(g, prob, u0_dist, p, Koopman(), Tsit5())","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"u: 1-element Array{Float64,1}:\n 0.0","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"Being that this system is linear, we can analytically compute the solution as a deterministic ODE with its initial condition set to the expectation of the initial condition, i.e.,","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"e^ptmathbbEleftu_0right","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nexp(p[1]*4.0)*mean(u0_dist[1])","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"0.0","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"We see that for this case the Koopman() algorithm produces a more accurate solution than MonteCarlo(). Not only is it more accurate, it is also much faster","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\n@time expectation(g, prob, u0_dist, p, MonteCarlo(), Tsit5(); trajectories=100000)","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"2.280767 seconds (79.32 M allocations: 7.160 GiB, 71.23% gc time)\n1-element Array{Float64,1}:\n -0.0050382269528445305","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\n@time expectation(g, prob, u0_dist, p, Koopman(), Tsit5())","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"0.000798 seconds (12.26 k allocations: 1.111 MiB)\nu: 1-element Array{Float64,1}:\n 0.0","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"Changing the distribution, we arrive at","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nu0_dist = [Uniform(0.0,10.0)]\n@time expectation(g, prob, u0_dist, p, MonteCarlo(), Tsit5(); trajectories=100_000)","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"1.027060 seconds (79.30 M allocations: 7.160 GiB, 44.15% gc time)\n1-element Array{Float64,1}:\n 1.5059653813564504","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"and","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\n@time expectation(g, prob, u0_dist, p, Koopman(), Tsit5())[1]","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"0.004259 seconds (14.02 k allocations: 1.221 MiB)\n1.5059722133001539","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"where the analytical solution is ","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nexp(p[1]*4.0)*mean(u0_dist[1])","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"1.5059710595610105","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"Note that the Koopman() algorithm doesn't currently support infinite or semi-infinite integration domains, where the integration domain is determined by the extrema of the given distributions. So, trying to using a Normal distribution will produce NaN","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nu0_dist = [Normal(3.0,2.0)]\nexpectation(g, prob, u0_dist, p, Koopman(), Tsit5())","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"u: 1-element Array{Float64,1}:\n NaN","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"Here, the analytical solution is ","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nexp(p[1]*4.0)*mean(u0_dist[1])","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"0.9035826357366062","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"Using a truncated distribution will alleviate this problem. However, there is another gotcha. If a large majority of the probability mass of the distribution exists in a small region in the support, then the adaptive methods used to solve the expectation can \"miss\" the non-zero portions of the distribution and errantly return 0.0.","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nu0_dist = [truncated(Normal(3.0,2.0),-1000,1000)]\nexpectation(g, prob, u0_dist, p, Koopman(), Tsit5())","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"u: 1-element Array{Float64,1}:\n 0.0","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"whereas truncating at pm 4sigma produces the correct result","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nu0_dist = [truncated(Normal(3.0,2.0),-5,11)]\nexpectation(g, prob, u0_dist, p, Koopman(), Tsit5())","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"u: 1-element Array{Float64,1}:\n 0.9035833577709517","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"If a large truncation is required, it is best practice to center the distribution on the truncated interval. This is because many of the underlying quadrature algorithms use the center of the interval as an evaluation point.","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nu0_dist = [truncated(Normal(3.0,2.0),3-1000,3+1000)]\nexpectation(g, prob, u0_dist, p, Koopman(), Tsit5())","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"u: 1-element Array{Float64,1}:\n 0.903584360812248","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/#Vector-Valued-Functions","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"Vector-Valued Functions","text":"","category":"section"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"expectation() can also handle vector-valued functions. Simply pass the vector-valued function and set the nout kwarg to the length of the vector the function returns.","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"Here, we demonstrate this by computing the expectation of u at t=4.0s and t=6.0s","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\ng(sol) = [sol(4.0)[1], sol(6.0)[1]]\nexpectation(g, prob, u0_dist, p, Koopman(), Tsit5(); nout = 2)","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"u: 2-element Array{Float64,1}:\n 0.903584360812248\n 0.49589556820916314","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"with analytical solution","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nexp.(p.*[4.0,6.0])*mean(u0_dist[1])","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"2-element Array{Float64,1}:\n 0.9035826357366062\n 0.4958966646647597","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"this can be used to compute the expectation at a range of times simultaneously","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nsaveat = tspan[1]:.5:tspan[2]\ng(sol) = Matrix(sol)\nmean_koop = expectation(g, prob, u0_dist, p, Koopman(), Tsit5(); nout = length(saveat), saveat=saveat)","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"u: 1×21 Array{Float64,2}:\n 3.0  2.58213  2.22246  1.91289  1.64644  …  0.201619  0.173536  0.149364","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"We can then plot these values along with the analytical solution","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nplot(t->exp(p[1]*t)*mean(u0_dist[1]),tspan..., xlabel=\"t\", label=\"analytical\")\nscatter!(collect(saveat),mean_koop.u[:],marker=:o, label=nothing)","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"(Image: )","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/#Benefits-of-Using-Vector-Valued-Functions","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"Benefits of Using Vector-Valued Functions","text":"","category":"section"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"In the above examples we used vector-valued expectation calculations to compute the various expectations required. Alternatively, one could simply compute multiple scalar-valued expectations. However, in most cases it is more efficient to use the vector-valued form. This is especially true when the ODE to be solved is computationally expensive.","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"To demonstrate this, lets compute the expectation of x, x^2, and x^3 using both approaches while counting the number of times g() is evaluated. This is the same as the number of simulation runs required to arrive at the solution. First, consider the scalar-valued approach. Here, we follow the same method as before, but we add a counter to our function evaluation that stores the number of function calls for each expectation calculation to an array.","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nfunction g(sol, power, counter)\n    counter[power] = counter[power] + 1\n    sol(4.0)[1]^power\nend\n\ncounters = [0,0,0]\nx_koop = expectation(s->g(s,1,counters), prob, u0_dist, p, Koopman(), Tsit5())\nx2_koop = expectation(s->g(s,2,counters), prob, u0_dist, p, Koopman(), Tsit5())\nx3_koop = expectation(s->g(s,3,counters), prob, u0_dist, p, Koopman(), Tsit5())\ncounters","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"3-element Array{Int64,1}:\n 375\n 405\n 375","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"Leading to a total of 1155 function evaluations.","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"Now, lets compare this to the vector-valued approach","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nfunction g(sol, counter) \n    counter[1] = counter[1] + 1\n    v = sol(4.0)[1]\n    [v, v^2, v^3]\nend\n\ncounter = [0]\nexpectation(s->g(s,counter), prob, u0_dist, p, Koopman(), Tsit5(); nout = 3)\ncounter","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"1-element Array{Int64,1}:\n 405","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"This is 35.06% the number of simulations required when using scalar-valued expectations. Note how the number of evaluations used in the vector-valued form is equivelent to the maximum number of evaluations for the 3 scalar-valued expectation calls.","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/#Higher-Order-Moments","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"Higher-Order Moments","text":"","category":"section"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"Leveraging this vector-valued capability, we can also efficiently compute higher-order central moments.","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/#Variance","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"Variance","text":"","category":"section"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"The variance, or 2nd central moment, of a random variable X is defined as","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"mathrmVarleft(Xright)=mathbbEleftleft(X-muright)^2right","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"where","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"mu = mathbbEleftXright","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"The expression for the variance can be expanded to","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"mathrmVarleft(Xright)=mathbbEleftX^2right-mathbbEleftXright^2","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"Using this, we define a function that returns the expectations of X and X^2 as a vector-valued function and then compute the variance from these","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nfunction g(sol) \n    x = sol(4.0)[1]\n    [x, x^2]\nend\n\nkoop = expectation(g, prob, u0_dist, p, Koopman(), Tsit5(); nout = 2)\nmean_koop = koop[1]\nvar_koop = koop[2] - mean_koop^2","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"0.36287237175498144","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"For a linear system, we can propagate the variance analytically as","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"e^2ptmathrmVarleft(u_0right)","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nexp(2*p[1]*4.0)*var(u0_dist[1])","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"0.36287181315765005","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"This can be computed at multiple time instances as well","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nsaveat = tspan[1]:.5:tspan[2]\ng(sol) = [Matrix(sol)'; (Matrix(sol).^2)']\n\nkoop = expectation(g, prob, u0_dist, p, Koopman(), Tsit5(); nout = length(saveat)*2, saveat=saveat)\nμ = koop.u[1:length(saveat)]\nσ = sqrt.(koop.u[length(saveat)+1:end] - μ.^2)\n\nplot(t->exp(p[1]*t)*mean(u0_dist[1]),tspan..., ribbon = t->-sqrt(exp(2*p[1]*t)*var(u0_dist[1])), label=\"Analytical Mean, 1 std bounds\")\nscatter!(collect(saveat),μ,marker=:x, yerror = σ, c=:black, label = \"Koopman Mean, 1 std bounds\")","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"(Image: )","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/#Skewness","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"Skewness","text":"","category":"section"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"A similar approach can be used to compute skewness","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nfunction g(sol) \n    v = sol(4.0)[1]\n    [v, v^2, v^3]\nend\n\nkoop = expectation(g, prob, u0_dist, p, Koopman(), Tsit5(); nout = 3)\nmean_koop = koop[1]\nvar_koop = koop[2] - mean_koop^2\n(koop[3] - 3.0*mean_koop*var_koop - mean_koop^3) / var_koop^(3/2)","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"3.7952822389774445e-9","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"As the system is linear, we expect the skewness to be unchanged from the inital distribution. Becasue the distribution is a truncated Normal distribution centered on the mean, the true skewness is 0.0.","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/#nth-Central-Moment","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"nth Central Moment","text":"","category":"section"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"DiffEqUncertainty provides a convenience function centralmoment around this approach for higher-order central moments. It takes an integer for the number of central moments you wish to compute. While the rest of the arguments are the same as for  expectation(). The following will return central moments 1-5.","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\ng(sol) = sol(4.0)[1]\ncentralmoment(5, g, prob, u0_dist, p, Koopman(), Tsit5(),\n                ireltol = 1e-9, iabstol = 1e-9)","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"5-element Array{Float64,1}:\n 0.0\n 0.3628723692985327\n 4.026725619610261e-10\n 0.39502906894683987\n 1.2523240222606091e-9","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/#Batch-Mode","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"Batch-Mode","text":"","category":"section"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"It is also possible to solve the various simulations in parallel by using the batch kwarg and a batch-mode supported quadrature algorithm via the quadalg kwarg. To view the list of batch compatible quadrature algorithms, refer to Quadrature.jl. Note: Batch-mode operation is built on top of DifferentialEquation.jl's EnsembleProblem. See the EnsembleProblem documentation for additional options.","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"The default quadtrature algorithm used by expectation() does not support batch-mode evaluation. So, we first load dependencies for additional quadrature algorithms","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"using Quadrature, Cuba","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"We then solve our expectation as before using a batch=10 multi-thread parallelization via EnsembleThreads() of Cuba's SUAVE algorithm. However, in this case we introduce additional uncertainty in the model parameter.","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nu0_dist = [truncated(Normal(3.0,2.0),-5,11)]\np_dist = [truncated(Normal(-.7, .1), -1,0)]\n\ng(sol) = sol(6.0)[1]\n\nexpectation(g, prob, u0_dist, p_dist, Koopman(), Tsit5(), EnsembleThreads(); \n                quadalg = CubaSUAVE(), batch=10)[1]","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"0.05397860786456136","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"Now, lets compare the performance of the batch and non-batch modes","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nusing BenchmarkTools\n\n@btime expectation(g, prob, u0_dist, p_dist, Koopman(), Tsit5(); \n                quadalg = CubaSUAVE())[1]","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"44.556 ms (1006187 allocations: 91.55 MiB)\n0.05397860786456136","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\n@btime expectation(g, prob, u0_dist, p_dist, Koopman(), Tsit5(), EnsembleThreads(); \n                quadalg = CubaSUAVE(), batch=10)[1]","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"21.936 ms (1019426 allocations: 93.00 MiB)\n0.05397860786456136","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"It is also possible to parallelize across the GPU. However, one must be careful of the limitations of ensemble solutions with the GPU. Please refer to DiffEqGPU.jl for details.","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"Here we load DiffEqGPU and modify our problem to use Float32 and to put the ODE in the required GPU form","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"\nusing DiffEqGPU\n\nfunction f(du, u,p,t) \n    @inbounds begin\n        du[1] = p[1]*u[1];\n    end\n    nothing\nend\n\nu0 = Float32[10.0]\np = Float32[-0.3]\ntspan = (0.0f0,10.0f0)\nprob = ODEProblem(f,u0,tspan,p)\n\ng(sol) = sol(6.0)[1]\n\nu0_dist = [truncated(Normal(3.0f0,2.0f0),-5f0,11f0)]\np_dist = [truncated(Normal(-.7f0, .1f0), -1f0,0f0)]\n\n@btime expectation(g, prob, u0_dist, p_dist, Koopman(), Tsit5(), EnsembleGPUArray(); \n                   quadalg = CubaSUAVE(), batch=1000)[1]","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"6.861 ms (76204 allocations: 3.71 MiB)\n0.056093966910433016","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"The performance gains realized by leveraging batch GPU processing is problem dependent. In this case, the number of batch evaluations required to overcome the overhead of using the GPU exceeds the number of simulations required to converge to the quadrature solution.","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/#Appendix","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"Appendix","text":"","category":"section"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"This tutorial is part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl.  For more information on doing scientific machine learning (SciML) with open source software, check out https://sciml.ai/.","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"DiffEqUncertainty\",\"01-expectation_introduction.jmd\")","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"Computer Information:","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"Julia Version 1.4.2\nCommit 44fa15b150* (2020-05-23 18:35 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Core(TM) i7-9700K CPU @ 3.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-8.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_LOAD_PATH = /builds/JuliaGPU/DiffEqTutorials.jl:\n  JULIA_DEPOT_PATH = /builds/JuliaGPU/DiffEqTutorials.jl/.julia\n  JULIA_CUDA_MEMORY_LIMIT = 2147483648\n  JULIA_NUM_THREADS = 8\n","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"Package Information:","category":"page"},{"location":"DiffEqUncertainty/01-expectation_introduction/","page":"An Intro to Expectations via DiffEqUncertainty.jl","title":"An Intro to Expectations via DiffEqUncertainty.jl","text":"Status `/builds/JuliaGPU/DiffEqTutorials.jl/tutorials/DiffEqUncertainty/Project.toml`\n[6e4b80f9-dd63-53aa-95a3-0cdb28fa8baf] BenchmarkTools 0.5.0\n[8a292aeb-7a57-582c-b821-06e4c11590b1] Cuba 2.1.0\n[071ae1c0-96b5-11e9-1965-c90190d839ea] DiffEqGPU 1.6.0\n[41bf760c-e81c-5289-8e54-58b1f1f8abe2] DiffEqSensitivity 6.31.1\n[ef61062a-5684-51dc-bb67-a0fcdec5c97d] DiffEqUncertainty 1.5.0\n[0c46a032-eb83-5123-abaf-570d42b7fbaa] DifferentialEquations 6.15.0\n[31c24e10-a181-5473-b8eb-7969acd0382f] Distributions 0.23.8\n[f6369f11-7733-5829-9624-2563aa707210] ForwardDiff 0.10.12\n[76087f3c-5699-56af-9a33-bf431cd00edd] NLopt 0.6.0\n[1dea7af3-3e70-54e6-95c3-0bf5283fa5ed] OrdinaryDiffEq 5.42.3\n[91a5bcdd-55d7-5caf-9e0b-520d859cae80] Plots 1.6.0\n[67601950-bd08-11e9-3c89-fd23fb4432d2] Quadrature 1.3.0","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/#Solving-the-heat-equation-with-diffusion-implicit-time-stepping","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"","category":"section"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"In this tutorial, we'll be solving the heat equation:","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"_t T = α ²(T) + β sin(γ z)","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"with boundary conditions: T(z=a) = T_bottom T(z=b) = T_top. We'll solve these equations numerically using Finite Difference Method on cell faces. The same exercise could easily be done on cell centers.","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/#Code-loading-and-parameters","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Code loading and parameters","text":"","category":"section"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"First, we'll use / import some packages:","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"import Plots\nusing LinearAlgebra\nusing DiffEqBase\nusing OrdinaryDiffEq: SplitODEProblem, solve, IMEXEuler\nimport SciMLBase","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Next, we'll define some global problem parameters:","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"a,b, n = 0, 1, 10               # zmin, zmax, number of cells\nn̂_min, n̂_max = -1, 1            # Outward facing unit vectors\nα = 100;                        # thermal diffusivity, larger means more stiff\nβ, γ = 10000, π;                # source term coefficients\nΔt = 1000;                      # timestep size\nN_t = 10;                       # number of timesteps to take\nFT = Float64;                   # float type\nΔz = FT(b-a)/FT(n)\nΔz² = Δz^2;\n∇²_op = [1/Δz², -2/Δz², 1/Δz²]; # interior Laplacian operator\n∇T_bottom = 10;                 # Temperature gradient at the top\nT_top = 1;                      # Temperature at the bottom\nS(z) = β*sin(γ*z)               # source term, (sin for easy integration)\nzf = range(a, b, length=n+1);   # coordinates on cell faces","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/#Derivation-of-analytic-solution","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Derivation of analytic solution","text":"","category":"section"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Here, we'll derive the analytic solution:","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"frac²T²z = -fracS(z)α = -fracβ sin(γ z)α \nfracTz = fracβ cos(γ z)γ α+c_1 \nT(z) = fracβ sin(γ z)γ^2 α+c_1 z+c_2 qquad text(generic solution)","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Apply bottom boundary condition:","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"fracTz(a) = fracβ cos(γ a)γ α+c_1 = T_bottom \nc_1 = T_bottom-fracβ cos(γ a)γ α","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Apply top boundary condition:","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"T(b) = fracβ sin(γ b)γ^2 α+c_1 b+c_2 = T_top \nc_2 = T_top-left(fracβ sin(γ b)γ^2 α+c_1 bright)","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"And now let's define this in a julia function:","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"function T_analytic(z) # Analytic steady state solution\n    c1 = ∇T_bottom-β*cos(γ*a)/(γ*α)\n    c2 = T_top-(β*sin(γ*b)/(γ^2*α)+c1*b)\n    return β*sin(γ*z)/(γ^2*α)+c1*z+c2\nend","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"T_analytic (generic function with 1 method)","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/#Derive-the-temporal-discretization","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Derive the temporal discretization","text":"","category":"section"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Here, we'll derivation the matrix form of the temporal discretization we wish to use (diffusion-implicit and explicit Euler):","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"_t T = α ²T + S \n(T^n+1-T^n) = Δt (α  ²T^n+1 + S) \n(T^n+1 - Δt α ²T^n+1) = T^n + Δt S \n(I - Δt α ²) T^n+1 = T^n + Δt S","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Note that, since the ² reaches to boundary points, we'll need to modify the stencils to account for boundary conditions.","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/#Derive-the-finite-difference-stencil","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Derive the finite difference stencil","text":"","category":"section"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"For the interior domain, a central and second-order finite difference stencil is simply:","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"²f = fracf_i-1 -2f_i + f_i+1Δz² qquad textor \n² = leftfrac1Δz² frac-2Δz² frac1Δz²right ","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"At the boundaries, we need to modify the stencil to account for Dirichlet and Neumann BCs. Using the following index denotion:","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"i first interior index\nb boundary index\ng ghost index","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"the Dirichlet boundary stencil & source:","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"_t T = α fracTi-1+Tb-2 TiΔz² + S \n_t T = α fracTi-1-2 TiΔz² + S + α fracTbΔz²","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"and Neumann boundary stencil & source:","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"T_bottom n = fracTg - Ti2Δz qquad    n = -11  z_minz_max \nTi + 2 Δz T_bottom n = Tg \n_t T = α fracfrac(Ti + 2 Δz T_bottom n) - TbΔz - fracTb - TiΔzΔz + S \n_t T = α fracfracTi - TbΔz - fracTb - TiΔzΔz + S + α 2 Δz fracT_bottomΔz² \n_t T = α frac2 Ti - 2 TbΔz² + S + 2α fracT_bottom nΔz","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/#Define-the-discrete-diffusion-operator","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Define the discrete diffusion operator","text":"","category":"section"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"# Initialize interior and boundary stencils:\n∇² = Tridiagonal(\n    ones(FT, n) .* ∇²_op[1],\n    ones(FT, n+1)   .* ∇²_op[2],\n    ones(FT, n) .* ∇²_op[3]\n);\n\n# Modify boundary stencil to account for BCs\n\n∇².d[1] = -2/Δz²\n∇².du[1] = +2/Δz²\n\n# Modify boundary stencil to account for BCs\n∇².du[n] = 0  # modified stencil\n∇².d[n+1] = 0 # to ensure `∂_t T = 0` at `z=zmax`\n∇².dl[n] = 0  # to ensure `∂_t T = 0` at `z=zmax`\nD = α .* ∇²","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"11×11 LinearAlgebra.Tridiagonal{Float64, Vector{Float64}}:\n -20000.0   20000.0        ⋅         ⋅   …        ⋅         ⋅         ⋅    \n⋅ \n  10000.0  -20000.0   10000.0        ⋅            ⋅         ⋅         ⋅    \n⋅ \n       ⋅    10000.0  -20000.0   10000.0           ⋅         ⋅         ⋅    \n⋅ \n       ⋅         ⋅    10000.0  -20000.0           ⋅         ⋅         ⋅    \n⋅ \n       ⋅         ⋅         ⋅    10000.0           ⋅         ⋅         ⋅    \n⋅ \n       ⋅         ⋅         ⋅         ⋅   …        ⋅         ⋅         ⋅    \n⋅ \n       ⋅         ⋅         ⋅         ⋅       10000.0        ⋅         ⋅    \n⋅ \n       ⋅         ⋅         ⋅         ⋅      -20000.0   10000.0        ⋅    \n⋅ \n       ⋅         ⋅         ⋅         ⋅       10000.0  -20000.0   10000.0   \n⋅ \n       ⋅         ⋅         ⋅         ⋅            ⋅    10000.0  -20000.0  0\n.0\n       ⋅         ⋅         ⋅         ⋅   …        ⋅         ⋅        0.0  0\n.0","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/#Define-boundary-source","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Define boundary source","text":"","category":"section"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Here, we'll compute the boundary source left(fracα TbΔz²right)","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"AT_b = zeros(FT, n+1);\nAT_b[1] = α*2/Δz*∇T_bottom*n̂_min;\nAT_b[end-1] = α*T_top/Δz²;","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/#Set-initial-condition","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Set initial condition","text":"","category":"section"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Let's just initialize the solution to 1, and also set the top boundary condition:","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"T = zeros(FT, n+1);\nT .= 1;\nT[n+1] = T_top; # set top BC","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/#Define-right-hand-side-sources","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Define right-hand side sources","text":"","category":"section"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Here, we define the right-hand side (RHS) sources:","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"function rhs!(dT, T, params, t)\n    n = params.n\n    i = 1:n # interior domain\n    dT[i] .= S.(zf[i]) .+ AT_b[i]\n    return dT\nend;","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Next, we'll pacakge up parameters needed in the RHS function, define the ODE problem, and solve.","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"params = (;n)\n\ntspan = (FT(0), N_t*FT(Δt))\n\nprob = SplitODEProblem(\n    SciMLBase.DiffEqArrayOperator(\n        D,\n    ),\n    rhs!,\n    T,\n    tspan,\n    params\n)\nalg = IMEXEuler(linsolve=LinSolveFactorize(lu!))\nprintln(\"Solving...\")\nsol = solve(\n    prob,\n    alg,\n    dt = Δt,\n    saveat = range(FT(0), N_t*FT(Δt), length=5),\n    progress = true,\n    progress_message = (dt, u, p, t) -> t,\n);","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Solving...","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/#Visualizing-results","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Visualizing results","text":"","category":"section"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Now, let's visualize the results of the solution and error:","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"T_end = sol.u[end]\n\np1 = Plots.plot(zf, T_analytic.(zf), label=\"analytic\", markershape=:circle, markersize=6)\np1 = Plots.plot!(p1, zf, T_end, label=\"numerical\", markershape=:diamond)\np1 = Plots.plot!(p1, title=\"T ∈ cell faces\")\n\np2 = Plots.plot(zf, abs.(T_end .- T_analytic.(zf)), label=\"error\", markershape=:circle, markersize=6)\np2 = Plots.plot!(p2, title=\"T ∈ cell faces\")\n\nPlots.plot(p1, p2)","category":"page"},{"location":"advanced/04-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"(Image: )","category":"page"},{"location":"introduction/01-ode_introduction/#An-Intro-to-DifferentialEquations.jl","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"","category":"section"},{"location":"introduction/01-ode_introduction/#Basic-Introduction-Via-Ordinary-Differential-Equations","page":"An Intro to DifferentialEquations.jl","title":"Basic Introduction Via Ordinary Differential Equations","text":"","category":"section"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"This notebook will get you started with DifferentialEquations.jl by introducing you to the functionality for solving ordinary differential equations (ODEs). The corresponding documentation page is the ODE tutorial. While some of the syntax may be different for other types of equations, the same general principles hold in each case. Our goal is to give a gentle and thorough introduction that highlights these principles in a way that will help you generalize what you have learned.","category":"page"},{"location":"introduction/01-ode_introduction/#Background","page":"An Intro to DifferentialEquations.jl","title":"Background","text":"","category":"section"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"If you are new to the study of differential equations, it can be helpful to do a quick background read on the definition of ordinary differential equations. We define an ordinary differential equation as an equation which describes the way that a variable u changes, that is","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"u = f(upt)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"where p are the parameters of the model, t is the time variable, and f is the nonlinear model of how u changes. The initial value problem also includes the information about the starting value:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"u(t_0) = u_0","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"Together, if you know the starting value and you know how the value will change with time, then you know what the value will be at any time point in the future. This is the intuitive definition of a differential equation.","category":"page"},{"location":"introduction/01-ode_introduction/#First-Model:-Exponential-Growth","page":"An Intro to DifferentialEquations.jl","title":"First Model: Exponential Growth","text":"","category":"section"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"Our first model will be the canonical exponential growth model. This model says that the rate of change is proportional to the current value, and is this:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"u = au","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"where we have a starting value u(0)=u_0. Let's say we put 1 dollar into Bitcoin which is increasing at a rate of 98 per year. Then calling now t=0 and measuring time in years, our model is:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"u = 098u","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"and u(0) = 10. We encode this into Julia by noticing that, in this setup, we match the general form when","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"f(u,p,t) = 0.98u","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"f (generic function with 1 method)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"with u_0 = 10. If we want to solve this model on a time span from t=0.0 to t=1.0, then we define an ODEProblem by specifying this function f, this initial condition u0, and this time span as follows:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"using DifferentialEquations\nf(u,p,t) = 0.98u\nu0 = 1.0\ntspan = (0.0,1.0)\nprob = ODEProblem(f,u0,tspan)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"ODEProblem with uType Float64 and tType Float64. In-place: false\ntimespan: (0.0, 1.0)\nu0: 1.0","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"To solve our ODEProblem we use the command solve.","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"sol = solve(prob)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"retcode: Success\nInterpolation: automatic order switching interpolation\nt: 5-element Vector{Float64}:\n 0.0\n 0.10042494449239292\n 0.35218603951893646\n 0.6934436028208104\n 1.0\nu: 5-element Vector{Float64}:\n 1.0\n 1.1034222047865465\n 1.4121908848175448\n 1.9730384275622996\n 2.664456142481451","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"and that's it: we have succesfully solved our first ODE!","category":"page"},{"location":"introduction/01-ode_introduction/#Analyzing-the-Solution","page":"An Intro to DifferentialEquations.jl","title":"Analyzing the Solution","text":"","category":"section"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"Of course, the solution type is not interesting in and of itself. We want to understand the solution! The documentation page which explains in detail the functions for analyzing the solution is the Solution Handling page. Here we will describe some of the basics. You can plot the solution using the plot recipe provided by Plots.jl:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"using Plots; gr()\nplot(sol)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"(Image: )","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"From the picture we see that the solution is an exponential curve, which matches our intuition. As a plot recipe, we can annotate the result using any of the Plots.jl attributes. For example:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"plot(sol,linewidth=5,title=\"Solution to the linear ODE with a thick line\",\n     xaxis=\"Time (t)\",yaxis=\"u(t) (in μm)\",label=\"My Thick Line!\") # legend=false","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"(Image: )","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"Using the mutating plot! command we can add other pieces to our plot. For this ODE we know that the true solution is u(t) = u_0 exp(at), so let's add some of the true solution to our plot:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"plot!(sol.t, t->1.0*exp(0.98t),lw=3,ls=:dash,label=\"True Solution!\")","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"(Image: )","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"In the previous command I demonstrated sol.t, which grabs the array of time points that the solution was saved at:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"sol.t","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"5-element Vector{Float64}:\n 0.0\n 0.10042494449239292\n 0.35218603951893646\n 0.6934436028208104\n 1.0","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"We can get the array of solution values using sol.u:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"sol.u","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"5-element Vector{Float64}:\n 1.0\n 1.1034222047865465\n 1.4121908848175448\n 1.9730384275622996\n 2.664456142481451","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"sol.u[i] is the value of the solution at time sol.t[i]. We can compute arrays of functions of the solution values using standard comprehensions, like:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"[t+u for (u,t) in tuples(sol)]","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"5-element Vector{Float64}:\n 1.0\n 1.2038471492789395\n 1.7643769243364813\n 2.66648203038311\n 3.664456142481451","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"However, one interesting feature is that, by default, the solution is a continuous function. If we check the print out again:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"sol","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"retcode: Success\nInterpolation: automatic order switching interpolation\nt: 5-element Vector{Float64}:\n 0.0\n 0.10042494449239292\n 0.35218603951893646\n 0.6934436028208104\n 1.0\nu: 5-element Vector{Float64}:\n 1.0\n 1.1034222047865465\n 1.4121908848175448\n 1.9730384275622996\n 2.664456142481451","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"you see that it says that the solution has a order changing interpolation. The default algorithm automatically switches between methods in order to handle all types of problems. For non-stiff equations (like the one we are solving), it is a continuous function of 4th order accuracy. We can call the solution as a function of time sol(t). For example, to get the value at t=0.45, we can use the command:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"sol(0.45)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"1.554261048055312","category":"page"},{"location":"introduction/01-ode_introduction/#Controlling-the-Solver","page":"An Intro to DifferentialEquations.jl","title":"Controlling the Solver","text":"","category":"section"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"DifferentialEquations.jl has a common set of solver controls among its algorithms which can be found at the Common Solver Options page. We will detail some of the most widely used options.","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"The most useful options are the tolerances abstol and reltol. These tell the internal adaptive time stepping engine how precise of a solution you want. Generally, reltol is the relative accuracy while abstol is the accuracy when u is near zero. These tolerances are local tolerances and thus are not global guarantees. However, a good rule of thumb is that the total solution accuracy is 1-2 digits less than the relative tolerances. Thus for the defaults abstol=1e-6 and reltol=1e-3, you can expect a global accuracy of about 1-2 digits. If we want to get around 6 digits of accuracy, we can use the commands:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"sol = solve(prob,abstol=1e-8,reltol=1e-8)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"retcode: Success\nInterpolation: automatic order switching interpolation\nt: 9-element Vector{Float64}:\n 0.0\n 0.04127492324135852\n 0.14679917846877366\n 0.28631546412766684\n 0.4381941361169628\n 0.6118924302028597\n 0.7985659100883337\n 0.9993516479536952\n 1.0\nu: 9-element Vector{Float64}:\n 1.0\n 1.0412786454705882\n 1.1547261252949712\n 1.3239095703537043\n 1.5363819257509728\n 1.8214895157178692\n 2.1871396448296223\n 2.662763824115295\n 2.664456241933517","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"Now we can see no visible difference against the true solution:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"plot(sol)\nplot!(sol.t, t->1.0*exp(0.98t),lw=3,ls=:dash,label=\"True Solution!\")","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"(Image: )","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"Notice that by decreasing the tolerance, the number of steps the solver had to take was 9 instead of the previous 5. There is a trade off between accuracy and speed, and it is up to you to determine what is the right balance for your problem.","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"Another common option is to use saveat to make the solver save at specific time points. For example, if we want the solution at an even grid of t=0.1k for integers k, we would use the command:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"sol = solve(prob,saveat=0.1)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"retcode: Success\nInterpolation: 1st order linear\nt: 11-element Vector{Float64}:\n 0.0\n 0.1\n 0.2\n 0.3\n 0.4\n 0.5\n 0.6\n 0.7\n 0.8\n 0.9\n 1.0\nu: 11-element Vector{Float64}:\n 1.0\n 1.102962785129292\n 1.2165269512238264\n 1.341783821227542\n 1.4799379510586077\n 1.632316207054161\n 1.8003833264983584\n 1.9857565541588758\n 2.1902158127997695\n 2.415725742084496\n 2.664456142481451","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"Notice that when saveat is used the continuous output variables are no longer saved and thus sol(t), the interpolation, is only first order. We can save at an uneven grid of points by passing a collection of values to saveat. For example:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"sol = solve(prob,saveat=[0.2,0.7,0.9])","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"retcode: Success\nInterpolation: 1st order linear\nt: 3-element Vector{Float64}:\n 0.2\n 0.7\n 0.9\nu: 3-element Vector{Float64}:\n 1.2165269512238264\n 1.9857565541588758\n 2.415725742084496","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"If we need to reduce the amount of saving, we can also turn off the continuous output directly via dense=false:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"sol = solve(prob,dense=false)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"retcode: Success\nInterpolation: 1st order linear\nt: 5-element Vector{Float64}:\n 0.0\n 0.10042494449239292\n 0.35218603951893646\n 0.6934436028208104\n 1.0\nu: 5-element Vector{Float64}:\n 1.0\n 1.1034222047865465\n 1.4121908848175448\n 1.9730384275622996\n 2.664456142481451","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"and to turn off all intermediate saving we can use save_everystep=false:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"sol = solve(prob,save_everystep=false)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"retcode: Success\nInterpolation: 1st order linear\nt: 2-element Vector{Float64}:\n 0.0\n 1.0\nu: 2-element Vector{Float64}:\n 1.0\n 2.664456142481451","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"If we want to solve and only save the final value, we can even set save_start=false.","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"sol = solve(prob,save_everystep=false,save_start = false)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"retcode: Success\nInterpolation: 1st order linear\nt: 1-element Vector{Float64}:\n 1.0\nu: 1-element Vector{Float64}:\n 2.664456142481451","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"Note that similarly on the other side there is save_end=false.","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"More advanced saving behaviors, such as saving functionals of the solution, are handled via the SavingCallback in the Callback Library which will be addressed later in the tutorial.","category":"page"},{"location":"introduction/01-ode_introduction/#Choosing-Solver-Algorithms","page":"An Intro to DifferentialEquations.jl","title":"Choosing Solver Algorithms","text":"","category":"section"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"There is no best algorithm for numerically solving a differential equation. When you call solve(prob), DifferentialEquations.jl makes a guess at a good algorithm for your problem, given the properties that you ask for (the tolerances, the saving information, etc.). However, in many cases you may want more direct control. A later notebook will help introduce the various algorithms in DifferentialEquations.jl, but for now let's introduce the syntax.","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"The most crucial determining factor in choosing a numerical method is the stiffness of the model. Stiffness is roughly characterized by a Jacobian f with large eigenvalues. That's quite mathematical, and we can think of it more intuitively: if you have big numbers in f (like parameters of order 1e5), then it's probably stiff. Or, as the creator of the MATLAB ODE Suite, Lawrence Shampine, likes to define it, if the standard algorithms are slow, then it's stiff. We will go into more depth about diagnosing stiffness in a later tutorial, but for now note that if you believe your model may be stiff, you can hint this to the algorithm chooser via alg_hints = [:stiff].","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"sol = solve(prob,alg_hints=[:stiff])","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"retcode: Success\nInterpolation: specialized 3rd order \"free\" stiffness-aware interpolation\nt: 8-element Vector{Float64}:\n 0.0\n 0.05653299582822294\n 0.17270731152826024\n 0.3164602871490142\n 0.5057500163821153\n 0.7292241858994543\n 0.9912975001018789\n 1.0\nu: 8-element Vector{Float64}:\n 1.0\n 1.0569657840332976\n 1.1844199383303913\n 1.3636037723365293\n 1.6415399686182572\n 2.043449143475479\n 2.6418256160577602\n 2.6644526430553808","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"Stiff algorithms have to solve implicit equations and linear systems at each step so they should only be used when required.","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"If we want to choose an algorithm directly, you can pass the algorithm type after the problem as solve(prob,alg). For example, let's solve this problem using the Tsit5() algorithm, and just for show let's change the relative tolerance to 1e-6 at the same time:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"sol = solve(prob,Tsit5(),reltol=1e-6)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"retcode: Success\nInterpolation: specialized 4th order \"free\" interpolation\nt: 10-element Vector{Float64}:\n 0.0\n 0.028970819746309166\n 0.10049147151547619\n 0.19458908698515082\n 0.3071725081673423\n 0.43945421453622546\n 0.5883434923759523\n 0.7524873357619015\n 0.9293021330536031\n 1.0\nu: 10-element Vector{Float64}:\n 1.0\n 1.0287982807225062\n 1.1034941463604806\n 1.2100931078233779\n 1.351248605624241\n 1.538280340326815\n 1.7799346012651116\n 2.090571742234628\n 2.486102171447025\n 2.6644562434913377","category":"page"},{"location":"introduction/01-ode_introduction/#Systems-of-ODEs:-The-Lorenz-Equation","page":"An Intro to DifferentialEquations.jl","title":"Systems of ODEs: The Lorenz Equation","text":"","category":"section"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"Now let's move to a system of ODEs. The Lorenz equation is the famous \"butterfly attractor\" that spawned chaos theory. It is defined by the system of ODEs:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"$","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"\\begin{align} \\frac{dx}{dt} &= \\sigma (y - x)\\\n\\frac{dy}{dt} &= x (\\rho - z) -y\\\n\\frac{dz}{dt} &= xy - \\beta z \\end{align} $","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"To define a system of differential equations in DifferentialEquations.jl, we define our f as a vector function with a vector initial condition. Thus, for the vector u = [x,y,z]', we have the derivative function:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"function lorenz!(du,u,p,t)\n    σ,ρ,β = p\n    du[1] = σ*(u[2]-u[1])\n    du[2] = u[1]*(ρ-u[3]) - u[2]\n    du[3] = u[1]*u[2] - β*u[3]\nend","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"lorenz! (generic function with 1 method)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"Notice here we used the in-place format which writes the output to the preallocated vector du. For systems of equations the in-place format is faster. We use the initial condition u_0 = 100000 as follows:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"u0 = [1.0,0.0,0.0]","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"3-element Vector{Float64}:\n 1.0\n 0.0\n 0.0","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"Lastly, for this model we made use of the parameters p. We need to set this value in the ODEProblem as well. For our model we want to solve using the parameters sigma = 10, rho = 28, and beta = 83, and thus we build the parameter collection:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"p = (10,28,8/3) # we could also make this an array, or any other type!","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"(10, 28, 2.6666666666666665)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"Now we generate the ODEProblem type. In this case, since we have parameters, we add the parameter values to the end of the constructor call. Let's solve this on a time span of t=0 to t=100:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"tspan = (0.0,100.0)\nprob = ODEProblem(lorenz!,u0,tspan,p)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"ODEProblem with uType Vector{Float64} and tType Float64. In-place: true\ntimespan: (0.0, 100.0)\nu0: 3-element Vector{Float64}:\n 1.0\n 0.0\n 0.0","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"Now, just as before, we solve the problem:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"sol = solve(prob)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"retcode: Success\nInterpolation: automatic order switching interpolation\nt: 1300-element Vector{Float64}:\n   0.0\n   3.5678604836301404e-5\n   0.0003924646531993154\n   0.003262408518896374\n   0.009058077168386882\n   0.01695647153663815\n   0.027689960628879868\n   0.041856351821061455\n   0.06024041060823337\n   0.08368540639551347\n   ⋮\n  99.25227436435598\n  99.34990050231407\n  99.47329750836677\n  99.56888278883171\n  99.68067056500875\n  99.7698930548574\n  99.86396908592394\n  99.9520070464327\n 100.0\nu: 1300-element Vector{Vector{Float64}}:\n [1.0, 0.0, 0.0]\n [0.9996434557625105, 0.0009988049817849058, 1.781434788799189e-8]\n [0.9961045497425811, 0.010965399721242457, 2.1469553658389193e-6]\n [0.9693591566959717, 0.089770627357676, 0.0001438019004555601]\n [0.9242043510496474, 0.24228916412927515, 0.0010461626692665619]\n [0.8800455755115648, 0.43873651254178225, 0.003424260317913913]\n [0.8483309815012585, 0.6915629798778471, 0.008487625758932924]\n [0.8495036692770451, 1.0145426674126548, 0.018212090760571238]\n [0.9139069519040545, 1.4425599553295452, 0.036693820689070726]\n [1.088863767524423, 2.052326420986981, 0.07402572431671739]\n ⋮\n [5.791198832787258, 3.8198742723079415, 26.666685868569655]\n [4.959577668148714, 5.1627464679185815, 22.495413403699086]\n [6.653100232410356, 9.122429705812463, 20.41123180056622]\n [9.593094878342031, 12.952212134722183, 23.567760855989487]\n [11.932162424256417, 11.761476358727544, 31.642393421283604]\n [9.907977700774161, 6.112102601076882, 32.83064925680822]\n [6.4119417247899015, 3.408711533396652, 28.483033292250997]\n [4.734282403550539, 3.913681157796059, 24.002168300285124]\n [4.596259899368738, 4.819051128437629, 22.02318896633189]","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"The same solution handling features apply to this case. Thus sol.t stores the time points and sol.u is an array storing the solution at the corresponding time points.","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"However, there are a few extra features which are good to know when dealing with systems of equations. First of all, sol also acts like an array. sol[i] returns the solution at the ith time point.","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"sol.t[10],sol[10]","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"(0.08368540639551347, [1.088863767524423, 2.052326420986981, 0.074025724316\n71739])","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"Additionally, the solution acts like a matrix where sol[j,i] is the value of the jth variable at time i:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"sol[2,10]","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"2.052326420986981","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"We can get a real matrix by performing a conversion:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"A = Array(sol)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"3×1300 Matrix{Float64}:\n 1.0  0.999643     0.996105    0.969359     …   6.41194   4.73428   4.59626\n 0.0  0.000998805  0.0109654   0.0897706        3.40871   3.91368   4.81905\n 0.0  1.78143e-8   2.14696e-6  0.000143802     28.483    24.0022   22.0232","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"This is the same as sol, i.e. sol[i,j] = A[i,j], but now it's a true matrix. Plotting will by default show the time series for each variable:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"plot(sol)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"(Image: )","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"If we instead want to plot values against each other, we can use the vars command. Let's plot variable 1 against variable 2 against variable 3:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"plot(sol,vars=(1,2,3))","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"(Image: )","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"This is the classic Lorenz attractor plot, where the x axis is u[1], the y axis is u[2], and the z axis is u[3]. Note that the plot recipe by default uses the interpolation, but we can turn this off:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"plot(sol,vars=(1,2,3),denseplot=false)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"(Image: )","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"Yikes! This shows how calculating the continuous solution has saved a lot of computational effort by computing only a sparse solution and filling in the values! Note that in vars, 0=time, and thus we can plot the time series of a single component like:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"plot(sol,vars=(0,2))","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"(Image: )","category":"page"},{"location":"introduction/01-ode_introduction/#Internal-Types","page":"An Intro to DifferentialEquations.jl","title":"Internal Types","text":"","category":"section"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"The last basic user-interface feature to explore is the choice of types. DifferentialEquations.jl respects your input types to determine the internal types that are used. Thus since in the previous cases, when we used Float64 values for the initial condition, this meant that the internal values would be solved using Float64. We made sure that time was specified via Float64 values, meaning that time steps would utilize 64-bit floats as well. But, by simply changing these types we can change what is used internally.","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"As a quick example, let's say we want to solve an ODE defined by a matrix. To do this, we can simply use a matrix as input.","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"A  = [1. 0  0 -5\n      4 -2  4 -3\n     -4  0  0  1\n      5 -2  2  3]\nu0 = rand(4,2)\ntspan = (0.0,1.0)\nf(u,p,t) = A*u\nprob = ODEProblem(f,u0,tspan)\nsol = solve(prob)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"retcode: Success\nInterpolation: automatic order switching interpolation\nt: 10-element Vector{Float64}:\n 0.0\n 0.0331010730691975\n 0.09782085679194133\n 0.18191187446836993\n 0.28632603546736024\n 0.4040506177182259\n 0.5444845160456964\n 0.6919976340048595\n 0.8531307370404774\n 1.0\nu: 10-element Vector{Matrix{Float64}}:\n [0.014747968966241753 0.14496017235002934; 0.5405146764582902 0.7507124983\n144184; 0.8637771912953807 0.24940709712390485; 0.25268820618439447 0.85571\n3156943483]\n [-0.031220752042396306 -0.0002374973693238247; 0.5895706606523794 0.659218\n6004376548; 0.8739108240812645 0.2691710214579143; 0.29888519570381655 0.92\n67801144223753]\n [-0.14591301277137186 -0.3292274747166891; 0.6522286454994926 0.4364608585\n4574035; 0.9179976878204164 0.37432482851661675; 0.3713293434375492 1.03537\n35570911555]\n [-0.33466916118168755 -0.830561885827794; 0.6841503488204593 0.09511787169\n524738; 1.0315302291748207 0.6579870119771181; 0.4228995681616543 1.1050958\n393259087]\n [-0.6040917796504578 -1.5242351889406898; 0.6897988920987816 -0.3217920618\n0756564; 1.2710081554063146 1.2623307080718313; 0.4059226449899241 1.055484\n7932482665]\n [-0.8962221865295689 -2.30368962364882; 0.7337218290317526 -0.621227822492\n1441; 1.6668943459910721 2.276948291040312; 0.26154699125208886 0.784176611\n7237723]\n [-1.1087487522394643 -3.021989161941192; 0.9825502421303286 -0.46092512671\n40586; 2.2542928821824058 3.8578317871619996; -0.09907689404210246 0.120165\n06439738461]\n [-0.9909122944702802 -3.194010670474809; 1.6430287316886858 0.657082066660\n454; 2.8403269138214866 5.671558778436573; -0.6882495897088279 -0.992685186\n5461248]\n [-0.22328081905826624 -2.2155914075850034; 2.9583231888949753 3.2978880867\n294094; 3.098548954921636 7.207366231070659; -1.5062144186355564 -2.6275138\n367784754]\n [1.2330802577873936 0.15913595025588334; 4.653356702242153 7.0210638225949\n7; 2.561691558505567 7.38017123367908; -2.2716399256807716 -4.3116415394514\n07]","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"There is no real difference from what we did before, but now in this case u0 is a 4x2 matrix. Because of that, the solution at each time point is matrix:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"sol[3]","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"4×2 Matrix{Float64}:\n -0.145913  -0.329227\n  0.652229   0.436461\n  0.917998   0.374325\n  0.371329   1.03537","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"In DifferentialEquations.jl, you can use any type that defines +, -, *, /, and has an appropriate norm. For example, if we want arbitrary precision floating point numbers, we can change the input to be a matrix of BigFloat:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"big_u0 = big.(u0)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"4×2 Matrix{BigFloat}:\n 0.014748  0.14496\n 0.540515  0.750712\n 0.863777  0.249407\n 0.252688  0.855713","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"and we can solve the ODEProblem with arbitrary precision numbers by using that initial condition:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"prob = ODEProblem(f,big_u0,tspan)\nsol = solve(prob)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"retcode: Success\nInterpolation: automatic order switching interpolation\nt: 6-element Vector{Float64}:\n 0.0\n 0.0331010730691975\n 0.20696173808837195\n 0.489610659955686\n 0.8019632243011008\n 1.0\nu: 6-element Vector{Matrix{BigFloat}}:\n [0.014747968966241753463464192464016377925872802734375 0.14496017235002933\n70960889660636894404888153076171875; 0.540514676458290210803170339204370975\n494384765625 0.7507124983144184415806421384331770241260528564453125; 0.8637\n77191295380664115555191528983414173126220703125 0.2494070971239048528644843\n827350996434688568115234375; 0.25268820618439447045489032461773604154586791\n9921875 0.8557131569434830442588690857519395649433135986328125]\n [-0.0312207520256040208018462725768585089479916413145051776297731185547387\n4685394847 -0.0002374973746370063726334692405823679833621528276691681405138\n268086673211980883989; 0.58957066073643911173479246355577664057102835297568\n62542100715403525691120468183 0.6592186005224230967284037788575641289056130\n819602492754918453048942424903983319; 0.87391082410375363767149139968773694\n81770636954336344979263545693218303915793066 0.2691710215066015806169984373\n018550540462447164250561309944021007975335095863645; 0.29888519570172968854\n00026353766574781912705260650244932924428252198441194030608 0.9267801144152\n455228759065993724041412153835396491544923877712258669311108501346]\n [-0.3971455045661057871583007302525178970474339219695392949460070536417855\n343798884 -0.99206425850354891442533243302609587203604266704707245494635921\n80430391077461121; 0.686839848952166655368657205907536082445026785120917522\n0550049890496686824357338 -0.0097469204373119457244449100560149075002122903\n68545345560794795264384835036882812; 1.078838985132652140576174768877515276\n513955955529273163029467100585355976378404 0.776999990982186926788473874336\n5477733242444076038943802849427299417404962980107; 0.4275676511041581592857\n022896097132162174197882847451221030847431641637985708651 1.107953532925116\n378505172680061890463539782121177345161807547814240893365355827]\n [-1.0530123841255846942003853171740856687312134559035513042523713533179580\n12292795 -2.786064876306964010368736937534528187774392950465400962924153533\n294024216106311; 0.84966406408060820968780809929000689031102959682556817866\n75784732918771195689298 -0.610780879606481381872221321683947349540242287475\n5662811964404240107423300030211; 2.0170249116303885826459953083292604021232\n98642614218908427738424621856977225997 3.2038682763560962160817603812110507\n97717015562873709130238223977448301117565621; 0.066418611800177891739370928\n6447197039374200407751229380603067839449702959776234 0.42567317801766546267\n52245985949814421363581849618145926718692312748847773209589]\n [-0.5535152413276966547126085146659920232039809590727065922470779278837273\n604446314 -2.68976800980470463593686342293804597085081545304736797936258065\n190185270801543; 2.47187664215331604569590372567810304948862165789576535496\n6984945876586384284602 2.28912903148757393151483885750368277222422667815978\n9301716104703793692750138216; 3.0876802215518665221407072525560459686988869\n04564556208894167053935718932374585 6.8226195243784239062360100549807994762\n75598698637449619014625500346695188144235; -1.23462731922338697469695995284\n8443903590012911068330500317396096190182497812944 -2.0706706059455992375544\n20586353046465950126151382554281601996400985221921999]\n [1.23309027327793500473858443206594829803763768955384041283355247669337190\n4058872 0.15915056441766642611701673223167539774852295882892334194837309412\n92630091850624; 4.653370992046395638011709438733940972844823649045083062177\n018407321394365591331 7.021091259367930692153293721068725305308389042073779\n974009505267325739194211646; 2.56168888971947932524925499414614763454921782\n2190027975030408953260572480212338 7.38017565606460977243860994064483565491\n9197887840992375938694496266513805436211; -2.271645575569937310333665370481\n826834888720636357471941701763257661280941670421 -4.31165414450274677407613\n4011103462276693641638349764709925568719460005028893542]","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"sol[1,3]","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"-0.397145504566105787158300730252517897047433921969539294946007053641785534\n3798884","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"To really make use of this, we would want to change abstol and reltol to be small! Notice that the type for \"time\" is different than the type for the dependent variables, and this can be used to optimize the algorithm via keeping multiple precisions. We can convert time to be arbitrary precision as well by defining our time span with BigFloat variables:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"prob = ODEProblem(f,big_u0,big.(tspan))\nsol = solve(prob)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"retcode: Success\nInterpolation: automatic order switching interpolation\nt: 6-element Vector{BigFloat}:\n 0.0\n 0.033101073069197498219941999568621391581962542315611620290345971364972686\n27152473\n 0.206961738088371965072040594512409027450272557247879927000771045747165639\n7814062\n 0.489610659955685951052930989970056149632220960513998216744469802303939864\n721736\n 0.801963224301100794548260585623504944993207531476574643481856572314590487\n6403047\n 1.0\nu: 6-element Vector{Matrix{BigFloat}}:\n [0.014747968966241753463464192464016377925872802734375 0.14496017235002933\n70960889660636894404888153076171875; 0.540514676458290210803170339204370975\n494384765625 0.7507124983144184415806421384331770241260528564453125; 0.8637\n77191295380664115555191528983414173126220703125 0.2494070971239048528644843\n827350996434688568115234375; 0.25268820618439447045489032461773604154586791\n9921875 0.8557131569434830442588690857519395649433135986328125]\n [-0.0312207520256040232038387457028117409930652255633009388706657410453921\n9854447601 -0.0002374973746370136686637621442949619665299533487146233450740\n818779101156243420605; 0.58957066073643911377359491293201947836404859768661\n67365986143851153298186977966 0.6592186005224230919688959176136864322393562\n446374196932441411254077441658956819; 0.87391082410375363833867602081638979\n73283504954481039414382322759408495906473331 0.2691710215066015820776253846\n115689814288899198725977273849955688518754877735026; 0.29888519570172969060\n1269975876238908599840752599329916612079482344130223110089 0.92678011441524\n55260232417252949585449587609769117104632981334014384821932547719]\n [-0.3971455045661057954891918188459454214461377140441721991385930938649555\n090549053 -0.99206425850354893589133991688314380065088078097692925167662614\n18573811027958551; 0.686839848952166655599988873082666423846574173744605450\n3303599863696778457809135 -0.0097469204373119594109339829759998156696465656\n52844700476726528064185355332316201; 1.078838985132652147201985781688757222\n695889620901757605163107608725159900606579 0.776999990982186943470773007101\n978319184919072821135498956397012169769920707775; 0.42756765110415815955181\n17257120916662970801854204338613846709667290926777850861 1.1079535329251163\n7829824033032216956459004002247439798948200991791458853004144]\n [-1.0530123841255846851312186476194671908271315323551008406457128333178467\n84176498 -2.786064876306963978190828771078410793083983827348697499249823653\n394474679267319; 0.84966406408060819687102792546253325339244021954526426725\n57462571502052635434822 -0.610780879606481392451607653268327800505016043417\n596310655685661542417854027764; 2.01702491163038855463213866226325310390547\n5959665516120104574229754711066722292 3.20386827635609614032603802567170967\n2805235380137030673967796960208838451252158; 0.0664186118001779096215214367\n205840262416639135566252152759778827543963927643886 0.425673178017665495570\n5985483671799144112844292353560306353008638694281612946641]\n [-0.5535152413276967988123056551342428180587250815737412628107849962553929\n360043278 -2.68976800980470483244838389861796173188907459114128690581012230\n9719712184450036; 2.4718766421533158175623061474116395920685834523232278424\n6089404616011438959795 2.28912903148757346571942385721713333227981412614209\n2503777534666149548048349013; 3.0876802215518664970258565621914095176945924\n0059080687527529180575680691884406 6.82261952437842368344596539195626649189\n6610235755258761873006155301830665408277; -1.234627319223386840335441441128\n000121822012314818185845076868174824014715699702 -2.07067060594559896590383\n2847894022252686872967989397973085132445754667697015884]\n [1.23309027327793456788947971612362856485509898447006448145513716287830045\n8327467 0.15915056441766567264259322535151641146428470974144133284346401746\n5468874606167; 4.6533709920463951978321918348852261476520021815585890558147\n9201812911492306714 7.02109125936792968427604053880132433093800237741520498\n3840043148270836352421911; 2.5616888897194795751884709103661813580881154133\n92543831043686447544089540449663 7.3801756560646099441157965186700230200637\n63050715237114006013750300789150834864; -2.27164557556993714266052590833812\n0511387887531916619541317559377769405784530876 -4.3116541445027463778292015\n48821765212521286601495713954941234870679463160904216]","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"Let's end by showing a more complicated use of types. For small arrays, it's usually faster to do operations on static arrays via the package StaticArrays.jl. The syntax is similar to that of normal arrays, but for these special arrays we utilize the @SMatrix macro to indicate we want to create a static array.","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"using StaticArrays\nA  = @SMatrix [ 1.0  0.0 0.0 -5.0\n                4.0 -2.0 4.0 -3.0\n               -4.0  0.0 0.0  1.0\n                5.0 -2.0 2.0  3.0]\nu0 = @SMatrix rand(4,2)\ntspan = (0.0,1.0)\nf(u,p,t) = A*u\nprob = ODEProblem(f,u0,tspan)\nsol = solve(prob)","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"retcode: Success\nInterpolation: automatic order switching interpolation\nt: 11-element Vector{Float64}:\n 0.0\n 0.028497485729204085\n 0.09677891087850361\n 0.1838629699017056\n 0.2792755454678705\n 0.3849487087012745\n 0.5037834259824925\n 0.6535425718374789\n 0.8219485208527942\n 0.9963187838589457\n 1.0\nu: 11-element Vector{StaticArrays.SMatrix{4, 2, Float64, 8}}:\n [0.6044706715729704 0.6651681883844265; 0.25696570195459634 0.800391802344\n2045; 0.5029536403278085 0.3575093833720393; 0.03794176795515902 0.09872799\n410985289]\n [0.6090164207338807 0.6645296194502982; 0.35457436842122125 0.853916279412\n2843; 0.4362080107118939 0.2855402087083679; 0.1414591941953183 0.176444624\n92944807]\n [0.5589668179776879 0.617139289324531; 0.5008618571017903 0.90974959705322\n08; 0.29280087873465277 0.1273279080385313; 0.3871952918505474 0.3583276474\n184245]\n [0.36634268206197285 0.46125231125305666; 0.5134472682634394 0.84001531044\n81114; 0.17421053662677327 -0.022875618363667027; 0.6825695145311004 0.5726\n310798164117]\n [-0.009281357125025314 0.17041174891042277; 0.3292691258680993 0.606597367\n2565503; 0.17953773911100426 -0.08288929953020502; 0.9584979147235346 0.768\n7986346795259]\n [-0.6078927872865104 -0.2833285077901624; -0.05096132785483232 0.210325411\n44468148; 0.41730328857484894 0.026313633816218568; 1.1700472012314482 0.91\n59657644107604]\n [-1.4549440823926374 -0.9185322671331277; -0.566177652311823 -0.3049762534\n505666; 1.0471161872690764 0.42085045378126773; 1.2388752217176495 0.961003\n1099688554]\n [-2.6191532157534585 -1.7920259126501163; -1.0407475360982281 -0.831463713\n6681373; 2.4398891539460696 1.3669469970508974; 0.9841484657160131 0.780816\n5896257838]\n [-3.671802984762903 -2.6075076971462505; -0.7885898418834298 -0.8586739891\n952148; 4.691977368425225 2.9568352561684854; 0.13256776797971892 0.1907674\n2240190392]\n [-3.8254590396795334 -2.8220823558456196; 1.0282240305582555 0.23124784284\n706623; 7.280705717329159 4.848706337087659; -1.4394260741422142 -0.8942786\n8657168]\n [-3.8126523625270052 -2.8157427240759465; 1.0879003580861206 0.26960362245\n150576; 7.331568628025925 4.886871737110194; -1.4798387330520493 -0.9221991\n731068224]","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"sol[3]","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"4×2 StaticArrays.SMatrix{4, 2, Float64, 8} with indices SOneTo(4)×SOneTo(2)\n:\n 0.558967  0.617139\n 0.500862  0.90975\n 0.292801  0.127328\n 0.387195  0.358328","category":"page"},{"location":"introduction/01-ode_introduction/#Conclusion","page":"An Intro to DifferentialEquations.jl","title":"Conclusion","text":"","category":"section"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"These are the basic controls in DifferentialEquations.jl. All equations are defined via a problem type, and the solve command is used with an algorithm choice (or the default) to get a solution. Every solution acts the same, like an array sol[i] with sol.t[i], and also like a continuous function sol(t) with a nice plot command plot(sol). The Common Solver Options can be used to control the solver for any equation type. Lastly, the types used in the numerical solving are determined by the input types, and this can be used to solve with arbitrary precision and add additional optimizations (this can be used to solve via GPUs for example!). While this was shown on ODEs, these techniques generalize to other types of equations as well.","category":"page"},{"location":"introduction/01-ode_introduction/#Appendix","page":"An Intro to DifferentialEquations.jl","title":"Appendix","text":"","category":"section"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"introduction\",\"01-ode_introduction.jmd\")","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"Computer Information:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"Julia Version 1.6.3\nCommit ae8452a9e0 (2021-09-23 17:34 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, znver2)\nEnvironment:\n  JULIA_CPU_THREADS = 16\n  BUILDKITE_PLUGIN_JULIA_CACHE_DIR = /cache/julia-buildkite-plugin\n  JULIA_DEPOT_PATH = /cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"Package Information:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"      Status `/cache/build/amdci4-4/julialang/scimltutorials-dot-jl/tutorials/introduction/Project.toml`\n  [6e4b80f9] BenchmarkTools v1.0.0\n  [0c46a032] DifferentialEquations v6.17.1\n  [65888b18] ParameterizedFunctions v5.10.0\n  [91a5bcdd] Plots v1.15.2\n  [30cb0354] SciMLTutorials v0.9.0\n  [90137ffa] StaticArrays v1.2.0\n  [c3572dad] Sundials v4.4.3\n  [37e2e46d] LinearAlgebra","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"And the full manifest:","category":"page"},{"location":"introduction/01-ode_introduction/","page":"An Intro to DifferentialEquations.jl","title":"An Intro to DifferentialEquations.jl","text":"      Status `/cache/build/amdci4-4/julialang/scimltutorials-dot-jl/tutorials/introduction/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.16.0\n  [1520ce14] AbstractTrees v0.3.4\n  [79e6a3ab] Adapt v3.3.0\n  [ec485272] ArnoldiMethod v0.1.0\n  [4fba245c] ArrayInterface v3.1.15\n  [4c555306] ArrayLayouts v0.7.0\n  [aae01518] BandedMatrices v0.16.9\n  [6e4b80f9] BenchmarkTools v1.0.0\n  [764a87c0] BoundaryValueDiffEq v2.7.1\n  [fa961155] CEnum v0.4.1\n  [d360d2e6] ChainRulesCore v0.9.44\n  [b630d9fa] CheapThreads v0.2.5\n  [35d6a980] ColorSchemes v3.12.1\n  [3da002f7] ColorTypes v0.11.0\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [38540f10] CommonSolve v0.2.0\n  [bbf7d656] CommonSubexpressions v0.3.0\n  [34da2185] Compat v3.30.0\n  [8f4d0f93] Conda v1.5.2\n  [187b0558] ConstructionBase v1.2.1\n  [d38c429a] Contour v0.5.7\n  [9a962f9c] DataAPI v1.6.0\n  [864edb3b] DataStructures v0.18.9\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [bcd4f6db] DelayDiffEq v5.31.0\n  [2b5f629d] DiffEqBase v6.62.2\n  [459566f4] DiffEqCallbacks v2.16.1\n  [5a0ffddc] DiffEqFinancial v2.4.0\n  [c894b116] DiffEqJump v6.14.2\n  [77a26b50] DiffEqNoiseProcess v5.7.3\n  [055956cb] DiffEqPhysics v3.9.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.0.2\n  [0c46a032] DifferentialEquations v6.17.1\n  [c619ae07] DimensionalPlotRecipes v1.2.0\n  [b4f34e82] Distances v0.10.3\n  [31c24e10] Distributions v0.24.18\n  [ffbed154] DocStringExtensions v0.8.4\n  [d4d017d3] ExponentialUtilities v1.8.4\n  [e2ba6199] ExprTools v0.1.3\n  [c87230d0] FFMPEG v0.4.0\n  [7034ab61] FastBroadcast v0.1.8\n  [9aa1b823] FastClosures v0.3.2\n  [1a297f60] FillArrays v0.11.7\n  [6a86dc24] FiniteDiff v2.8.0\n  [53c48c17] FixedPointNumbers v0.8.4\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.18\n  [069b7b12] FunctionWrappers v1.1.2\n  [28b8d3ca] GR v0.57.4\n  [5c1252a2] GeometryBasics v0.3.12\n  [42e2da0e] Grisu v1.0.2\n  [cd3eb016] HTTP v0.9.9\n  [eafb193a] Highlights v0.4.5\n  [0e44f5e4] Hwloc v2.0.0\n  [7073ff75] IJulia v1.23.2\n  [615f187c] IfElse v0.1.0\n  [d25df0c9] Inflate v0.1.2\n  [83e8ac13] IniFile v0.5.0\n  [c8e1da08] IterTools v1.3.0\n  [42fd0dbc] IterativeSolvers v0.9.1\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.3.0\n  [682c06a0] JSON v0.21.1\n  [b964fa9f] LaTeXStrings v1.2.1\n  [2ee39098] LabelledArrays v1.6.1\n  [23fbe1c1] Latexify v0.15.5\n  [093fc24a] LightGraphs v1.3.5\n  [d3d80556] LineSearches v7.1.1\n  [2ab3a3ac] LogExpFunctions v0.2.4\n  [bdcacae8] LoopVectorization v0.12.23\n  [1914dd2f] MacroTools v0.5.6\n  [739be429] MbedTLS v1.0.3\n  [442fdcdd] Measures v0.3.1\n  [e1d29d7a] Missings v1.0.0\n  [961ee093] ModelingToolkit v5.16.0\n  [46d2c3a1] MuladdMacro v0.2.2\n  [f9640e96] MultiScaleArrays v1.8.1\n  [ffc61752] Mustache v1.0.10\n  [d41bc354] NLSolversBase v7.8.0\n  [2774e3e8] NLsolve v4.5.1\n  [77ba4419] NaNMath v0.3.5\n  [8913a72c] NonlinearSolve v0.3.8\n  [6fe1bfb0] OffsetArrays v1.9.0\n  [429524aa] Optim v1.3.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [90014a1f] PDMats v0.11.0\n  [65888b18] ParameterizedFunctions v5.10.0\n  [d96e819e] Parameters v0.12.2\n  [69de0a69] Parsers v1.1.0\n  [ccf2f8ad] PlotThemes v2.0.1\n  [995b91a9] PlotUtils v1.0.10\n  [91a5bcdd] Plots v1.15.2\n  [e409e4f3] PoissonRandom v0.4.0\n  [f517fe37] Polyester v0.3.1\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [21216c6a] Preferences v1.2.2\n  [1fd47b50] QuadGK v2.4.1\n  [74087812] Random123 v1.3.1\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.4.0\n  [3cdcf5f2] RecipesBase v1.1.1\n  [01d81517] RecipesPipeline v0.3.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [f2c3362d] RecursiveFactorization v0.1.12\n  [189a3867] Reexport v1.0.0\n  [ae029012] Requires v1.1.3\n  [ae5879a3] ResettableStacks v1.1.0\n  [79098fc4] Rmath v0.7.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.2\n  [476501e8] SLEEFPirates v0.6.20\n  [1bc83da4] SafeTestsets v0.0.1\n  [0bca4576] SciMLBase v1.13.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [6c6a2e73] Scratch v1.0.3\n  [efcf1570] Setfield v0.7.0\n  [992d4aef] Showoff v1.0.3\n  [699a6c99] SimpleTraits v0.9.3\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.0\n  [47a9eef4] SparseDiffTools v1.13.2\n  [276daf66] SpecialFunctions v1.4.1\n  [aedffcd0] Static v0.2.4\n  [90137ffa] StaticArrays v1.2.0\n  [82ae8749] StatsAPI v1.0.0\n  [2913bbd2] StatsBase v0.33.8\n  [4c63d2b9] StatsFuns v0.9.8\n  [9672c7b4] SteadyStateDiffEq v1.6.2\n  [789caeaf] StochasticDiffEq v6.34.1\n  [7792a7ef] StrideArraysCore v0.1.11\n  [09ab397b] StructArrays v0.5.1\n  [c3572dad] Sundials v4.4.3\n  [d1185830] SymbolicUtils v0.11.2\n  [0c5d862f] Symbolics v0.1.25\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.4.2\n  [8290d209] ThreadingUtilities v0.4.4\n  [a759f4b9] TimerOutputs v0.5.9\n  [a2a6695c] TreeViews v0.3.0\n  [5c2747f8] URIs v1.3.0\n  [3a884ed6] UnPack v1.0.2\n  [1986cc42] Unitful v1.7.0\n  [3d5dd08c] VectorizationBase v0.20.11\n  [81def892] VersionParsing v1.2.0\n  [19fa3120] VertexSafeGraphs v0.1.2\n  [44d3d7a6] Weave v0.10.8\n  [ddb6d928] YAML v0.4.6\n  [c2297ded] ZMQ v1.2.1\n  [700de1a5] ZygoteRules v0.2.1\n  [6e34b625] Bzip2_jll v1.0.6+5\n  [83423d85] Cairo_jll v1.16.0+6\n  [5ae413db] EarCut_jll v2.1.5+1\n  [2e619515] Expat_jll v2.2.10+0\n  [b22a6f82] FFMPEG_jll v4.3.1+4\n  [a3f928ae] Fontconfig_jll v2.13.1+14\n  [d7e528f0] FreeType2_jll v2.10.1+5\n  [559328eb] FriBidi_jll v1.0.5+6\n  [0656b61e] GLFW_jll v3.3.4+0\n  [d2c73de3] GR_jll v0.57.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.1+0\n  [e33a78d0] Hwloc_jll v2.4.1+0\n  [aacddb02] JpegTurbo_jll v2.0.1+3\n  [c1c5ebd0] LAME_jll v3.100.0+3\n  [dd4b983a] LZO_jll v2.10.1+0\n  [dd192d2f] LibVPX_jll v1.9.0+1\n  [e9f186c6] Libffi_jll v3.2.2+0\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+0\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.1.0+2\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [e7412a2a] Ogg_jll v1.3.4+2\n  [458c3c95] OpenSSL_jll v1.1.1+6\n  [efe28fd5] OpenSpecFun_jll v0.5.4+0\n  [91d4177d] Opus_jll v1.3.1+3\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.2+0\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.0+1\n  [a2964d1f] Wayland_jll v1.17.0+4\n  [2381bf8a] Wayland_protocols_jll v1.18.0+4\n  [02c8fc9c] XML2_jll v2.9.12+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.2+6\n  [3161d3a3] Zstd_jll v1.5.0+0\n  [0ac62f75] libass_jll v0.14.0+4\n  [f638f0a6] libfdk_aac_jll v0.1.6+4\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.6+6\n  [1270edf5] x264_jll v2020.7.14+2\n  [dfaa095f] x265_jll v3.0.0+3\n  [d8fb68d0] xkbcommon_jll v0.9.1+5\n  [0dad84c5] ArgTools\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [b27032c2] LibCURL\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions\n  [44cfe95a] Pkg\n  [de0858da] Printf\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML\n  [a4e569a6] Tar\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll\n  [deac9b47] LibCURL_jll\n  [29816b5a] LibSSH2_jll\n  [c8ffd9c3] MbedTLS_jll\n  [14a3606d] MozillaCACerts_jll\n  [4536629a] OpenBLAS_jll\n  [bea87d4a] SuiteSparse_jll\n  [83775a58] Zlib_jll\n  [8e850ede] nghttp2_jll\n  [3f19e933] p7zip_jll","category":"page"},{"location":"introduction/02-choosing_algs/#Choosing-an-ODE-Algorithm","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"","category":"section"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"While the default algorithms, along with alg_hints = [:stiff], will suffice in most cases, there are times when you may need to exert more control. The purpose of this part of the tutorial is to introduce you to some of the most widely used algorithm choices and when they should be used. The corresponding page of the documentation is the ODE Solvers page which goes into more depth.","category":"page"},{"location":"introduction/02-choosing_algs/#Diagnosing-Stiffness","page":"Choosing an ODE Algorithm","title":"Diagnosing Stiffness","text":"","category":"section"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"One of the key things to know for algorithm choices is whether your problem is stiff. Let's take for example the driven Van Der Pol equation:","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"using DifferentialEquations, ParameterizedFunctions\nvan! = @ode_def VanDerPol begin\n  dy = μ*((1-x^2)*y - x)\n  dx = 1*y\nend μ\n\nprob = ODEProblem(van!,[0.0,2.0],(0.0,6.3),1e6)","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"ODEProblem with uType Array{Float64,1} and tType Float64. In-place: true\ntimespan: (0.0, 6.3)\nu0: [0.0, 2.0]","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"One indicating factor that should alert you to the fact that this model may be stiff is the fact that the parameter is 1e6: large parameters generally mean stiff models. If we try to solve this with the default method:","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"sol = solve(prob,Tsit5())","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"retcode: MaxIters\nInterpolation: specialized 4th order \"free\" interpolation\nt: 999977-element Array{Float64,1}:\n 0.0\n 4.997501249375313e-10\n 5.4972513743128435e-9\n 3.289919594544218e-8\n 9.055581394883546e-8\n 1.7309428803584187e-7\n 2.79375393394586e-7\n 4.149527171475212e-7\n 5.807919390815544e-7\n 7.81280701490125e-7\n ⋮\n 1.8457012081010522\n 1.845702696026691\n 1.8457041839548325\n 1.8457056718857727\n 1.845707159819413\n 1.8457086477557534\n 1.8457101356946952\n 1.8457116236362385\n 1.8457131115805805\nu: 999977-element Array{Array{Float64,1},1}:\n [0.0, 2.0]\n [-0.0009987513736106552, 1.9999999999997504]\n [-0.010904339759596433, 1.9999999999699458]\n [-0.06265556194129239, 1.9999999989523902]\n [-0.1585948892562767, 1.9999999924944207]\n [-0.2700352862461109, 1.9999999746155703]\n [-0.3783197963325601, 1.9999999398563364]\n [-0.47467864703912216, 1.9999998815910678]\n [-0.5499302545937235, 1.999999796115446]\n [-0.6026934372089534, 1.9999996800439757]\n ⋮\n [-0.7770871866226842, 1.8321769350351387]\n [-0.7770880934309836, 1.8321757783565626]\n [-0.7770890004563554, 1.832174621674691]\n [-0.7770899073362528, 1.832173464989294]\n [-0.7770908141915421, 1.832172308300448]\n [-0.777091721022237, 1.8321711516081531]\n [-0.7770926279492066, 1.832169994912486]\n [-0.7770935349724621, 1.8321688382134467]\n [-0.7770944418503102, 1.8321676815108816]","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"Here it shows that maximum iterations were reached. Another thing that can happen is that the solution can return that the solver was unstable (exploded to infinity) or that dt became too small. If these happen, the first thing to do is to check that your model is correct. It could very well be that you made an error that causes the model to be unstable!","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"If the model is not the problem, then stiffness could be the reason. We can thus hint to the solver to use an appropriate method:","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"sol = solve(prob,alg_hints = [:stiff])","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"retcode: Success\nInterpolation: specialized 3rd order \"free\" stiffness-aware interpolation\nt: 1226-element Array{Float64,1}:\n 0.0\n 4.997501249375313e-10\n 5.453184230996133e-9\n 1.895183630235216e-8\n 4.149247971579005e-8\n 7.307376959633615e-8\n 1.1713591893796848e-7\n 1.7479822117537617e-7\n 2.486030087103307e-7\n 3.4022788683889606e-7\n ⋮\n 6.188041517724838\n 6.204913043782912\n 6.2217845698409855\n 6.238656095899059\n 6.253679862101827\n 6.268703628304595\n 6.282070305195064\n 6.2954369820855325\n 6.3\nu: 1226-element Array{Array{Float64,1},1}:\n [0.0, 2.0]\n [-0.000998751373610652, 1.9999999999997504]\n [-0.010817641311225656, 1.9999999999704245]\n [-0.03684629017642281, 1.9999999996475395]\n [-0.07802787837298908, 1.9999999983476398]\n [-0.13123735922182378, 1.99999999502994]\n [-0.19753547724970358, 1.9999999877545467]\n [-0.27205756492789135, 1.9999999741537076]\n [-0.35043290542710875, 1.9999999510756288]\n [-0.42643392266323493, 1.9999999153260477]\n ⋮\n [1.0971561367809486, -1.554613011001242]\n [1.1302170319936697, -1.535817137514224]\n [1.1667415189790122, -1.516434006501714]\n [1.2073883637970209, -1.4963996433335196]\n [1.247774778031224, -1.4779508004118078]\n [1.292840162501961, -1.4588601889598454]\n [1.3377470703606134, -1.4412739713742109]\n [1.388065609850801, -1.4230515564498547]\n [1.4068511716709224, -1.4166737780416512]","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"Or we can use the default algorithm. By default, DifferentialEquations.jl uses algorithms like AutoTsit5(Rodas5()) which automatically detect stiffness and switch to an appropriate method once stiffness is known.","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"sol = solve(prob)","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"retcode: Success\nInterpolation: Automatic order switching interpolation\nt: 38190-element Array{Float64,1}:\n 0.0\n 4.997501249375313e-10\n 5.4972513743128435e-9\n 3.289919594544218e-8\n 9.055581394883546e-8\n 1.7309428803584187e-7\n 2.79375393394586e-7\n 4.149527171475212e-7\n 5.807919390815544e-7\n 7.81280701490125e-7\n ⋮\n 6.299119356444013\n 6.299244744062207\n 6.2993700837874025\n 6.2994953756213015\n 6.299620619573913\n 6.299745815655246\n 6.299870963883599\n 6.29999606426898\n 6.3\nu: 38190-element Array{Array{Float64,1},1}:\n [0.0, 2.0]\n [-0.0009987513736106552, 1.9999999999997504]\n [-0.010904339759596433, 1.9999999999699458]\n [-0.06265556194129239, 1.9999999989523902]\n [-0.1585948892562767, 1.9999999924944207]\n [-0.2700352862461109, 1.9999999746155703]\n [-0.3783197963325601, 1.9999999398563364]\n [-0.47467864703912216, 1.9999998815910678]\n [-0.5499302545937235, 1.999999796115446]\n [-0.6026934372089534, 1.9999996800439757]\n ⋮\n [1.3775946417912535, -1.4267417163857983]\n [1.3780838380959652, -1.4265689388521878]\n [1.378573407853009, -1.4263961659683526]\n [1.3790633515217017, -1.4262233977319996]\n [1.3795536695700248, -1.4260506341293753]\n [1.3800443624757206, -1.425877875146702]\n [1.3805354307415847, -1.4257051207587392]\n [1.3810268748552081, -1.4255323709516574]\n [1.381165043579902, -1.425526935263265]","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"Another way to understand stiffness is to look at the solution.","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"using Plots; gr()\nsol = solve(prob,alg_hints = [:stiff],reltol=1e-6)\nplot(sol,denseplot=false)","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"(Image: )","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"Let's zoom in on the y-axis to see what's going on:","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"plot(sol,ylims = (-10.0,10.0))","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"(Image: )","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"Notice how there are some extreme vertical shifts that occur. These vertical shifts are places where the derivative term is very large, and this is indicative of stiffness. This is an extreme example to highlight the behavior, but this general idea can be carried over to your problem. When in doubt, simply try timing using both a stiff solver and a non-stiff solver and see which is more efficient.","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"To try this out, let's use BenchmarkTools, a package that let's us relatively reliably time code blocks.","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"function lorenz!(du,u,p,t)\n    σ,ρ,β = p\n    du[1] = σ*(u[2]-u[1])\n    du[2] = u[1]*(ρ-u[3]) - u[2]\n    du[3] = u[1]*u[2] - β*u[3]\nend\nu0 = [1.0,0.0,0.0]\np = (10,28,8/3)\ntspan = (0.0,100.0)\nprob = ODEProblem(lorenz!,u0,tspan,p)","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"ODEProblem with uType Array{Float64,1} and tType Float64. In-place: true\ntimespan: (0.0, 100.0)\nu0: [1.0, 0.0, 0.0]","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"And now, let's use the @btime macro from benchmark tools to compare the use of non-stiff and stiff solvers on this problem.","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"using BenchmarkTools\n@btime solve(prob);","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"866.080 μs (13110 allocations: 1.42 MiB)\nretcode: Success\nInterpolation: Automatic order switching interpolation\nt: 1294-element Array{Float64,1}:\n   0.0\n   3.5678604836301404e-5\n   0.0003924646531993154\n   0.0032624077544510573\n   0.009058075635317072\n   0.01695646895607931\n   0.0276899566248403\n   0.041856345938267966\n   0.06024040228733675\n   0.08368539694547242\n   ⋮\n  99.39403070915297\n  99.47001147494375\n  99.54379656909015\n  99.614651558349\n  99.69093823148101\n  99.78733023233721\n  99.86114450046736\n  99.96115759510786\n 100.0\nu: 1294-element Array{Array{Float64,1},1}:\n [1.0, 0.0, 0.0]\n [0.9996434557625105, 0.0009988049817849058, 1.781434788799208e-8]\n [0.9961045497425811, 0.010965399721242457, 2.146955365838907e-6]\n [0.9693591634199452, 0.08977060667778931, 0.0001438018342266937]\n [0.9242043615038835, 0.24228912482984957, 0.0010461623302512404]\n [0.8800455868998046, 0.43873645009348244, 0.0034242593451028745]\n [0.8483309877783048, 0.69156288756671, 0.008487623500490047]\n [0.8495036595681027, 1.0145425335433382, 0.01821208597613427]\n [0.9139069079152129, 1.4425597546855036, 0.03669381053327124]\n [1.0888636764765296, 2.052326153029042, 0.07402570506414284]\n ⋮\n [12.999157033749652, 14.10699925404482, 31.74244844521858]\n [11.646131422021162, 7.2855792145502845, 35.365000488215486]\n [7.777555445486692, 2.5166095828739574, 32.030953593541675]\n [4.739741627223412, 1.5919220588229062, 27.249779003951755]\n [3.2351668945618774, 2.3121727966182695, 22.724936101772805]\n [3.310411964698304, 4.28106626744641, 18.435441144016366]\n [4.527117863517627, 6.895878639772805, 16.58544600757436]\n [8.043672261487556, 12.711555298531689, 18.12537420595938]\n [9.97537965430362, 15.143884806010783, 21.00643286956427]","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"@btime solve(prob,alg_hints = [:stiff]);","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"9.596 ms (63543 allocations: 2.78 MiB)\nretcode: Success\nInterpolation: specialized 3rd order \"free\" stiffness-aware interpolation\nt: 2353-element Array{Float64,1}:\n   0.0\n   3.5678604836301404e-5\n   0.0003924646531993154\n   0.0015292937978620778\n   0.003162305724282332\n   0.005285973552599222\n   0.008023688976652094\n   0.01144101871159114\n   0.0156693459080261\n   0.020826710718121224\n   ⋮\n  99.64643805711006\n  99.69715002361579\n  99.75331122793506\n  99.79981678120402\n  99.84132760768253\n  99.88283843416104\n  99.92434926063956\n  99.96697093084641\n 100.0\nu: 2353-element Array{Array{Float64,1},1}:\n [1.0, 0.0, 0.0]\n [0.9996434557625105, 0.0009988049817849047, 1.7814347887985208e-8]\n [0.9961045497425969, 0.0109653997212298, 2.146955365112677e-6]\n [0.9851473616483439, 0.04246652425810003, 3.21927130421189e-5]\n [0.9702414465725462, 0.08706126023105658, 0.00013525574346441506]\n [0.9522854546465404, 0.14396668240059424, 0.00036967772967708476]\n [0.9314326271963391, 0.21565548792970338, 0.0008289976215629184]\n [0.9088641247467208, 0.3027798780735744, 0.001632872227230375]\n [0.8859643488922837, 0.4074631051549474, 0.002954345942806542]\n [0.8650679703454024, 0.5313629257625292, 0.0050183974807311285]\n ⋮\n [12.806695275278894, 12.494656408454457, 33.00345553979429]\n [11.743080430598853, 8.043506580216379, 34.89282227510988]\n [9.11982468203129, 3.968709691943006, 33.23949044247742]\n [6.836119847459929, 2.3677711311840715, 30.424290289803416]\n [5.229488956523552, 1.9977361551169743, 27.73491536637819]\n [4.156928665122608, 2.2016007548657157, 25.204702582122852]\n [3.5806565170126663, 2.724678757457538, 22.930442334447942]\n [3.4202075264870198, 3.4950829296305566, 20.89909215126914]\n [3.5509784304871257, 4.260058718117392, 19.561783277650832]","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"In this particular case, we can see that non-stiff solvers get us to the solution much more quickly.","category":"page"},{"location":"introduction/02-choosing_algs/#The-Recommended-Methods","page":"Choosing an ODE Algorithm","title":"The Recommended Methods","text":"","category":"section"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"When picking a method, the general rules are as follows:","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"Higher order is more efficient at lower tolerances, lower order is more efficient at higher tolerances\nAdaptivity is essential in most real-world scenarios\nRunge-Kutta methods do well with non-stiff equations, Rosenbrock methods do well with small stiff equations, BDF methods do well with large stiff equations","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"While there are always exceptions to the rule, those are good guiding principles. Based on those, a simple way to choose methods is:","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"The default is Tsit5(), a non-stiff Runge-Kutta method of Order 5\nIf you use low tolerances (1e-8), try Vern7() or Vern9()\nIf you use high tolerances, try BS3()\nIf the problem is stiff, try Rosenbrock23(), Rodas5(), or CVODE_BDF()\nIf you don't know, use AutoTsit5(Rosenbrock23()) or AutoVern9(Rodas5()).","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"(This is a simplified version of the default algorithm chooser)","category":"page"},{"location":"introduction/02-choosing_algs/#Comparison-to-other-Software","page":"Choosing an ODE Algorithm","title":"Comparison to other Software","text":"","category":"section"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"If you are familiar with MATLAB, SciPy, or R's DESolve, here's a quick translation start to have transfer your knowledge over.","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"ode23 -> BS3()\node45/dopri5 -> DP5(), though in most cases Tsit5() is more efficient\node23s -> Rosenbrock23(), though in most cases Rodas4() is more efficient\node113 -> VCABM(), though in many cases Vern7() is more efficient\ndop853 -> DP8(), though in most cases Vern7() is more efficient\node15s/vode -> QNDF(), though in many cases CVODE_BDF(), Rodas4() or radau() are more efficient\node23t -> Trapezoid() for efficiency and GenericTrapezoid() for robustness\node23tb -> TRBDF2\nlsoda -> lsoda() (requires ]add LSODA; using LSODA)\node15i -> IDA(), though in many cases Rodas4() can handle the DAE and is significantly more efficient","category":"page"},{"location":"introduction/02-choosing_algs/#Appendix","page":"Choosing an ODE Algorithm","title":"Appendix","text":"","category":"section"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"This tutorial is part of the SciMLTutorials.jl repository, found at: https://github.com/SciMLTutorials/SciMLTutorials.jl.  For more information on doing scientific machine learning (SciML) with open source software, check out https://sciml.ai/.","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"introduction\",\"02-choosing_algs.jmd\")","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"Computer Information:","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"Julia Version 1.4.2\nCommit 44fa15b150* (2020-05-23 18:35 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Core(TM) i7-9700K CPU @ 3.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-8.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_LOAD_PATH = /builds/JuliaGPU/DiffEqTutorials.jl:\n  JULIA_DEPOT_PATH = /builds/JuliaGPU/DiffEqTutorials.jl/.julia\n  JULIA_CUDA_MEMORY_LIMIT = 2147483648\n  JULIA_NUM_THREADS = 8\n","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"Package Information:","category":"page"},{"location":"introduction/02-choosing_algs/","page":"Choosing an ODE Algorithm","title":"Choosing an ODE Algorithm","text":"Status `/builds/JuliaGPU/DiffEqTutorials.jl/tutorials/introduction/Project.toml`\n[6e4b80f9-dd63-53aa-95a3-0cdb28fa8baf] BenchmarkTools 0.5.0\n[0c46a032-eb83-5123-abaf-570d42b7fbaa] DifferentialEquations 6.15.0\n[65888b18-ceab-5e60-b2b9-181511a3b968] ParameterizedFunctions 5.4.0\n[91a5bcdd-55d7-5caf-9e0b-520d859cae80] Plots 1.5.6\n[90137ffa-7385-5640-81b9-e52037218182] StaticArrays 0.12.4\n[c3572dad-4567-51f8-b174-8c6c989267f4] Sundials 4.2.5\n[37e2e46d-f89d-539d-b4ee-838fcccc9c8e] LinearAlgebra","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/#Monte-Carlo-Parameter-Estimation-From-Data","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"","category":"section"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"First you want to create a problem which solves multiple problems at the same time. This is the Monte Carlo Problem. When the parameter estimation tools say it will take any DEProblem, it really means ANY DEProblem!","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"So, let's get a Monte Carlo problem setup that solves with 10 different initial conditions.","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\nusing DifferentialEquations, DiffEqParamEstim, Plots, Optim\n\n# Monte Carlo Problem Set Up for solving set of ODEs with different initial conditions\n\n# Set up Lotka-Volterra system\nfunction pf_func(du,u,p,t)\n  du[1] = p[1] * u[1] - p[2] * u[1]*u[2]\n  du[2] = -3 * u[2] + u[1]*u[2]\nend\np = [1.5,1.0]\nprob = ODEProblem(pf_func,[1.0,1.0],(0.0,10.0),p)","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"ODEProblem with uType Array{Float64,1} and tType Float64. In-place: true\ntimespan: (0.0, 10.0)\nu0: [1.0, 1.0]","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Now for a MonteCarloProblem we have to take this problem and tell it what to do N times via the prob_func. So let's generate N=10 different initial conditions, and tell it to run the same problem but with these 10 different initial conditions each time:","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\n# Setting up to solve the problem N times (for the N different initial conditions)\nN = 10;\ninitial_conditions = [[1.0,1.0], [1.0,1.5], [1.5,1.0], [1.5,1.5], [0.5,1.0], [1.0,0.5], [0.5,0.5], [2.0,1.0], [1.0,2.0], [2.0,2.0]]\nfunction prob_func(prob,i,repeat)\n  ODEProblem(prob.f,initial_conditions[i],prob.tspan,prob.p)\nend\nmonte_prob = MonteCarloProblem(prob,prob_func=prob_func)","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"EnsembleProblem with problem ODEProblem","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"We can check this does what we want by solving it:","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\n# Check above does what we want\nsim = solve(monte_prob,Tsit5(),num_monte=N)\nplot(sim)","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"(Image: )","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"nummonte=N means \"run N times\", and each time it runs the problem returned by the probfunc, which is always the same problem but with the ith initial condition.","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Now let's generate a dataset from that. Let's get data points at every t=0.1 using saveat, and then convert the solution into an array.","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\n# Generate a dataset from these runs\ndata_times = 0.0:0.1:10.0\nsim = solve(monte_prob,Tsit5(),num_monte=N,saveat=data_times)\ndata = Array(sim)","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"2×101×10 Array{Float64,3}:\n[:, :, 1] =\n 1.0  1.06108   1.14403   1.24917   1.37764   …  0.956979  0.983561  1.0337\n6\n 1.0  0.821084  0.679053  0.566893  0.478813     1.35559   1.10629   0.9063\n7\n\n[:, :, 2] =\n 1.0  1.01413  1.05394  1.11711   …  1.05324  1.01309  1.00811  1.03162\n 1.5  1.22868  1.00919  0.833191     2.08023  1.70818  1.39972  1.14802\n\n[:, :, 3] =\n 1.5  1.58801   1.70188   1.84193   2.00901   …  2.0153    2.21084   2.4358\n9\n 1.0  0.864317  0.754624  0.667265  0.599149     0.600943  0.549793  0.5136\n8\n\n[:, :, 4] =\n 1.5  1.51612  1.5621   1.63555   1.73531   …  1.83822   1.98545   2.15958\n 1.5  1.29176  1.11592  0.969809  0.850159     0.771088  0.691421  0.630025\n\n[:, :, 5] =\n 0.5  0.531705  0.576474  0.634384  0.706139  …  9.05366   9.4006   8.8391\n 1.0  0.77995   0.610654  0.480565  0.380645     0.809383  1.51708  2.82619\n\n[:, :, 6] =\n 1.0  1.11027   1.24238   1.39866   1.58195   …  0.753107  0.748814  0.7682\n84\n 0.5  0.411557  0.342883  0.289812  0.249142     1.73879   1.38829   1.1093\n2\n\n[:, :, 7] =\n 0.5  0.555757  0.623692  0.705084  0.80158   …  8.11213   9.10669   9.9216\n9\n 0.5  0.390449  0.30679   0.24286   0.193966     0.261294  0.455928  0.8787\n92\n\n[:, :, 8] =\n 2.0  2.11239   2.24921   2.41003   2.59433   …  3.22292   3.47356   3.7301\n1\n 1.0  0.909749  0.838025  0.783532  0.745339     0.739406  0.765524  0.8130\n04\n\n[:, :, 9] =\n 1.0  0.969326  0.971358  1.00017  …  1.25065  1.1012   1.01733  0.979304\n 2.0  1.63445   1.33389   1.09031     3.02672  2.52063  2.07503  1.69808\n\n[:, :, 10] =\n 2.0  1.92148  1.88215  1.87711  1.90264  …  2.15079  2.27937   2.43105\n 2.0  1.80195  1.61405  1.4426   1.2907      0.95722  0.884825  0.829478","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Here, data[i,j,k] is the same as sim[i,j,k] which is the same as sim[k]i,j. So data[i,j,k] is the jth timepoint of the ith variable in the kth trajectory.","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Now let's build a loss function. A loss function is some loss(sol) that spits out a scalar for how far from optimal we are. In the documentation I show that we normally do loss = L2Loss(t,data), but we can bootstrap off of this. Instead lets build an array of N loss functions, each one with the correct piece of data.","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\n# Building a loss function\nlosses = [L2Loss(data_times,data[:,:,i]) for i in 1:N]","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"10-element Array{DiffEqParamEstim.L2Loss{StepRangeLen{Float64,Base.TwicePre\ncision{Float64},Base.TwicePrecision{Float64}},Array{Float64,2},Nothing,Noth\ning,Nothing},1}:\n DiffEqParamEstim.L2Loss{StepRangeLen{Float64,Base.TwicePrecision{Float64},\nBase.TwicePrecision{Float64}},Array{Float64,2},Nothing,Nothing,Nothing}(0.0\n:0.1:10.0, [1.0 1.0610780673356452 … 0.9835609175876878 1.03375813933372; 1\n.0 0.821084277588617 … 1.1062868012281115 0.9063703701433561], nothing, not\nhing, nothing, nothing)\n DiffEqParamEstim.L2Loss{StepRangeLen{Float64,Base.TwicePrecision{Float64},\nBase.TwicePrecision{Float64}},Array{Float64,2},Nothing,Nothing,Nothing}(0.0\n:0.1:10.0, [1.0 1.0141312263418634 … 1.0081060199159142 1.0316172446513838;\n 1.5 1.228683152066521 … 1.399724197709348 1.1480244766323144], nothing, no\nthing, nothing, nothing)\n DiffEqParamEstim.L2Loss{StepRangeLen{Float64,Base.TwicePrecision{Float64},\nBase.TwicePrecision{Float64}},Array{Float64,2},Nothing,Nothing,Nothing}(0.0\n:0.1:10.0, [1.5 1.5880106683980333 … 2.2108390928827633 2.4358900204179257;\n 1.0 0.8643172923598123 … 0.5497934554116727 0.5136795231383728], nothing, \nnothing, nothing, nothing)\n DiffEqParamEstim.L2Loss{StepRangeLen{Float64,Base.TwicePrecision{Float64},\nBase.TwicePrecision{Float64}},Array{Float64,2},Nothing,Nothing,Nothing}(0.0\n:0.1:10.0, [1.5 1.5161205353418132 … 1.98544815023441 2.159582376155923; 1.\n5 1.291763682858893 … 0.6914210407725863 0.6300249062168604], nothing, noth\ning, nothing, nothing)\n DiffEqParamEstim.L2Loss{StepRangeLen{Float64,Base.TwicePrecision{Float64},\nBase.TwicePrecision{Float64}},Array{Float64,2},Nothing,Nothing,Nothing}(0.0\n:0.1:10.0, [0.5 0.5317050732862075 … 9.40059681475263 8.839104135554038; 1.\n0 0.7799498910330318 … 1.5170828246557035 2.8261900619627034], nothing, not\nhing, nothing, nothing)\n DiffEqParamEstim.L2Loss{StepRangeLen{Float64,Base.TwicePrecision{Float64},\nBase.TwicePrecision{Float64}},Array{Float64,2},Nothing,Nothing,Nothing}(0.0\n:0.1:10.0, [1.0 1.1102743524476706 … 0.7488135727436903 0.7682835552381805;\n 0.5 0.41155721428049064 … 1.3882945275734764 1.1093238617250127], nothing,\n nothing, nothing, nothing)\n DiffEqParamEstim.L2Loss{StepRangeLen{Float64,Base.TwicePrecision{Float64},\nBase.TwicePrecision{Float64}},Array{Float64,2},Nothing,Nothing,Nothing}(0.0\n:0.1:10.0, [0.5 0.5557572700553828 … 9.106689672020078 9.92168798092248; 0.\n5 0.390449424650402 … 0.4559279494700062 0.8787916230455673], nothing, noth\ning, nothing, nothing)\n DiffEqParamEstim.L2Loss{StepRangeLen{Float64,Base.TwicePrecision{Float64},\nBase.TwicePrecision{Float64}},Array{Float64,2},Nothing,Nothing,Nothing}(0.0\n:0.1:10.0, [2.0 2.112390154025954 … 3.47356127269175 3.7301053632038483; 1.\n0 0.9097494017873065 … 0.7655239702477202 0.8130037985322804], nothing, not\nhing, nothing, nothing)\n DiffEqParamEstim.L2Loss{StepRangeLen{Float64,Base.TwicePrecision{Float64},\nBase.TwicePrecision{Float64}},Array{Float64,2},Nothing,Nothing,Nothing}(0.0\n:0.1:10.0, [1.0 0.9693256296130462 … 1.0173287701631242 0.9793042434753583;\n 2.0 1.634450182452438 … 2.075029652563485 1.6980752053964283], nothing, no\nthing, nothing, nothing)\n DiffEqParamEstim.L2Loss{StepRangeLen{Float64,Base.TwicePrecision{Float64},\nBase.TwicePrecision{Float64}},Array{Float64,2},Nothing,Nothing,Nothing}(0.0\n:0.1:10.0, [2.0 1.9214830168796073 … 2.279371218479859 2.4310471044470905; \n2.0 1.8019540594630474 … 0.8848252408869255 0.8294783000181652], nothing, n\nothing, nothing, nothing)","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"So losses[i] is a function which computes the loss of a solution against the data of the ith trajectory. So to build our true loss function, we sum the losses:","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\nloss(sim) = sum(losses[i](sim[i]) for i in 1:N)","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"loss (generic function with 1 method)","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"As a double check, make sure that loss(sim) outputs zero (since we generated the data from sim). Now we generate data with other parameters:","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\nprob = ODEProblem(pf_func,[1.0,1.0],(0.0,10.0),[1.2,0.8])\nfunction prob_func(prob,i,repeat)\n  ODEProblem(prob.f,initial_conditions[i],prob.tspan,prob.p)\nend\nmonte_prob = MonteCarloProblem(prob,prob_func=prob_func)\nsim = solve(monte_prob,Tsit5(),num_monte=N,saveat=data_times)\nloss(sim)","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"10108.69418531734","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"and get a non-zero loss. So we now have our problem, our data, and our loss function... we have what we need.","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Put this into buildlossobjective.","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\nobj = build_loss_objective(monte_prob,Tsit5(),loss,num_monte=N,\n                           saveat=data_times)","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"(::DiffEqParamEstim.DiffEqObjective{DiffEqParamEstim.var\"#43#48\"{Nothing,Bo\nol,Int64,typeof(DiffEqParamEstim.STANDARD_PROB_GENERATOR),Base.Iterators.Pa\nirs{Symbol,Any,Tuple{Symbol,Symbol},NamedTuple{(:num_monte, :saveat),Tuple{\nInt64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision\n{Float64}}}}},DiffEqBase.EnsembleProblem{DiffEqBase.ODEProblem{Array{Float6\n4,1},Tuple{Float64,Float64},true,Array{Float64,1},DiffEqBase.ODEFunction{tr\nue,typeof(Main.##WeaveSandBox#293.pf_func),LinearAlgebra.UniformScaling{Boo\nl},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,\nNothing,Nothing,Nothing},Base.Iterators.Pairs{Union{},Union{},Tuple{},Named\nTuple{(),Tuple{}}},DiffEqBase.StandardODEProblem},typeof(Main.##WeaveSandBo\nx#293.prob_func),typeof(DiffEqBase.DEFAULT_OUTPUT_FUNC),typeof(DiffEqBase.D\nEFAULT_REDUCTION),Nothing},OrdinaryDiffEq.Tsit5,typeof(Main.##WeaveSandBox#\n293.loss),Nothing,Tuple{}},DiffEqParamEstim.var\"#47#53\"{DiffEqParamEstim.va\nr\"#43#48\"{Nothing,Bool,Int64,typeof(DiffEqParamEstim.STANDARD_PROB_GENERATO\nR),Base.Iterators.Pairs{Symbol,Any,Tuple{Symbol,Symbol},NamedTuple{(:num_mo\nnte, :saveat),Tuple{Int64,StepRangeLen{Float64,Base.TwicePrecision{Float64}\n,Base.TwicePrecision{Float64}}}}},DiffEqBase.EnsembleProblem{DiffEqBase.ODE\nProblem{Array{Float64,1},Tuple{Float64,Float64},true,Array{Float64,1},DiffE\nqBase.ODEFunction{true,typeof(Main.##WeaveSandBox#293.pf_func),LinearAlgebr\na.UniformScaling{Bool},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Noth\ning,Nothing,Nothing,Nothing,Nothing,Nothing},Base.Iterators.Pairs{Union{},U\nnion{},Tuple{},NamedTuple{(),Tuple{}}},DiffEqBase.StandardODEProblem},typeo\nf(Main.##WeaveSandBox#293.prob_func),typeof(DiffEqBase.DEFAULT_OUTPUT_FUNC)\n,typeof(DiffEqBase.DEFAULT_REDUCTION),Nothing},OrdinaryDiffEq.Tsit5,typeof(\nMain.##WeaveSandBox#293.loss),Nothing,Tuple{}}}}) (generic function with 2 \nmethods)","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Notice that I added the kwargs for solve into this. They get passed to an internal solve command, so then the loss is computed on N trajectories at data_times.","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Thus we take this objective function over to any optimization package. I like to do quick things in Optim.jl. Here, since the Lotka-Volterra equation requires positive parameters, I use Fminbox to make sure the parameters stay positive. I start the optimization with [1.3,0.9], and Optim spits out that the true parameters are:","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\nlower = zeros(2)\nupper = fill(2.0,2)\nresult = optimize(obj, lower, upper, [1.3,0.9], Fminbox(BFGS()))","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"* Status: success\n\n * Candidate solution\n    Final objective value:     3.530023e-13\n\n * Found with\n    Algorithm:     Fminbox with BFGS\n\n * Convergence measures\n    |x - x'|               = 0.00e+00 ≤ 0.0e+00\n    |x - x'|/|x'|          = 0.00e+00 ≤ 0.0e+00\n    |f(x) - f(x')|         = 0.00e+00 ≤ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 0.00e+00 ≤ 0.0e+00\n    |g(x)|                 = 1.09e-05 ≰ 1.0e-08\n\n * Work counters\n    Seconds run:   61  (vs limit Inf)\n    Iterations:    9\n    f(x) calls:    46080\n    ∇f(x) calls:   46080","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\nresult","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"* Status: success\n\n * Candidate solution\n    Final objective value:     3.530023e-13\n\n * Found with\n    Algorithm:     Fminbox with BFGS\n\n * Convergence measures\n    |x - x'|               = 0.00e+00 ≤ 0.0e+00\n    |x - x'|/|x'|          = 0.00e+00 ≤ 0.0e+00\n    |f(x) - f(x')|         = 0.00e+00 ≤ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 0.00e+00 ≤ 0.0e+00\n    |g(x)|                 = 1.09e-05 ≰ 1.0e-08\n\n * Work counters\n    Seconds run:   61  (vs limit Inf)\n    Iterations:    9\n    f(x) calls:    46080\n    ∇f(x) calls:   46080","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Optim finds one but not the other parameter.","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"I would run a test on synthetic data for your problem before using it on real data. Maybe play around with different optimization packages, or add regularization. You may also want to decrease the tolerance of the ODE solvers via","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\nobj = build_loss_objective(monte_prob,Tsit5(),loss,num_monte=N,\n                           abstol=1e-8,reltol=1e-8,\n                           saveat=data_times)\nresult = optimize(obj, lower, upper, [1.3,0.9], Fminbox(BFGS()))","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"* Status: success\n\n * Candidate solution\n    Final objective value:     4.155346e-02\n\n * Found with\n    Algorithm:     Fminbox with BFGS\n\n * Convergence measures\n    |x - x'|               = 3.84e-14 ≰ 0.0e+00\n    |x - x'|/|x'|          = 2.13e-14 ≰ 0.0e+00\n    |f(x) - f(x')|         = 0.00e+00 ≤ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 0.00e+00 ≤ 0.0e+00\n    |g(x)|                 = 2.92e-09 ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   1  (vs limit Inf)\n    Iterations:    5\n    f(x) calls:    46\n    ∇f(x) calls:   46","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\nresult","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"* Status: success\n\n * Candidate solution\n    Final objective value:     4.155346e-02\n\n * Found with\n    Algorithm:     Fminbox with BFGS\n\n * Convergence measures\n    |x - x'|               = 3.84e-14 ≰ 0.0e+00\n    |x - x'|/|x'|          = 2.13e-14 ≰ 0.0e+00\n    |f(x) - f(x')|         = 0.00e+00 ≤ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 0.00e+00 ≤ 0.0e+00\n    |g(x)|                 = 2.92e-09 ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   1  (vs limit Inf)\n    Iterations:    5\n    f(x) calls:    46\n    ∇f(x) calls:   46","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"if you suspect error is the problem. However, if you're having problems it's most likely not the ODE solver tolerance and mostly because parameter inference is a very hard optimization problem.","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/#Appendix","page":"Monte Carlo Parameter Estimation From Data","title":"Appendix","text":"","category":"section"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"This tutorial is part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl.  For more information on doing scientific machine learning (SciML) with open source software, check out https://sciml.ai/.","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"model_inference\",\"02-monte_carlo_parameter_estim.jmd\")","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Computer Information:","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Julia Version 1.4.2\nCommit 44fa15b150* (2020-05-23 18:35 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Core(TM) i7-9700K CPU @ 3.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-8.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_LOAD_PATH = /builds/JuliaGPU/DiffEqTutorials.jl:\n  JULIA_DEPOT_PATH = /builds/JuliaGPU/DiffEqTutorials.jl/.julia\n  JULIA_CUDA_MEMORY_LIMIT = 2147483648\n  JULIA_NUM_THREADS = 8\n","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Package Information:","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Status `/builds/JuliaGPU/DiffEqTutorials.jl/tutorials/model_inference/Project.toml`\n[6e4b80f9-dd63-53aa-95a3-0cdb28fa8baf] BenchmarkTools 0.5.0\n[593b3428-ca2f-500c-ae53-031589ec8ddd] CmdStan 6.0.8\n[ebbdde9d-f333-5424-9be2-dbf1e9acfb5e] DiffEqBayes 2.17.0\n[1130ab10-4a5a-5621-a13d-e4788d82bd4c] DiffEqParamEstim 1.17.0\n[0c46a032-eb83-5123-abaf-570d42b7fbaa] DifferentialEquations 6.15.0\n[31c24e10-a181-5473-b8eb-7969acd0382f] Distributions 0.23.12\n[bbc10e6e-7c05-544b-b16e-64fede858acb] DynamicHMC 2.2.0\n[429524aa-4258-5aef-a3af-852621145aeb] Optim 1.2.0\n[1dea7af3-3e70-54e6-95c3-0bf5283fa5ed] OrdinaryDiffEq 5.42.8\n[91a5bcdd-55d7-5caf-9e0b-520d859cae80] Plots 1.6.5\n[731186ca-8d62-57ce-b412-fbd966d074cd] RecursiveArrayTools 2.7.0\n[f3b207a7-027a-5e70-b257-86293d7955fd] StatsPlots 0.14.13\n[84d833dd-6860-57f9-a1a7-6da5db126cff] TransformVariables 0.3.10","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/#DiffEqBiological-Tutorial-II:-Network-Properties-API","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"","category":"section"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"The DiffEqBiological API provides a collection of functions for easily accessing network properties, and for incrementally building and extending a network. In this tutorial we'll go through the API, and then illustrate how to programmatically construct a network.","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"We'll illustrate the API using a toggle-switch like network that contains a variety of different reaction types:","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"using DifferentialEquations, DiffEqBiological, Latexify, Plots\nfmt = :svg\npyplot(fmt=fmt)\nrn = @reaction_network begin\n    hillr(D₂,α,K,n), ∅ --> m₁\n    hillr(D₁,α,K,n), ∅ --> m₂\n    (δ,γ), m₁ ↔ ∅\n    (δ,γ), m₂ ↔ ∅\n    β, m₁ --> m₁ + P₁\n    β, m₂ --> m₂ + P₂\n    μ, P₁ --> ∅\n    μ, P₂ --> ∅\n    (k₊,k₋), 2P₁ ↔ D₁\n    (k₊,k₋), 2P₂ ↔ D₂\n    (k₊,k₋), P₁+P₂ ↔ T\nend α K n δ γ β μ k₊ k₋;","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: ArgumentError: Package DiffEqBiological not found in current path:\n- Run `import Pkg; Pkg.add(\"DiffEqBiological\")` to install the DiffEqBiolog\nical package.","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"This corresponds to the chemical reaction network given by","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"latexify(rn; env=:chemical)","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: latexify not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/#Network-Properties","page":"DiffEqBiological Tutorial II: Network Properties API","title":"Network Properties","text":"","category":"section"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Basic properties of the generated network include the speciesmap and paramsmap functions we examined in the last tutorial, along with the corresponding species and params functions:","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"species(rn)","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: species not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"params(rn)","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: params not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"The numbers of species, parameters and reactions can be accessed using numspecies(rn), numparams(rn) and numreactions(rn).","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"A number of functions are available to access properties of reactions within the generated network, including substrates, products, dependents, ismassaction, substratestoich, substratesymstoich, productstoich, productsymstoich, and netstoich. Each of these functions takes two arguments, the reaction network rn and the index of the reaction to query information about. For example, to find the substrate symbols and their corresponding stoichiometries for the 11th reaction, 2P₁ --> D₁, we would use","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"substratesymstoich(rn, 11)","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: substratesymstoich not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Broadcasting works on all these functions, allowing the construction of a vector holding the queried information across all reactions, i.e.","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"substratesymstoich.(rn, 1:numreactions(rn))","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: numreactions not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"To see the net stoichiometries for all reactions we would use","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"netstoich.(rn, 1:numreactions(rn))","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: numreactions not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Here the first integer in each pair corresponds to the index of the species (with symbol species(rn)[index]). The second integer corresponds to the net stoichiometric coefficient of the species within the reaction. substratestoich and productstoich are defined similarly.","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Several functions are also provided that calculate different types of dependency graphs. These include rxtospecies_depgraph, which provides a mapping from reaction index to the indices of species whose population changes when the reaction occurs:","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"rxtospecies_depgraph(rn)","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: rxtospecies_depgraph not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Here the last row indicates that the species with indices [3,4,7] will change values when the reaction T --> P₁ + P₂ occurs. To confirm these are the correct species we can look at","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"species(rn)[[3,4,7]]","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: species not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"The speciestorx_depgraph similarly provides a mapping from species to reactions for which their rate laws depend on that species. These correspond to all reactions for which the given species is in the dependent set of the reaction. We can verify this for the first species, m₁:","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"speciestorx_depgraph(rn)[1]","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: speciestorx_depgraph not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"findall(depset -> in(:m₁, depset), dependents.(rn, 1:numreactions(rn)))","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: numreactions not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Finally, rxtorx_depgraph provides a mapping that shows when a given reaction occurs, which other reactions have rate laws that involve species whose value would have changed:","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"rxtorx_depgraph(rn)","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: rxtorx_depgraph not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/#Note-on-Using-Network-Property-API-Functions","page":"DiffEqBiological Tutorial II: Network Properties API","title":"Note on Using Network Property API Functions","text":"","category":"section"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Many basic network query and reaction property functions are simply accessors, returning information that is already stored within the generated reaction_network. For these functions, modifying the returned data structures may lead to inconsistent internal state within the network. As such, they should be used for accessing, but not modifying, network properties. The API documentation indicates which functions return newly allocated data structures and which return data stored within the reaction_network.","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/#Incremental-Construction-of-Networks","page":"DiffEqBiological Tutorial II: Network Properties API","title":"Incremental Construction of Networks","text":"","category":"section"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"The @reaction_network macro is monolithic, in that it not only constructs and stores basic network properties such as the reaction stoichiometries, but also generates everything needed to immediately solve ODE, SDE and jump models using the network. This includes Jacobian functions, noise functions, and jump functions for each reaction. While this allows for a compact interface to the DifferentialEquations.jl solvers, it can also be computationally expensive for large networks, where a user may only wish to solve one type of problem and/or have fine-grained control over what is generated. In addition, some types of reaction network structures are more amenable to being constructed programmatically, as opposed to writing out all reactions by hand within one macro. For these reasons DiffEqBiological provides two additional macros that only initially setup basic reaction network properties, and which can be extended through a programmatic interface: @min_reaction_network and @empty_reaction_network. We now give an introduction to constructing these more minimal network representations, and how they can be programmatically extended. See also the relevant API section.","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"The @min_reaction_network macro works identically to the @reaction_network macro, but the generated network will only be complete with respect to its representation of chemical network properties (i.e. species, parameters and reactions). No ODE, SDE or jump models are generated during the macro call. It can subsequently be extended with the addition of new species, parameters or reactions. The @empty_reaction_network allocates an empty network structure that can also be extended using the programmatic interface. For example, consider a partial version of the toggle-switch like network we defined above:","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"rnmin = @min_reaction_network begin\n    (δ,γ), m₁ ↔ ∅\n    (δ,γ), m₂ ↔ ∅\n    β, m₁ --> m₁ + P₁\n    β, m₂ --> m₂ + P₂\n    μ, P₁ --> ∅\n    μ, P₂ --> ∅\nend δ γ β μ;","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: LoadError: UndefVarError: @min_reaction_network not defined\nin expression starting at /var/lib/buildkite-agent/builds/1-amdci4-julia-cs\nail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/models/04-diffeqbio_I\nI_networkproperties.jmd:2","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Here we have left out the first two, and last three, reactions from the original reaction_network. To expand the network until it is functionally equivalent to the original model we add back in the missing species, parameters, and finally the missing reactions. Note, it is required that species and parameters be defined before any reactions using them are added. The necessary network extension functions are given by addspecies!, addparam! and addreaction!, and described in the API. To complete rnmin we first add the relevant species:","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"addspecies!(rnmin, :D₁)\naddspecies!(rnmin, :D₂)\naddspecies!(rnmin, :T)","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: addspecies! not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Next we add the needed parameters","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"addparam!(rnmin, :α)\naddparam!(rnmin, :K)\naddparam!(rnmin, :n)\naddparam!(rnmin, :k₊)\naddparam!(rnmin, :k₋)","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: addparam! not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Note, both addspecies! and addparam! also accept strings encoding the variable names (which are then converted to Symbols internally).","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"We are now ready to add the missing reactions. The API provides two forms of the addreaction! function, one takes expressions analogous to what one would write in the macro:","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"addreaction!(rnmin, :(hillr(D₁,α,K,n)), :(∅ --> m₂))\naddreaction!(rnmin, :((k₊,k₋)), :(2P₂ ↔ D₂))\naddreaction!(rnmin, :k₊, :(2P₁ --> D₁))\naddreaction!(rnmin, :k₋, :(D₁ --> 2P₁))","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: addreaction! not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"The rate can be an expression or symbol as above, but can also just be a numeric value. The second form of addreaction! takes tuples of Pair{Symbol,Int} that encode the stoichiometric coefficients of substrates and reactants:","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"# signature is addreaction!(rnmin, paramexpr, substratestoich, productstoich)\naddreaction!(rnmin, :(hillr(D₂,α,K,n)), (), (:m₁ => 1,))\naddreaction!(rnmin, :k₊, (:P₁=>1, :P₂=>1), (:T=>1,))\naddreaction!(rnmin, :k₋, (:T=>1,), (:P₁=>1, :P₂=>1))","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: addreaction! not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Let's check that rn and rnmin have the same set of species:","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"setdiff(species(rn), species(rnmin))","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: species not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"the same set of params:","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"setdiff(params(rn), params(rnmin))","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: params not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"and the final reaction has the same substrates, reactions, and rate expression:","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"rxidx = numreactions(rn)\nsetdiff(substrates(rn, rxidx), substrates(rnmin, rxidx))","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: numreactions not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"setdiff(products(rn, rxidx), products(rnmin, rxidx))","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: products not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"rateexpr(rn, rxidx) == rateexpr(rnmin, rxidx)","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: rateexpr not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/#Extending-Incrementally-Generated-Networks-to-Include-ODEs,-SDEs-or-Jumps","page":"DiffEqBiological Tutorial II: Network Properties API","title":"Extending Incrementally Generated Networks to Include ODEs, SDEs or Jumps","text":"","category":"section"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Once a network generated from @min_reaction_network or @empty_reaction_network has had all the associated species, parameters and reactions filled in, corresponding ODE, SDE or jump models can be constructed. The relevant API functions are addodes!, addsdes! and addjumps!. One benefit to contructing models with these functions is that they offer more fine-grained control over what actually gets constructed. For example, addodes! has the optional keyword argument, build_jac, which if set to false will disable construction of symbolic Jacobians and functions for evaluating Jacobians. For large networks this can give a significant speed-up in the time required for constructing an ODE model. Each function and its associated keyword arguments are described in the API section, Functions to add ODEs, SDEs or Jumps to a Network.","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Let's extend rnmin to include the needed functions for use in ODE solvers:","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"addodes!(rnmin)","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: addodes! not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"The Generated Functions for Models section of the API shows what functions have been generated. For ODEs these include oderhsfun(rnmin), which returns a function of the form f(du,u,p,t) which evaluates the ODEs (i.e. the time derivatives of u) within du. For each generated function, the corresponding expressions from which it was generated can be retrieved using accessors from the Generated Expressions section of the API. The equations within du can be retrieved using the odeexprs(rnmin) function. For example:","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"odeexprs(rnmin)","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: odeexprs not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Using Latexify we can see the ODEs themselves to compare with these expressions:","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"latexify(rnmin)","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: latexify not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"For ODEs two other functions are generated by addodes!. jacfun(rnmin) will return the generated Jacobian evaluation function, fjac(dJ,u,p,t), which given the current solution u evaluates the Jacobian within dJ. jacobianexprs(rnmin) gives the corresponding matrix of expressions, which can be used with Latexify to see the Jacobian:","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"latexify(jacobianexprs(rnmin))","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: jacobianexprs not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"addodes! also generates a function that evaluates the Jacobian of the ODE derivative functions with respect to the parameters. paramjacfun(rnmin) then returns the generated function. It has the form fpjac(dPJ,u,p,t), which given the current solution u evaluates the Jacobian matrix with respect to parameters p within dPJ. For use in DifferentialEquations.jl solvers, an ODEFunction representation of the ODEs is available from odefun(rnmin).","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"addsdes! and addjumps! work similarly to complete the network for use in StochasticDiffEq and DiffEqJump solvers.","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/#Note-on-Using-Generated-Function-and-Expression-API-Functions","page":"DiffEqBiological Tutorial II: Network Properties API","title":"Note on Using Generated Function and Expression API Functions","text":"","category":"section"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"The generated functions and expressions accessible through the API require first calling the appropriate addodes!, addsdes or addjumps function. These are responsible for actually constructing the underlying functions and expressions. The API accessors simply return already constructed functions and expressions that are stored within the reaction_network structure.","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/#Example-of-Generating-a-Network-Programmatically","page":"DiffEqBiological Tutorial II: Network Properties API","title":"Example of Generating a Network Programmatically","text":"","category":"section"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"For a user directly typing in a reaction network, it is generally easier to use the @min_reaction_network or @reaction_network macros to fully specify reactions. However, for large, structured networks it can be much easier to generate the network programmatically. For very large networks, with tens of thousands of reactions, the form of addreaction! that uses stoichiometric coefficients should be preferred as it offers substantially better performance. To put together everything we've seen, let's generate the network corresponding to a 1D continuous time random walk, approximating the diffusion of molecules within an interval.","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"The basic \"reaction\" network we wish to study is","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"$","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"u1 \\leftrightarrows u2 \\leftrightarrows u3 \\cdots \\leftrightarrows u{N} $","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"for N lattice sites on 01. For h = 1N the lattice spacing, we'll assume the rate molecules hop from their current site to any particular neighbor is just h^-2. We can interpret this hopping process as a collection of 2N-2 \"reactions\", with the form u_i to u_j for j=i+1 or j=i-1. We construct the corresponding reaction network as follows. First we set values for the basic parameters:","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"N = 64\nh = 1 / N","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"0.015625","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"then we create an empty network, and add each species","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"rn = @empty_reaction_network\n\nfor i = 1:N\n    addspecies!(rn, Symbol(:u, i))\nend","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: LoadError: UndefVarError: @empty_reaction_network not defined\nin expression starting at /var/lib/buildkite-agent/builds/1-amdci4-julia-cs\nail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/models/04-diffeqbio_I\nI_networkproperties.jmd:2","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"We next add one parameter β, which we will set equal to the hopping rate of molecules, h^-2:","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"addparam!(rn, :β)","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: addparam! not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Finally, we add in the 2N-2 possible hopping reactions:","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"for i = 1:N\n    (i < N) && addreaction!(rn, :β, (Symbol(:u,i)=>1,), (Symbol(:u,i+1)=>1,))\n    (i > 1) && addreaction!(rn, :β, (Symbol(:u,i)=>1,), (Symbol(:u,i-1)=>1,))\nend","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: addreaction! not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Let's first construct an ODE model for the network","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"addodes!(rn)","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: addodes! not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"We now need to specify the initial condition, parameter vector and time interval to solve on. We start with 10000 molecules placed at the center of the domain, and setup an ODEProblem to solve:","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"u₀ = zeros(N)\nu₀[div(N,2)] = 10000\np = [1/(h*h)]\ntspan = (0.,.01)\noprob = ODEProblem(rn, u₀, tspan, p)","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: rn not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"We are now ready to solve the problem and plot the solution. Since we have essentially generated a method of lines discretization of the diffusion equation with a discontinuous initial condition, we'll use an A-L stable implicit ODE solver, Rodas5, and plot the solution at a few times:","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"sol = solve(oprob, Rodas5())\ntimes = [0., .0001, .001, .01]\nplt = plot()\nfor time in times\n    plot!(plt, 1:N, sol(time), fmt=fmt, xlabel=\"i\", ylabel=\"uᵢ\", label=string(\"t = \", time), lw=3)\nend\nplot(plt, ylims=(0.,10000.))","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: oprob not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Here we see the characteristic diffusion of molecules from the center of the domain, resulting in a shortening and widening of the solution as t increases.","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Let's now look at a stochastic chemical kinetics jump process version of the model, where β gives the probability per time each molecule can hop from its current lattice site to an individual neighboring site. We first add in the jumps, disabling regular_jumps since they are not needed, and using the minimal_jumps flag to construct a minimal representation of the needed jumps. We then construct a JumpProblem, and use the Composition-Rejection Direct method, DirectCR, to simulate the process of the molecules hopping about on the lattice:","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"addjumps!(rn, build_regular_jumps=false, minimal_jumps=true)\n\n# make the initial condition integer valued\nu₀ = zeros(Int, N)\nu₀[div(N,2)] = 10000\n\n# setup and solve the problem\ndprob = DiscreteProblem(rn, u₀, tspan, p)\njprob = JumpProblem(dprob, DirectCR(), rn, save_positions=(false,false))\njsol = solve(jprob, SSAStepper(), saveat=times)","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: addjumps! not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"We can now plot bar graphs showing the locations of the molecules at the same set of times we examined the ODE solution. For comparison, we also plot the corresponding ODE solutions (red lines) that we found:","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"times = [0., .0001, .001, .01]\nplts = []\nfor i = 1:4\n    b = bar(1:N, jsol[i], legend=false, fmt=fmt, xlabel=\"i\", ylabel=\"uᵢ\", title=string(\"t = \", times[i]))\n    plot!(b,sol(times[i]))\n    push!(plts,b)\nend\nplot(plts...)","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: UndefVarError: jsol not defined","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Similar to the ODE solutions, we see that the molecules spread out and become more and more well-mixed throughout the domain as t increases. The simulation results are noisy due to the finite numbers of molecules present in the stochsatic simulation, but since the number of molecules is large they agree well with the ODE solution at each time.","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/#Getting-Help","page":"DiffEqBiological Tutorial II: Network Properties API","title":"Getting Help","text":"","category":"section"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Have a question related to DiffEqBiological or this tutorial? Feel free to ask in the DifferentialEquations.jl Gitter. If you think you've found a bug in DiffEqBiological, or would like to request/discuss new functionality, feel free to open an issue on Github (but please check there is no related issue already open). If you've found a bug in this tutorial, or have a suggestion, feel free to open an issue on the SciMLTutorials Github site. Or, submit a pull request to SciMLTutorials updating the tutorial!","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"","category":"page"},{"location":"models/04-diffeqbio_II_networkproperties/","page":"DiffEqBiological Tutorial II: Network Properties API","title":"DiffEqBiological Tutorial II: Network Properties API","text":"Error: MethodError: no method matching tutorial_footer(::String, ::String; \nremove_homedir=true)\nClosest candidates are:\n  tutorial_footer(::Any, ::Any) at /var/lib/buildkite-agent/builds/1-amdci4\n-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/src/SciMLTutorials.jl:\n79 got unsupported keyword argument \"remove_homedir\"\n  tutorial_footer(::Any) at /var/lib/buildkite-agent/builds/1-amdci4-julia-\ncsail-mit-edu/julialang/scimltutorials-dot-jl/src/SciMLTutorials.jl:79 got \nunsupported keyword argument \"remove_homedir\"","category":"page"},{"location":"models/02-conditional_dosing/#Conditional-Dosing-Pharmacometric-Example","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"","category":"section"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"In this example we will show how to model a conditional dosing using the DiscreteCallbacks. The problem is as follows. The patient has a drug A(t) in their system. The concentration of the drug is given as C(t)=A(t)/V for some volume constant V. At t=4, the patient goes to the clinic and is checked. If the concentration of the drug in their body is below 4, then they will receive a new dose.","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"For our model, we will use the simple decay equation. We will write this in the in-place form to make it easy to extend to more complicated examples:","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"using DifferentialEquations\nfunction f(du,u,p,t)\n    du[1] = -u[1]\nend\nu0 = [10.0]\nconst V = 1\nprob = ODEProblem(f,u0,(0.0,10.0))","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"ODEProblem with uType Vector{Float64} and tType Float64. In-place: true\ntimespan: (0.0, 10.0)\nu0: 1-element Vector{Float64}:\n 10.0","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"Let's see what the solution looks like without any events.","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"sol = solve(prob,Tsit5())\nusing Plots; gr()\nplot(sol)","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"(Image: )","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"We see that at time t=4, the patient should receive a dose. Let's code up that event. We need to check at t=4 if the concentration u[1]/4 is <4, and if so, add 10 to u[1]. We do this with the following:","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"condition(u,t,integrator) = t==4 && u[1]/V<4\naffect!(integrator) = integrator.u[1] += 10\ncb = DiscreteCallback(condition,affect!)","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"DiffEqBase.DiscreteCallback{typeof(Main.##WeaveSandBox#5561.condition), typ\neof(Main.##WeaveSandBox#5561.affect!), typeof(DiffEqBase.INITIALIZE_DEFAULT\n), typeof(DiffEqBase.FINALIZE_DEFAULT)}(Main.##WeaveSandBox#5561.condition,\n Main.##WeaveSandBox#5561.affect!, DiffEqBase.INITIALIZE_DEFAULT, DiffEqBas\ne.FINALIZE_DEFAULT, Bool[1, 1])","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"Now we will give this callback to the solver, and tell it to stop at t=4 so that way the condition can be checked:","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"sol = solve(prob,Tsit5(),tstops=[4.0],callback=cb)\nusing Plots; gr()\nplot(sol)","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"(Image: )","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"Let's show that it actually added 10 instead of setting the value to 10. We could have set the value using affect!(integrator) = integrator.u[1] = 10","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"println(sol(4.00000))\nprintln(sol(4.000000000001))","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"[0.18316389222022983]\n[10.183163892210045]","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"Now let's model a patient whose decay rate for the drug is lower:","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"function f(du,u,p,t)\n    du[1] = -u[1]/6\nend\nu0 = [10.0]\nconst V = 1\nprob = ODEProblem(f,u0,(0.0,10.0))","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"ODEProblem with uType Vector{Float64} and tType Float64. In-place: true\ntimespan: (0.0, 10.0)\nu0: 1-element Vector{Float64}:\n 10.0","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"sol = solve(prob,Tsit5())\nusing Plots; gr()\nplot(sol)","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"(Image: )","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"Under the same criteria, with the same event, this patient will not receive a second dose:","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"sol = solve(prob,Tsit5(),tstops=[4.0],callback=cb)\nusing Plots; gr()\nplot(sol)","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"(Image: )","category":"page"},{"location":"models/02-conditional_dosing/#Appendix","page":"Conditional Dosing Pharmacometric Example","title":"Appendix","text":"","category":"section"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"tutorials/models\",\"02-conditional_dosing.jmd\")","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"Computer Information:","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"Julia Version 1.6.2\nCommit 1b93d53fc4 (2021-07-14 15:36 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, znver2)\nEnvironment:\n  JULIA_DEPOT_PATH = /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n  JULIA_NUM_THREADS = 16\n","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"Package Information:","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"      Status `/var/lib/buildkite-agent/builds/1-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/models/Project.toml`\n  [479239e8] Catalyst v6.12.1\n  [459566f4] DiffEqCallbacks v2.16.1\n  [f3b72e0c] DiffEqDevTools v2.27.2\n  [055956cb] DiffEqPhysics v3.9.0\n  [0c46a032] DifferentialEquations v6.17.1\n  [31c24e10] Distributions v0.24.18\n  [587475ba] Flux v0.12.1\n  [f6369f11] ForwardDiff v0.10.18\n  [23fbe1c1] Latexify v0.15.5\n  [961ee093] ModelingToolkit v5.17.3\n  [2774e3e8] NLsolve v4.5.1\n  [315f7962] NeuralPDE v3.10.1\n  [429524aa] Optim v1.3.0\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [91a5bcdd] Plots v1.15.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [789caeaf] StochasticDiffEq v6.34.1\n  [37e2e46d] LinearAlgebra\n  [2f01184e] SparseArrays","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"And the full manifest:","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"      Status `/var/lib/buildkite-agent/builds/1-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/models/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.16.0\n  [621f4979] AbstractFFTs v1.0.1\n  [1520ce14] AbstractTrees v0.3.4\n  [79e6a3ab] Adapt v3.3.0\n  [ec485272] ArnoldiMethod v0.1.0\n  [4fba245c] ArrayInterface v3.1.15\n  [4c555306] ArrayLayouts v0.7.0\n  [13072b0f] AxisAlgorithms v1.0.0\n  [ab4f0b2a] BFloat16s v0.1.0\n  [aae01518] BandedMatrices v0.16.9\n  [764a87c0] BoundaryValueDiffEq v2.7.1\n  [fa961155] CEnum v0.4.1\n  [00ebfdb7] CSTParser v2.5.0\n  [052768ef] CUDA v2.6.3\n  [479239e8] Catalyst v6.12.1\n  [082447d4] ChainRules v0.7.65\n  [d360d2e6] ChainRulesCore v0.9.44\n  [b630d9fa] CheapThreads v0.2.5\n  [944b1d66] CodecZlib v0.7.0\n  [35d6a980] ColorSchemes v3.12.1\n  [3da002f7] ColorTypes v0.11.0\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [a80b9123] CommonMark v0.8.1\n  [38540f10] CommonSolve v0.2.0\n  [bbf7d656] CommonSubexpressions v0.3.0\n  [34da2185] Compat v3.30.0\n  [8f4d0f93] Conda v1.5.2\n  [88cd18e8] ConsoleProgressMonitor v0.1.2\n  [187b0558] ConstructionBase v1.2.1\n  [d38c429a] Contour v0.5.7\n  [a8cc5b0e] Crayons v4.0.4\n  [8a292aeb] Cuba v2.2.0\n  [667455a9] Cubature v1.5.1\n  [9a962f9c] DataAPI v1.6.0\n  [82cc6244] DataInterpolations v3.3.1\n  [864edb3b] DataStructures v0.18.9\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [bcd4f6db] DelayDiffEq v5.31.0\n  [2b5f629d] DiffEqBase v6.62.2\n  [459566f4] DiffEqCallbacks v2.16.1\n  [f3b72e0c] DiffEqDevTools v2.27.2\n  [5a0ffddc] DiffEqFinancial v2.4.0\n  [aae7a2af] DiffEqFlux v1.37.0\n  [c894b116] DiffEqJump v6.14.2\n  [77a26b50] DiffEqNoiseProcess v5.7.3\n  [055956cb] DiffEqPhysics v3.9.0\n  [41bf760c] DiffEqSensitivity v6.45.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.0.2\n  [0c46a032] DifferentialEquations v6.17.1\n  [c619ae07] DimensionalPlotRecipes v1.2.0\n  [b4f34e82] Distances v0.10.3\n  [31c24e10] Distributions v0.24.18\n  [ced4e74d] DistributionsAD v0.6.26\n  [ffbed154] DocStringExtensions v0.8.4\n  [e30172f5] Documenter v0.26.3\n  [d4d017d3] ExponentialUtilities v1.8.4\n  [e2ba6199] ExprTools v0.1.3\n  [c87230d0] FFMPEG v0.4.0\n  [7a1cc6ca] FFTW v1.4.1\n  [7034ab61] FastBroadcast v0.1.8\n  [9aa1b823] FastClosures v0.3.2\n  [1a297f60] FillArrays v0.11.7\n  [6a86dc24] FiniteDiff v2.8.0\n  [53c48c17] FixedPointNumbers v0.8.4\n  [587475ba] Flux v0.12.1\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.18\n  [069b7b12] FunctionWrappers v1.1.2\n  [d9f16b24] Functors v0.2.1\n  [0c68f7d7] GPUArrays v6.4.1\n  [61eb1bfa] GPUCompiler v0.10.0\n  [28b8d3ca] GR v0.57.4\n  [a75be94c] GalacticOptim v1.2.0\n  [5c1252a2] GeometryBasics v0.3.12\n  [af5da776] GlobalSensitivity v1.0.0\n  [42e2da0e] Grisu v1.0.2\n  [19dc6840] HCubature v1.5.0\n  [cd3eb016] HTTP v0.9.9\n  [eafb193a] Highlights v0.4.5\n  [0e44f5e4] Hwloc v2.0.0\n  [7073ff75] IJulia v1.23.2\n  [b5f81e59] IOCapture v0.1.1\n  [7869d1d1] IRTools v0.4.2\n  [615f187c] IfElse v0.1.0\n  [d25df0c9] Inflate v0.1.2\n  [83e8ac13] IniFile v0.5.0\n  [a98d9a8b] Interpolations v0.13.2\n  [c8e1da08] IterTools v1.3.0\n  [42fd0dbc] IterativeSolvers v0.9.1\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.3.0\n  [682c06a0] JSON v0.21.1\n  [98e50ef6] JuliaFormatter v0.13.7\n  [e5e0dc1b] Juno v0.8.4\n  [5ab0869b] KernelDensity v0.6.3\n  [929cbde3] LLVM v3.7.1\n  [b964fa9f] LaTeXStrings v1.2.1\n  [2ee39098] LabelledArrays v1.6.1\n  [23fbe1c1] Latexify v0.15.5\n  [a5e1c1ea] LatinHypercubeSampling v1.8.0\n  [73f95e8e] LatticeRules v0.0.1\n  [1d6d02ad] LeftChildRightSiblingTrees v0.1.2\n  [093fc24a] LightGraphs v1.3.5\n  [d3d80556] LineSearches v7.1.1\n  [2ab3a3ac] LogExpFunctions v0.2.4\n  [e6f89c97] LoggingExtras v0.4.6\n  [bdcacae8] LoopVectorization v0.12.23\n  [1914dd2f] MacroTools v0.5.6\n  [739be429] MbedTLS v1.0.3\n  [442fdcdd] Measures v0.3.1\n  [e89f7d12] Media v0.5.0\n  [c03570c3] Memoize v0.4.4\n  [e1d29d7a] Missings v1.0.0\n  [961ee093] ModelingToolkit v5.17.3\n  [4886b29c] MonteCarloIntegration v0.0.2\n  [46d2c3a1] MuladdMacro v0.2.2\n  [f9640e96] MultiScaleArrays v1.8.1\n  [ffc61752] Mustache v1.0.10\n  [d41bc354] NLSolversBase v7.8.0\n  [2774e3e8] NLsolve v4.5.1\n  [872c559c] NNlib v0.7.19\n  [77ba4419] NaNMath v0.3.5\n  [315f7962] NeuralPDE v3.10.1\n  [8913a72c] NonlinearSolve v0.3.8\n  [6fe1bfb0] OffsetArrays v1.9.0\n  [429524aa] Optim v1.3.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [90014a1f] PDMats v0.11.0\n  [65888b18] ParameterizedFunctions v5.10.0\n  [d96e819e] Parameters v0.12.2\n  [69de0a69] Parsers v1.1.0\n  [ccf2f8ad] PlotThemes v2.0.1\n  [995b91a9] PlotUtils v1.0.10\n  [91a5bcdd] Plots v1.15.2\n  [e409e4f3] PoissonRandom v0.4.0\n  [f517fe37] Polyester v0.3.1\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [21216c6a] Preferences v1.2.2\n  [33c8b6b6] ProgressLogging v0.1.4\n  [92933f4c] ProgressMeter v1.6.2\n  [1fd47b50] QuadGK v2.4.1\n  [67601950] Quadrature v1.8.1\n  [8a4e6c94] QuasiMonteCarlo v0.2.2\n  [74087812] Random123 v1.3.1\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.4.0\n  [c84ed2f1] Ratios v0.4.0\n  [3cdcf5f2] RecipesBase v1.1.1\n  [01d81517] RecipesPipeline v0.3.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [f2c3362d] RecursiveFactorization v0.1.12\n  [189a3867] Reexport v1.0.0\n  [ae029012] Requires v1.1.3\n  [ae5879a3] ResettableStacks v1.1.0\n  [37e2e3b7] ReverseDiff v1.9.0\n  [79098fc4] Rmath v0.7.0\n  [47965b36] RootedTrees v1.0.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.2\n  [476501e8] SLEEFPirates v0.6.20\n  [1bc83da4] SafeTestsets v0.0.1\n  [0bca4576] SciMLBase v1.13.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [6c6a2e73] Scratch v1.0.3\n  [efcf1570] Setfield v0.7.0\n  [992d4aef] Showoff v1.0.3\n  [699a6c99] SimpleTraits v0.9.3\n  [ed01d8cd] Sobol v1.5.0\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.0\n  [47a9eef4] SparseDiffTools v1.13.2\n  [276daf66] SpecialFunctions v1.4.1\n  [860ef19b] StableRNGs v1.0.0\n  [aedffcd0] Static v0.2.4\n  [90137ffa] StaticArrays v1.2.0\n  [82ae8749] StatsAPI v1.0.0\n  [2913bbd2] StatsBase v0.33.8\n  [4c63d2b9] StatsFuns v0.9.8\n  [9672c7b4] SteadyStateDiffEq v1.6.2\n  [789caeaf] StochasticDiffEq v6.34.1\n  [7792a7ef] StrideArraysCore v0.1.11\n  [09ab397b] StructArrays v0.5.1\n  [c3572dad] Sundials v4.4.3\n  [d1185830] SymbolicUtils v0.11.2\n  [0c5d862f] Symbolics v0.1.25\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.4.2\n  [5d786b92] TerminalLoggers v0.1.3\n  [8290d209] ThreadingUtilities v0.4.4\n  [a759f4b9] TimerOutputs v0.5.9\n  [0796e94c] Tokenize v0.5.16\n  [9f7883ad] Tracker v0.2.16\n  [3bb67fe8] TranscodingStreams v0.9.5\n  [592b5752] Trapz v2.0.2\n  [a2a6695c] TreeViews v0.3.0\n  [5c2747f8] URIs v1.3.0\n  [3a884ed6] UnPack v1.0.2\n  [1986cc42] Unitful v1.7.0\n  [3d5dd08c] VectorizationBase v0.20.11\n  [81def892] VersionParsing v1.2.0\n  [19fa3120] VertexSafeGraphs v0.1.2\n  [44d3d7a6] Weave v0.10.8\n  [efce3f68] WoodburyMatrices v0.5.3\n  [ddb6d928] YAML v0.4.6\n  [c2297ded] ZMQ v1.2.1\n  [a5390f91] ZipFile v0.9.3\n  [e88e6eb3] Zygote v0.6.11\n  [700de1a5] ZygoteRules v0.2.1\n  [6e34b625] Bzip2_jll v1.0.6+5\n  [83423d85] Cairo_jll v1.16.0+6\n  [3bed1096] Cuba_jll v4.2.1+0\n  [7bc98958] Cubature_jll v1.0.4+0\n  [5ae413db] EarCut_jll v2.1.5+1\n  [2e619515] Expat_jll v2.2.10+0\n  [b22a6f82] FFMPEG_jll v4.3.1+4\n  [f5851436] FFTW_jll v3.3.9+7\n  [a3f928ae] Fontconfig_jll v2.13.1+14\n  [d7e528f0] FreeType2_jll v2.10.1+5\n  [559328eb] FriBidi_jll v1.0.5+6\n  [0656b61e] GLFW_jll v3.3.4+0\n  [d2c73de3] GR_jll v0.57.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.1+0\n  [e33a78d0] Hwloc_jll v2.4.1+0\n  [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2\n  [aacddb02] JpegTurbo_jll v2.0.1+3\n  [c1c5ebd0] LAME_jll v3.100.0+3\n  [dd4b983a] LZO_jll v2.10.1+0\n  [dd192d2f] LibVPX_jll v1.9.0+1\n  [e9f186c6] Libffi_jll v3.2.2+0\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+0\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.1.0+2\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [856f044c] MKL_jll v2021.1.1+1\n  [e7412a2a] Ogg_jll v1.3.4+2\n  [458c3c95] OpenSSL_jll v1.1.1+6\n  [efe28fd5] OpenSpecFun_jll v0.5.4+0\n  [91d4177d] Opus_jll v1.3.1+3\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.2+0\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.0+1\n  [a2964d1f] Wayland_jll v1.17.0+4\n  [2381bf8a] Wayland_protocols_jll v1.18.0+4\n  [02c8fc9c] XML2_jll v2.9.12+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.2+6\n  [3161d3a3] Zstd_jll v1.5.0+0\n  [0ac62f75] libass_jll v0.14.0+4\n  [f638f0a6] libfdk_aac_jll v0.1.6+4\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.6+6\n  [1270edf5] x264_jll v2020.7.14+2\n  [dfaa095f] x265_jll v3.0.0+3\n  [d8fb68d0] xkbcommon_jll v0.9.1+5\n  [0dad84c5] ArgTools\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [4af54fe1] LazyArtifacts\n  [b27032c2] LibCURL\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions\n  [44cfe95a] Pkg\n  [de0858da] Printf\n  [9abbd945] Profile\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML\n  [a4e569a6] Tar\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll\n  [deac9b47] LibCURL_jll\n  [29816b5a] LibSSH2_jll\n  [c8ffd9c3] MbedTLS_jll\n  [14a3606d] MozillaCACerts_jll\n  [4536629a] OpenBLAS_jll\n  [bea87d4a] SuiteSparse_jll\n  [83775a58] Zlib_jll\n  [8e850ede] nghttp2_jll\n  [3f19e933] p7zip_jll","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/#DiffEqBiological-Tutorial-III:-Steady-States-and-Bifurcations","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"","category":"section"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Several types of steady state analysis can be performed for networks defined with DiffEqBiological by utilizing homotopy continuation. This allows for finding the steady states and bifurcations within a large class of systems. In this tutorial we'll go through several examples of using this functionality.","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"We start by loading the necessary packages:","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"using DiffEqBiological, Plots\ngr(); default(fmt = :png);","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Error: ArgumentError: Package DiffEqBiological not found in current path:\n- Run `import Pkg; Pkg.add(\"DiffEqBiological\")` to install the DiffEqBiolog\nical package.","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/#Steady-states-and-stability-of-a-biochemical-reaction-network.","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"Steady states and stability of a biochemical reaction network.","text":"","category":"section"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Bistable switches are well known biological motifs, characterised by the presence of two different stable steady states.","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"bistable_switch = @reaction_network begin\n    d,    (X,Y) → ∅\n    hillR(Y,v1,K1,n1), ∅ → X\n    hillR(X,v2,K2,n2), ∅ → Y\nend d v1 K1 n1 v2 K2 n2\nd = 0.01;\nv1 = 1.5; K1 = 30; n1 = 3;\nv2 = 1.; K2 = 30; n2 = 3;\nbistable_switch_p = [d, v1 ,K1, n1, v2, K2, n2];","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Error: LoadError: UndefVarError: @reaction_network not defined\nin expression starting at /var/lib/buildkite-agent/builds/1-amdci4-julia-cs\nail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/models/04b-diffeqbio_\nIII_steadystates.jmd:2","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"The steady states can be found using the steady_states function (which takes a reaction network and a set of parameter values as input). The stability of these steady states can be found using the stability function.","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"ss = steady_states(bistable_switch, bistable_switch_p)","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Error: UndefVarError: steady_states not defined","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"stability(ss,bistable_switch, bistable_switch_p)","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Error: UndefVarError: stability not defined","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Since the equilibration methodology is based on homotopy continuation, it is not able to handle systems with non-integer exponents, or non polynomial reaction rates. Neither of the following two systems will work.","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"This system contains a non-integer exponent:","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"rn1 = @reaction_network begin\n    p, ∅ → X\n    hill(X,v,K,n), X → ∅\nend p v K n\np1 = [1.,2.5,1.5,1.5]\nsteady_states(rn1,p1)","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Error: LoadError: UndefVarError: @reaction_network not defined\nin expression starting at /var/lib/buildkite-agent/builds/1-amdci4-julia-cs\nail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/models/04b-diffeqbio_\nIII_steadystates.jmd:2","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"This system contains a logarithmic reaction rate:","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"rn2 = @reaction_network begin\n    p, ∅ → X\n    log(X), X → ∅\nend p\np2 = [1.]\nsteady_states(rn2,p2)","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Error: LoadError: UndefVarError: @reaction_network not defined\nin expression starting at /var/lib/buildkite-agent/builds/1-amdci4-julia-cs\nail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/models/04b-diffeqbio_\nIII_steadystates.jmd:2","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/#Bifurcation-diagrams-for-biochemical-reaction-networks","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"Bifurcation diagrams for biochemical reaction networks","text":"","category":"section"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Bifurcation diagrams illustrate how the steady states of a system depend on one or more parameters. They can be computed with the bifurcations function. It takes the same arguments as steady_states, with the addition of the parameter one wants to vary, and an interval over which to vary it:","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"bif = bifurcations(bistable_switch, bistable_switch_p, :v1, (.1,5.))\nplot(bif,ylabel=\"[X]\",label=\"\")\nplot!([[],[]],color=[:blue :red],label = [\"Stable\" \"Unstable\"])","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Error: UndefVarError: bifurcations not defined","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"The values for the second variable in the system can also be displayed, by giving that as an additional input to plot (it is the second argument, directly after the bifurcation diagram object):","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"plot(bif,2,ylabel=\"[Y]\")\nplot!([[],[]],color=[:blue :red],label = [\"Stable\" \"Unstable\"])","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Error: UndefVarError: plot not defined","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"The plot function also accepts all other arguments which the Plots.jl plot function accepts.","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"bif = bifurcations(bistable_switch, bistable_switch_p,:v1,(.1,10.))\nplot(bif,linewidth=1.,title=\"A bifurcation diagram\",ylabel=\"Steady State concentration\")\nplot!([[],[]],color=[:blue :red],label = [\"Stable\" \"Unstable\"])","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Error: UndefVarError: bifurcations not defined","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Certain parameters, like n1, cannot be sensibly varied over a continuous interval. Instead, a discrete bifurcation diagram can be calculated with the bifurcation_grid function. Instead of an interval, the last argument is a range of numbers:","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"bif = bifurcation_grid(bistable_switch, bistable_switch_p,:n1,1.:5.)\nplot(bif)\nscatter!([[],[]],color=[:blue :red],label = [\"Stable\" \"Unstable\"])","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Error: UndefVarError: bifurcation_grid not defined","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/#Bifurcation-diagrams-over-two-dimensions","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"Bifurcation diagrams over two dimensions","text":"","category":"section"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"In addition to the bifurcation diagrams illustrated above, where only a single variable is varied, it is also possible to investigate the steady state properties of s system as two different parameters are varied. Due to the nature of the underlying bifurcation algorithm it is not possible to continuously vary both parameters. Instead, a set of discrete values are selected for the first parameter, and a continuous interval for the second. Next, for each discrete value of the first parameter, a normal bifurcation diagram is created over the interval given for the second parameter.","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"bif = bifurcation_grid_diagram(bistable_switch, bistable_switch_p,:n1,0.:4.,:v1,(.1,5.))\nplot(bif)\nplot!([[],[]],color=[:blue :red],label = [\"Stable\" \"Unstable\"])","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Error: UndefVarError: bifurcation_grid_diagram not defined","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"In the single variable case we could use a bifurcation_grid to investigate the behavior of a parameter which could only attain discrete values. In the same way, if we are interested in two parameters, both of which require integer values, we can use bifrucation_grid_2d. In our case, this is required if we want to vary both the parameters n1 and n2:","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"bif = bifurcation_grid_2d(bistable_switch, bistable_switch_p,:n1,1.:3.,:n2,1.:10.)\nplot(bif)\nscatter!([[],[]],color=[:blue :red],label = [\"Stable\" \"Unstable\"])","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Error: UndefVarError: bifurcation_grid_2d not defined","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/#The-Brusselator","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"The Brusselator","text":"","category":"section"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"The Brusselator is a well know reaction network, which may or may not oscillate, depending on parameter values.","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"brusselator = @reaction_network begin\n    A, ∅ → X\n    1, 2X + Y → 3X\n    B, X → Y\n    1, X → ∅\nend A B;\nA = 0.5; B = 4.;\nbrusselator_p = [A, B];","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Error: LoadError: UndefVarError: @reaction_network not defined\nin expression starting at /var/lib/buildkite-agent/builds/1-amdci4-julia-cs\nail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/models/04b-diffeqbio_\nIII_steadystates.jmd:2","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"The system has only one steady state, for (XY)=(ABA) This fixed point becomes unstable when B  1+A^2, leading to oscillations. Bifurcation diagrams can be used to determine the system's stability, and hence look for where oscillations might appear in the Brusselator:","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"bif = bifurcations(brusselator,brusselator_p,:B,(0.1,2.5))\nplot(bif,2)\nplot!([[],[],[],[]],color=[:blue :cyan :orange :red],label = [\"Stable Real\" \"Stable Complex\" \"Unstable Complex\" \"Unstable Real\"])","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Error: UndefVarError: bifurcations not defined","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Here red and yellow colors label unstable steady-states, while blue and cyan label stable steady-states. (In addition, yellow and cyan correspond to points where at least one eigenvalue of the Jacobian is imaginary, while red and blue correspond to points with real-valued eigenvalues.)","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Given A=0.5, the point at which the system should become unstable is B=1.25. We can confirm this in the bifurcation diagram.","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"We can also investigate the behavior when we vary both parameters of the system:","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"bif = bifurcation_grid_diagram(brusselator,brusselator_p,:B,0.5:0.02:5.0,:A,(0.2,5.0))\nplot(bif)\nplot!([[],[],[],[]],color=[:blue :cyan :orange :red],label = [\"Stable Real\" \"Stable Complex\" \"Unstable Complex\" \"Unstable Real\"])","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Error: UndefVarError: bifurcation_grid_diagram not defined","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/#Getting-Help","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"Getting Help","text":"","category":"section"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Have a question related to DiffEqBiological or this tutorial? Feel free to ask in the DifferentialEquations.jl Gitter. If you think you've found a bug in DiffEqBiological, or would like to request/discuss new functionality, feel free to open an issue on Github (but please check there is no related issue already open). If you've found a bug in this tutorial, or have a suggestion, feel free to open an issue on the SciMLTutorials Github site. Or, submit a pull request to SciMLTutorials updating the tutorial!","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"","category":"page"},{"location":"models/04b-diffeqbio_III_steadystates/","page":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","title":"DiffEqBiological Tutorial III: Steady-States and Bifurcations","text":"Error: MethodError: no method matching tutorial_footer(::String, ::String; \nremove_homedir=true)\nClosest candidates are:\n  tutorial_footer(::Any, ::Any) at /var/lib/buildkite-agent/builds/1-amdci4\n-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/src/SciMLTutorials.jl:\n79 got unsupported keyword argument \"remove_homedir\"\n  tutorial_footer(::Any) at /var/lib/buildkite-agent/builds/1-amdci4-julia-\ncsail-mit-edu/julialang/scimltutorials-dot-jl/src/SciMLTutorials.jl:79 got \nunsupported keyword argument \"remove_homedir\"","category":"page"},{"location":"ode_extras/01-ModelingToolkit/#ModelingToolkit.jl,-An-IR-and-Compiler-for-Scientific-Models","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"","category":"section"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"A lot of people are building modeling languages for their specific domains. However, while the syntax my vary greatly between these domain-specific languages (DSLs), the internals of modeling frameworks are surprisingly similar: building differential equations, calculating Jacobians, etc.","category":"page"},{"location":"ode_extras/01-ModelingToolkit/#ModelingToolkit.jl-is-metamodeling-systemitized","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl is metamodeling systemitized","text":"","category":"section"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"After building our third modeling interface, we realized that this problem can be better approached by having a reusable internal structure which DSLs can target. This internal is ModelingToolkit.jl: an Intermediate Representation (IR) with a well-defined interface for defining system transformations and compiling to Julia functions for use in numerical libraries. Now a DSL can easily be written by simply defining the translation to ModelingToolkit.jl's primatives and querying for the mathematical quantities one needs.","category":"page"},{"location":"ode_extras/01-ModelingToolkit/#Basic-usage:-defining-differential-equation-systems,-with-performance!","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"Basic usage: defining differential equation systems, with performance!","text":"","category":"section"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"Let's explore the IR itself. ModelingToolkit.jl is friendly to use, and can used as a symbolic DSL in its own right. Let's define and solve the Lorenz differential equation system using ModelingToolkit to generate the functions:","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"using ModelingToolkit\n\n### Define a differential equation system\n\n@parameters t σ ρ β\n@variables x(t) y(t) z(t)\n@derivatives D'~t\n\neqs = [D(x) ~ σ*(y-x),\n       D(y) ~ x*(ρ-z)-y,\n       D(z) ~ x*y - β*z]\nde = ODESystem(eqs, t, [x,y,z], [σ,ρ,β])\node_f = ODEFunction(de)\n\n### Use in DifferentialEquations.jl\n\nusing OrdinaryDiffEq\nu₀ = ones(3)\ntspan = (0.0,100.0)\np = [10.0,28.0,10/3]\nprob = ODEProblem(ode_f,u₀,tspan,p)\nsol = solve(prob,Tsit5())\n\nusing Plots\nplot(sol,vars=(1,2,3))","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"(Image: )","category":"page"},{"location":"ode_extras/01-ModelingToolkit/#ModelingToolkit-is-a-compiler-for-mathematical-systems","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit is a compiler for mathematical systems","text":"","category":"section"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"At its core, ModelingToolkit is a compiler. It's IR is its type system, and its output are Julia functions (it's a compiler for Julia code to Julia code, written in Julia).","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"DifferentialEquations.jl wants a function f(u,p,t) or f(du,u,p,t) for defining an ODE system, so ModelingToolkit.jl builds both. First the out of place version:","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"generate_function(de)[1]","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":":(function (var\"##arg#1110\", var\"##arg#1111\", t)\n      #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:\n282 =#\n      #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:\n283 =#\n      let var\"x(t)\" = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9i\nQGH/src/code.jl:169 =# @inbounds(var\"##arg#1110\"[1]), var\"y(t)\" = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea\n-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg#1110\"[2]), var\"z(t)\" = #= /root/.cache/juli\na-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg\n#1110\"[3]), σ = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/sr\nc/code.jl:169 =# @inbounds(var\"##arg#1111\"[1]), ρ = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6\nc6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg#1111\"[2]), β = #= /root/.cache/julia-buildkite-plugin/dep\nots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg#1111\"[3])\n          #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code\n.jl:375 =#\n          (SymbolicUtils.Code.create_array)(typeof(var\"##arg#1110\"), nothing, Val{1}(), Val{(3,)}(), (*)(σ, (+)(var\"y(t)\", (*)(-1,\n var\"x(t)\"))), (+)((*)(var\"x(t)\", (+)(ρ, (*)(-1, var\"z(t)\"))), (*)(-1, var\"y(t)\")), (+)((*)(var\"x(t)\", var\"y(t)\"), (*)(-1, β, var\"\nz(t)\")))\n      end\n  end)","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"and the in-place:","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"generate_function(de)[2]","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":":(function (var\"##out#1115\", var\"##arg#1113\", var\"##arg#1114\", t)\n      #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:\n282 =#\n      #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:\n283 =#\n      let var\"x(t)\" = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9i\nQGH/src/code.jl:169 =# @inbounds(var\"##arg#1113\"[1]), var\"y(t)\" = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea\n-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg#1113\"[2]), var\"z(t)\" = #= /root/.cache/juli\na-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg\n#1113\"[3]), σ = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/sr\nc/code.jl:169 =# @inbounds(var\"##arg#1114\"[1]), ρ = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6\nc6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg#1114\"[2]), β = #= /root/.cache/julia-buildkite-plugin/dep\nots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg#1114\"[3])\n          #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/Symbolics/h8kPL/src/build_fu\nnction.jl:331 =#\n          #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code\n.jl:329 =# @inbounds begin\n                  #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/\nsrc/code.jl:325 =#\n                  var\"##out#1115\"[1] = (*)(σ, (+)(var\"y(t)\", (*)(-1, var\"x(t)\")))\n                  var\"##out#1115\"[2] = (+)((*)(var\"x(t)\", (+)(ρ, (*)(-1, var\"z(t)\"))), (*)(-1, var\"y(t)\"))\n                  var\"##out#1115\"[3] = (+)((*)(var\"x(t)\", var\"y(t)\"), (*)(-1, β, var\"z(t)\"))\n                  #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/\nsrc/code.jl:327 =#\n                  nothing\n              end\n      end\n  end)","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"ModelingToolkit.jl can be used to calculate the Jacobian of the differential equation system:","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"jac = calculate_jacobian(de)","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"3×3 Matrix{Symbolics.Num}:\n       -σ     σ      0\n ρ - z(t)    -1  -x(t)\n     y(t)  x(t)     -β","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"It will automatically generate functions for using this Jacobian within the stiff ODE solvers for faster solving:","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"jac_expr = generate_jacobian(de)","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"(:(function (var\"##arg#1116\", var\"##arg#1117\", t)\n      #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:\n282 =#\n      #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:\n283 =#\n      let var\"x(t)\" = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9i\nQGH/src/code.jl:169 =# @inbounds(var\"##arg#1116\"[1]), var\"y(t)\" = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea\n-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg#1116\"[2]), var\"z(t)\" = #= /root/.cache/juli\na-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg\n#1116\"[3]), σ = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/sr\nc/code.jl:169 =# @inbounds(var\"##arg#1117\"[1]), ρ = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6\nc6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg#1117\"[2]), β = #= /root/.cache/julia-buildkite-plugin/dep\nots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg#1117\"[3])\n          #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code\n.jl:375 =#\n          (SymbolicUtils.Code.create_array)(typeof(var\"##arg#1116\"), nothing, Val{2}(), Val{(3, 3)}(), (*)(-1, σ), (+)(ρ, (*)(-1, \nvar\"z(t)\")), var\"y(t)\", σ, -1, var\"x(t)\", 0, (*)(-1, var\"x(t)\"), (*)(-1, β))\n      end\n  end), :(function (var\"##out#1118\", var\"##arg#1116\", var\"##arg#1117\", t)\n      #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:\n282 =#\n      #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:\n283 =#\n      let var\"x(t)\" = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9i\nQGH/src/code.jl:169 =# @inbounds(var\"##arg#1116\"[1]), var\"y(t)\" = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea\n-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg#1116\"[2]), var\"z(t)\" = #= /root/.cache/juli\na-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg\n#1116\"[3]), σ = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/sr\nc/code.jl:169 =# @inbounds(var\"##arg#1117\"[1]), ρ = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6\nc6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg#1117\"[2]), β = #= /root/.cache/julia-buildkite-plugin/dep\nots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg#1117\"[3])\n          #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/Symbolics/h8kPL/src/build_fu\nnction.jl:331 =#\n          #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code\n.jl:329 =# @inbounds begin\n                  #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/\nsrc/code.jl:325 =#\n                  var\"##out#1118\"[1] = (*)(-1, σ)\n                  var\"##out#1118\"[2] = (+)(ρ, (*)(-1, var\"z(t)\"))\n                  var\"##out#1118\"[3] = var\"y(t)\"\n                  var\"##out#1118\"[4] = σ\n                  var\"##out#1118\"[5] = -1\n                  var\"##out#1118\"[6] = var\"x(t)\"\n                  var\"##out#1118\"[7] = 0\n                  var\"##out#1118\"[8] = (*)(-1, var\"x(t)\")\n                  var\"##out#1118\"[9] = (*)(-1, β)\n                  #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/\nsrc/code.jl:327 =#\n                  nothing\n              end\n      end\n  end))","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"It can even do fancy linear algebra. Stiff ODE solvers need to perform an LU-factorization which is their most expensive part. But ModelingToolkit.jl can skip this operation and instead generate the analytical solution to a matrix factorization, and build a Julia function for directly computing the factorization, which is then optimized in LLVM compiler passes.","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"ModelingToolkit.generate_factorized_W(de)[1]","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"Error: MethodError: no method matching generate_factorized_W(::ModelingToolkit.ODESystem)","category":"page"},{"location":"ode_extras/01-ModelingToolkit/#Solving-Nonlinear-systems","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"Solving Nonlinear systems","text":"","category":"section"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"ModelingToolkit.jl is not just for differential equations. It can be used for any mathematical target that is representable by its IR. For example, let's solve a rootfinding problem F(x)=0. What we do is define a nonlinear system and generate a function for use in NLsolve.jl","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"@variables x y z\n@parameters σ ρ β\n\n# Define a nonlinear system\neqs = [0 ~ σ*(y-x),\n       0 ~ x*(ρ-z)-y,\n       0 ~ x*y - β*z]\nns = NonlinearSystem(eqs, [x,y,z], [σ,ρ,β])\nnlsys_func = generate_function(ns)","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"(:(function (var\"##arg#1120\", var\"##arg#1121\")\n      #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:\n282 =#\n      #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:\n283 =#\n      let x = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/\ncode.jl:169 =# @inbounds(var\"##arg#1120\"[1]), y = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6\nea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg#1120\"[2]), z = #= /root/.cache/julia-buildkite-plugin/depot\ns/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg#1120\"[3]), σ = #= /root\n/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inboun\nds(var\"##arg#1121\"[1]), ρ = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUt\nils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg#1121\"[2]), β = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-b\nc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg#1121\"[3])\n          #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code\n.jl:375 =#\n          (SymbolicUtils.Code.create_array)(typeof(var\"##arg#1120\"), nothing, Val{1}(), Val{(3,)}(), (*)(σ, (+)(y, (*)(-1, x))), (\n+)((*)(x, (+)(ρ, (*)(-1, z))), (*)(-1, y)), (+)((*)(x, y), (*)(-1, z, β)))\n      end\n  end), :(function (var\"##out#1122\", var\"##arg#1120\", var\"##arg#1121\")\n      #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:\n282 =#\n      #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:\n283 =#\n      let x = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/\ncode.jl:169 =# @inbounds(var\"##arg#1120\"[1]), y = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6\nea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg#1120\"[2]), z = #= /root/.cache/julia-buildkite-plugin/depot\ns/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg#1120\"[3]), σ = #= /root\n/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inboun\nds(var\"##arg#1121\"[1]), ρ = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUt\nils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg#1121\"[2]), β = #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-b\nc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code.jl:169 =# @inbounds(var\"##arg#1121\"[3])\n          #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/Symbolics/h8kPL/src/build_fu\nnction.jl:331 =#\n          #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/src/code\n.jl:329 =# @inbounds begin\n                  #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/\nsrc/code.jl:325 =#\n                  var\"##out#1122\"[1] = (*)(σ, (+)(y, (*)(-1, x)))\n                  var\"##out#1122\"[2] = (+)((*)(x, (+)(ρ, (*)(-1, z))), (*)(-1, y))\n                  var\"##out#1122\"[3] = (+)((*)(x, y), (*)(-1, z, β))\n                  #= /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea/packages/SymbolicUtils/9iQGH/\nsrc/code.jl:327 =#\n                  nothing\n              end\n      end\n  end))","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"We can then tell ModelingToolkit.jl to compile this function for use in NLsolve.jl, and then numerically solve the rootfinding problem:","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"nl_f = @eval eval(nlsys_func[2])\n# Make a closure over the parameters for for NLsolve.jl\nf2 = (du,u) -> nl_f(du,u,(10.0,26.0,2.33))\n\nusing NLsolve\nnlsolve(f2,ones(3))","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"Results of Nonlinear Solver Algorithm\n * Algorithm: Trust-region with dogleg and autoscaling\n * Starting Point: [1.0, 1.0, 1.0]\n * Zero: [2.2228042243306243e-10, 2.2228042243645056e-10, -9.990339599422887e-11]\n * Inf-norm of residuals: 0.000000\n * Iterations: 3\n * Convergence: true\n   * |x - x'| < 0.0e+00: false\n   * |f(x)| < 1.0e-08: true\n * Function Calls (f): 4\n * Jacobian Calls (df/dx): 4","category":"page"},{"location":"ode_extras/01-ModelingToolkit/#Library-of-transformations-on-mathematical-systems","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"Library of transformations on mathematical systems","text":"","category":"section"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"The reason for using ModelingToolkit is not just for defining performant Julia functions for solving systems, but also for performing mathematical transformations which may be required in order to numerically solve the system. For example, let's solve a third order ODE. The way this is done is by transforming the third order ODE into a first order ODE, and then solving the resulting ODE. This transformation is given by the ode_order_lowering function.","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"@derivatives D3'''~t\n@derivatives D2''~t\n@variables u(t), x(t)\neqs = [D3(u) ~ 2(D2(u)) + D(u) + D(x) + 1\n       D2(x) ~ D(x) + 2]\nde = ODESystem(eqs, t, [u,x], [])\nde1 = ode_order_lowering(de)","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"Model ##ODESystem#1123 with 5 equations\nStates (5):\n  uˍtt(t)\n  xˍt(t)\n  uˍt(t)\n  u(t)\n⋮\nParameters (0):","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"de1.eqs","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"5-element Vector{Symbolics.Equation}:\n Differential(t)(uˍtt(t)) ~ 1 + uˍt(t) + xˍt(t) + 2uˍtt(t)\n Differential(t)(xˍt(t)) ~ 2 + xˍt(t)\n Differential(t)(uˍt(t)) ~ uˍtt(t)\n Differential(t)(u(t)) ~ uˍt(t)\n Differential(t)(x(t)) ~ xˍt(t)","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"This has generated a system of 5 first order ODE systems which can now be used in the ODE solvers.","category":"page"},{"location":"ode_extras/01-ModelingToolkit/#Linear-Algebra...-for-free?","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"Linear Algebra... for free?","text":"","category":"section"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"Let's take a look at how to extend ModelingToolkit.jl in new directions. Let's define a Jacobian just by using the derivative primatives by hand:","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"@parameters t σ ρ β\n@variables x(t) y(t) z(t)\n@derivatives D'~t Dx'~x Dy'~y Dz'~z\neqs = [D(x) ~ σ*(y-x),\n       D(y) ~ x*(ρ-z)-y,\n       D(z) ~ x*y - β*z]\nJ = [Dx(eqs[1].rhs) Dy(eqs[1].rhs) Dz(eqs[1].rhs)\n Dx(eqs[2].rhs) Dy(eqs[2].rhs) Dz(eqs[2].rhs)\n Dx(eqs[3].rhs) Dy(eqs[3].rhs) Dz(eqs[3].rhs)]","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"3×3 Matrix{SymbolicUtils.Term{Real, Nothing}}:\n Differential(x(t))(σ*(y(t) - x(t)))         …  Differential(z(t))(σ*(y(t) - x(t)))\n Differential(x(t))(x(t)*(ρ - z(t)) - y(t))     Differential(z(t))(x(t)*(ρ - z(t)) - y(t))\n Differential(x(t))(x(t)*y(t) - (β*z(t)))       Differential(z(t))(x(t)*y(t) - (β*z(t)))","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"Notice that this writes the derivatives in a \"lazy\" manner. If we want to actually compute the derivatives, we can expand out those expressions:","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"J = expand_derivatives.(J)","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"3×3 Matrix{Any}:\n -σ          σ     0\n ρ - z(t)  -1       -x(t)\n y(t)        x(t)   -β","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"Here's the magic of ModelingToolkit.jl: Julia treats ModelingToolkit expressions like a Number, and so generic numerical functions are directly usable on ModelingToolkit expressions! Let's compute the LU-factorization of this Jacobian we defined using Julia's Base linear algebra library.","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"using LinearAlgebra\nluJ = lu(J,Val(false))","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"Error: MethodError: no method matching oneunit(::Type{Any})\nClosest candidates are:\n  oneunit(::Type{Union{Missing, T}}) where T at missing.jl:105\n  oneunit(::Type{T}) where T at number.jl:319\n  oneunit(::T) where T at number.jl:318\n  ...","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"luJ.L","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"Error: UndefVarError: luJ not defined","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"and the inverse?","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"invJ = inv(luJ)","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"Error: UndefVarError: luJ not defined","category":"page"},{"location":"ode_extras/01-ModelingToolkit/#Thus-ModelingToolkit.jl-can-utilize-existing-numerical-code-on-symbolic-codes","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"Thus ModelingToolkit.jl can utilize existing numerical code on symbolic codes","text":"","category":"section"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"Let's follow this thread a little deeper.","category":"page"},{"location":"ode_extras/01-ModelingToolkit/#Automatically-convert-numerical-codes-to-symbolic","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"Automatically convert numerical codes to symbolic","text":"","category":"section"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"Let's take someone's code written to numerically solve the Lorenz equation:","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"function lorenz(du,u,p,t)\n du[1] = p[1]*(u[2]-u[1])\n du[2] = u[1]*(p[2]-u[3]) - u[2]\n du[3] = u[1]*u[2] - p[3]*u[3]\nend","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"lorenz (generic function with 1 method)","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"Since ModelingToolkit can trace generic numerical functions in Julia, let's trace it with Operations. When we do this, it'll spit out a symbolic representation of their numerical code:","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"u = [x,y,z]\ndu = similar(u)\np = [σ,ρ,β]\nlorenz(du,u,p,t)\ndu","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"3-element Vector{Symbolics.Num}:\n        σ*(y(t) - x(t))\n x(t)*(ρ - z(t)) - y(t)\n   x(t)*y(t) - (β*z(t))","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"We can then perform symbolic manipulations on their numerical code, and build a new numerical code that optimizes/fixes their original function!","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"J = [Dx(du[1]) Dy(du[1]) Dz(du[1])\n     Dx(du[2]) Dy(du[2]) Dz(du[2])\n     Dx(du[3]) Dy(du[3]) Dz(du[3])]\nJ = expand_derivatives.(J)","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"3×3 Matrix{Symbolics.Num}:\n       -σ     σ      0\n ρ - z(t)    -1  -x(t)\n     y(t)  x(t)     -β","category":"page"},{"location":"ode_extras/01-ModelingToolkit/#Automated-Sparsity-Detection","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"Automated Sparsity Detection","text":"","category":"section"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"In many cases one has to speed up large modeling frameworks by taking into account sparsity. While ModelingToolkit.jl can be used to compute Jacobians, we can write a standard Julia function in order to get a spase matrix of expressions which automatically detects and utilizes the sparsity of their function.","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"using SparseArrays\nfunction SparseArrays.SparseMatrixCSC(M::Matrix{T}) where {T<:ModelingToolkit.Expression}\n    idxs = findall(!iszero, M)\n    I = [i[1] for i in idxs]\n    J = [i[2] for i in idxs]\n    V = [M[i] for i in idxs]\n    return SparseArrays.sparse(I, J, V, size(M)...)\nend\nsJ = SparseMatrixCSC(J)","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"Error: UndefVarError: Expression not defined","category":"page"},{"location":"ode_extras/01-ModelingToolkit/#Dependent-Variables,-Functions,-Chain-Rule","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"Dependent Variables, Functions, Chain Rule","text":"","category":"section"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"\"Variables\" are overloaded. When you are solving a differential equation, the variable u(t) is actually a function of time. In order to handle these kinds of variables in a mathematically correct and extensible manner, the ModelingToolkit IR actually treats variables as functions, and constant variables are simply 0-ary functions (t()).","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"We can utilize this idea to have parameters that are also functions. For example, we can have a parameter σ which acts as a function of 1 argument, and then utilize this function within our differential equations:","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"@parameters σ(..)\neqs = [D(x) ~ σ(t-1)*(y-x),\n       D(y) ~ x*(σ(t^2)-z)-y,\n       D(z) ~ x*y - β*z]","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"3-element Vector{Symbolics.Equation}:\n Differential(t)(x(t)) ~ σ(t - 1)*(y(t) - x(t))\n Differential(t)(y(t)) ~ x(t)*(σ(t^2) - z(t)) - y(t)\n Differential(t)(z(t)) ~ x(t)*y(t) - (β*z(t))","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"Notice that when we calculate the derivative with respect to t, the chain rule is automatically handled:","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"@derivatives Dₜ'~t\nDₜ(x*(σ(t^2)-z)-y)\nexpand_derivatives(Dₜ(x*(σ(t^2)-z)-y))","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"x(t)*(Differential(t)(σ(t^2)) - Differential(t)(z(t))) + Differential(t)(x(t))*(σ(t^2) - z(t)) - Differential(t)(y(t))","category":"page"},{"location":"ode_extras/01-ModelingToolkit/#Hackability:-Extend-directly-from-the-language","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"Hackability: Extend directly from the language","text":"","category":"section"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"ModelingToolkit.jl is written in Julia, and thus it can be directly extended from Julia itself. Let's define a normal Julia function and call it with a variable:","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"_f(x) = 2x + x^2\n_f(x)","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"x(t)^2 + 2x(t)","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"Recall that when we do that, it will automatically trace this function and then build a symbolic expression. But what if we wanted our function to be a primative in the symbolic framework? This can be done by registering the function.","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"f(x) = 2x + x^2\n@register f(x)","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"Now this function is a new primitive:","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"f(x)","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"Main.##WeaveSandBox#1074.f(x(t))","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"and we can now define derivatives of our function:","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"function ModelingToolkit.derivative(::typeof(f), args::NTuple{1,Any}, ::Val{1})\n    2 + 2args[1]\nend\nexpand_derivatives(Dx(f(x)))","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"2 + 2x(t)","category":"page"},{"location":"ode_extras/01-ModelingToolkit/#Appendix","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"Appendix","text":"","category":"section"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"tutorials/ode_extras\",\"01-ModelingToolkit.jmd\")","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"Computer Information:","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"Julia Version 1.6.2\nCommit 1b93d53fc4 (2021-07-14 15:36 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, znver2)\nEnvironment:\n  JULIA_DEPOT_PATH = /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n  JULIA_NUM_THREADS = 16\n","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"Package Information:","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"      Status `/var/lib/buildkite-agent/builds/5-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/ode_extras/Project.toml`\n  [f3b72e0c] DiffEqDevTools v2.27.2\n  [0c46a032] DifferentialEquations v6.17.1\n  [961ee093] ModelingToolkit v5.17.3\n  [76087f3c] NLopt v0.6.2\n  [2774e3e8] NLsolve v4.5.1\n  [429524aa] Optim v1.3.0\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [91a5bcdd] Plots v1.15.2\n  [30cb0354] SciMLTutorials v0.9.0\n  [37e2e46d] LinearAlgebra\n  [2f01184e] SparseArrays","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"And the full manifest:","category":"page"},{"location":"ode_extras/01-ModelingToolkit/","page":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","title":"ModelingToolkit.jl, An IR and Compiler for Scientific Models","text":"      Status `/var/lib/buildkite-agent/builds/5-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/ode_extras/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.16.0\n  [1520ce14] AbstractTrees v0.3.4\n  [79e6a3ab] Adapt v3.3.0\n  [ec485272] ArnoldiMethod v0.1.0\n  [4fba245c] ArrayInterface v3.1.15\n  [4c555306] ArrayLayouts v0.7.0\n  [aae01518] BandedMatrices v0.16.9\n  [6e4b80f9] BenchmarkTools v1.0.0\n  [764a87c0] BoundaryValueDiffEq v2.7.1\n  [fa961155] CEnum v0.4.1\n  [00ebfdb7] CSTParser v2.5.0\n  [d360d2e6] ChainRulesCore v0.9.44\n  [b630d9fa] CheapThreads v0.2.5\n  [523fee87] CodecBzip2 v0.7.2\n  [944b1d66] CodecZlib v0.7.0\n  [35d6a980] ColorSchemes v3.12.1\n  [3da002f7] ColorTypes v0.11.0\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [a80b9123] CommonMark v0.8.1\n  [38540f10] CommonSolve v0.2.0\n  [bbf7d656] CommonSubexpressions v0.3.0\n  [34da2185] Compat v3.30.0\n  [8f4d0f93] Conda v1.5.2\n  [187b0558] ConstructionBase v1.2.1\n  [d38c429a] Contour v0.5.7\n  [a8cc5b0e] Crayons v4.0.4\n  [9a962f9c] DataAPI v1.6.0\n  [864edb3b] DataStructures v0.18.9\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [bcd4f6db] DelayDiffEq v5.31.0\n  [2b5f629d] DiffEqBase v6.62.2\n  [459566f4] DiffEqCallbacks v2.16.1\n  [f3b72e0c] DiffEqDevTools v2.27.2\n  [5a0ffddc] DiffEqFinancial v2.4.0\n  [c894b116] DiffEqJump v6.14.2\n  [77a26b50] DiffEqNoiseProcess v5.7.3\n  [055956cb] DiffEqPhysics v3.9.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.0.2\n  [0c46a032] DifferentialEquations v6.17.1\n  [c619ae07] DimensionalPlotRecipes v1.2.0\n  [b4f34e82] Distances v0.10.3\n  [31c24e10] Distributions v0.24.18\n  [ffbed154] DocStringExtensions v0.8.4\n  [e30172f5] Documenter v0.26.3\n  [d4d017d3] ExponentialUtilities v1.8.4\n  [e2ba6199] ExprTools v0.1.3\n  [c87230d0] FFMPEG v0.4.0\n  [7034ab61] FastBroadcast v0.1.8\n  [9aa1b823] FastClosures v0.3.2\n  [1a297f60] FillArrays v0.11.7\n  [6a86dc24] FiniteDiff v2.8.0\n  [53c48c17] FixedPointNumbers v0.8.4\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.18\n  [069b7b12] FunctionWrappers v1.1.2\n  [28b8d3ca] GR v0.57.4\n  [5c1252a2] GeometryBasics v0.3.12\n  [42e2da0e] Grisu v1.0.2\n  [cd3eb016] HTTP v0.9.9\n  [eafb193a] Highlights v0.4.5\n  [0e44f5e4] Hwloc v2.0.0\n  [7073ff75] IJulia v1.23.2\n  [b5f81e59] IOCapture v0.1.1\n  [615f187c] IfElse v0.1.0\n  [d25df0c9] Inflate v0.1.2\n  [83e8ac13] IniFile v0.5.0\n  [c8e1da08] IterTools v1.3.0\n  [42fd0dbc] IterativeSolvers v0.9.1\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.3.0\n  [682c06a0] JSON v0.21.1\n  [7d188eb4] JSONSchema v0.3.3\n  [98e50ef6] JuliaFormatter v0.13.7\n  [b964fa9f] LaTeXStrings v1.2.1\n  [2ee39098] LabelledArrays v1.6.1\n  [23fbe1c1] Latexify v0.15.5\n  [093fc24a] LightGraphs v1.3.5\n  [d3d80556] LineSearches v7.1.1\n  [2ab3a3ac] LogExpFunctions v0.2.4\n  [bdcacae8] LoopVectorization v0.12.23\n  [1914dd2f] MacroTools v0.5.6\n  [b8f27783] MathOptInterface v0.9.22\n  [fdba3010] MathProgBase v0.7.8\n  [739be429] MbedTLS v1.0.3\n  [442fdcdd] Measures v0.3.1\n  [e1d29d7a] Missings v1.0.0\n  [961ee093] ModelingToolkit v5.17.3\n  [46d2c3a1] MuladdMacro v0.2.2\n  [f9640e96] MultiScaleArrays v1.8.1\n  [ffc61752] Mustache v1.0.10\n  [d8a4904e] MutableArithmetics v0.2.19\n  [d41bc354] NLSolversBase v7.8.0\n  [76087f3c] NLopt v0.6.2\n  [2774e3e8] NLsolve v4.5.1\n  [77ba4419] NaNMath v0.3.5\n  [8913a72c] NonlinearSolve v0.3.8\n  [6fe1bfb0] OffsetArrays v1.9.0\n  [429524aa] Optim v1.3.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [90014a1f] PDMats v0.11.0\n  [65888b18] ParameterizedFunctions v5.10.0\n  [d96e819e] Parameters v0.12.2\n  [69de0a69] Parsers v1.1.0\n  [ccf2f8ad] PlotThemes v2.0.1\n  [995b91a9] PlotUtils v1.0.10\n  [91a5bcdd] Plots v1.15.2\n  [e409e4f3] PoissonRandom v0.4.0\n  [f517fe37] Polyester v0.3.1\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [21216c6a] Preferences v1.2.2\n  [1fd47b50] QuadGK v2.4.1\n  [74087812] Random123 v1.3.1\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.4.0\n  [3cdcf5f2] RecipesBase v1.1.1\n  [01d81517] RecipesPipeline v0.3.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [f2c3362d] RecursiveFactorization v0.1.12\n  [189a3867] Reexport v1.0.0\n  [ae029012] Requires v1.1.3\n  [ae5879a3] ResettableStacks v1.1.0\n  [79098fc4] Rmath v0.7.0\n  [47965b36] RootedTrees v1.0.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.2\n  [476501e8] SLEEFPirates v0.6.20\n  [1bc83da4] SafeTestsets v0.0.1\n  [0bca4576] SciMLBase v1.13.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [6c6a2e73] Scratch v1.0.3\n  [efcf1570] Setfield v0.7.0\n  [992d4aef] Showoff v1.0.3\n  [699a6c99] SimpleTraits v0.9.3\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.0\n  [47a9eef4] SparseDiffTools v1.13.2\n  [276daf66] SpecialFunctions v1.4.1\n  [aedffcd0] Static v0.2.4\n  [90137ffa] StaticArrays v1.2.0\n  [82ae8749] StatsAPI v1.0.0\n  [2913bbd2] StatsBase v0.33.8\n  [4c63d2b9] StatsFuns v0.9.8\n  [9672c7b4] SteadyStateDiffEq v1.6.2\n  [789caeaf] StochasticDiffEq v6.34.1\n  [7792a7ef] StrideArraysCore v0.1.11\n  [09ab397b] StructArrays v0.5.1\n  [c3572dad] Sundials v4.4.3\n  [d1185830] SymbolicUtils v0.11.2\n  [0c5d862f] Symbolics v0.1.25\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.4.2\n  [8290d209] ThreadingUtilities v0.4.4\n  [a759f4b9] TimerOutputs v0.5.9\n  [0796e94c] Tokenize v0.5.16\n  [3bb67fe8] TranscodingStreams v0.9.5\n  [a2a6695c] TreeViews v0.3.0\n  [5c2747f8] URIs v1.3.0\n  [3a884ed6] UnPack v1.0.2\n  [1986cc42] Unitful v1.7.0\n  [3d5dd08c] VectorizationBase v0.20.11\n  [81def892] VersionParsing v1.2.0\n  [19fa3120] VertexSafeGraphs v0.1.2\n  [44d3d7a6] Weave v0.10.8\n  [ddb6d928] YAML v0.4.6\n  [c2297ded] ZMQ v1.2.1\n  [a5390f91] ZipFile v0.9.3\n  [700de1a5] ZygoteRules v0.2.1\n  [6e34b625] Bzip2_jll v1.0.6+5\n  [83423d85] Cairo_jll v1.16.0+6\n  [5ae413db] EarCut_jll v2.1.5+1\n  [2e619515] Expat_jll v2.2.10+0\n  [b22a6f82] FFMPEG_jll v4.3.1+4\n  [a3f928ae] Fontconfig_jll v2.13.1+14\n  [d7e528f0] FreeType2_jll v2.10.1+5\n  [559328eb] FriBidi_jll v1.0.5+6\n  [0656b61e] GLFW_jll v3.3.4+0\n  [d2c73de3] GR_jll v0.57.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.1+0\n  [e33a78d0] Hwloc_jll v2.4.1+0\n  [aacddb02] JpegTurbo_jll v2.0.1+3\n  [c1c5ebd0] LAME_jll v3.100.0+3\n  [dd4b983a] LZO_jll v2.10.1+0\n  [dd192d2f] LibVPX_jll v1.9.0+1\n  [e9f186c6] Libffi_jll v3.2.2+0\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+0\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.1.0+2\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [079eb43e] NLopt_jll v2.7.0+0\n  [e7412a2a] Ogg_jll v1.3.4+2\n  [458c3c95] OpenSSL_jll v1.1.1+6\n  [efe28fd5] OpenSpecFun_jll v0.5.4+0\n  [91d4177d] Opus_jll v1.3.1+3\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.2+0\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.0+1\n  [a2964d1f] Wayland_jll v1.17.0+4\n  [2381bf8a] Wayland_protocols_jll v1.18.0+4\n  [02c8fc9c] XML2_jll v2.9.12+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.2+6\n  [3161d3a3] Zstd_jll v1.5.0+0\n  [0ac62f75] libass_jll v0.14.0+4\n  [f638f0a6] libfdk_aac_jll v0.1.6+4\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.6+6\n  [1270edf5] x264_jll v2020.7.14+2\n  [dfaa095f] x265_jll v3.0.0+3\n  [d8fb68d0] xkbcommon_jll v0.9.1+5\n  [0dad84c5] ArgTools\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [b27032c2] LibCURL\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions\n  [44cfe95a] Pkg\n  [de0858da] Printf\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML\n  [a4e569a6] Tar\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll\n  [deac9b47] LibCURL_jll\n  [29816b5a] LibSSH2_jll\n  [c8ffd9c3] MbedTLS_jll\n  [14a3606d] MozillaCACerts_jll\n  [4536629a] OpenBLAS_jll\n  [bea87d4a] SuiteSparse_jll\n  [83775a58] Zlib_jll\n  [8e850ede] nghttp2_jll\n  [3f19e933] p7zip_jll","category":"page"},{"location":"perturbation/02-perturbation_differential/#Mixed-Symbolic/Numerical-Methods-for-Perturbation-Theory-Differential-Equations","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"","category":"section"},{"location":"perturbation/02-perturbation_differential/#Prelims","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Prelims","text":"","category":"section"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"In the previous tutorial, Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations, we discussed how to solve algebraic equations using Symbolics.jl. Here, our goal is to extend the method to differential equations. First, we import the following helper functions that were introduced in Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations.","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"using Symbolics, SymbolicUtils\n\ndef_taylor(x, ps) = sum([a*x^i for (i,a) in enumerate(ps)])\ndef_taylor(x, ps, p₀) = p₀ + def_taylor(x, ps)\n\nfunction collect_powers(eq, x, ns; max_power=100)\n    eq = substitute(expand(eq), Dict(x^j => 0 for j=last(ns)+1:max_power))\n\n    eqs = []\n    for i in ns\n        powers = Dict(x^j => (i==j ? 1 : 0) for j=1:last(ns))\n        push!(eqs, substitute(eq, powers))\n    end\n    eqs\nend\n\nfunction solve_coef(eqs, ps)\n    vals = Dict()\n\n    for i = 1:length(ps)\n        eq = substitute(eqs[i], vals)\n        vals[ps[i]] = Symbolics.solve_for(eq ~ 0, ps[i])\n    end\n    vals\nend","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"solve_coef (generic function with 1 method)","category":"page"},{"location":"perturbation/02-perturbation_differential/#The-Trajectory-of-a-Ball!","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"The Trajectory of a Ball!","text":"","category":"section"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"In the first two examples, we applied the perturbation method to algebraic problems. However, the main power of the perturbation method is to solve differential equations (usually ODEs, but also occasionally PDEs). Surprisingly, the main procedure developed to solve algebraic problems works well for differential equations. In fact, we will use the same two helper functions, collect_powers and solve_coef. The main difference is in the way we expand the dependent variables. For algebraic problems, the coefficients of epsilon are constants; whereas, for differential equations, they are functions of the dependent variable (usually time).","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"As the first ODE example, we have chosen a simple and well-behaved problem, which is a variation of a standard first-year physics problem: what is the trajectory of an object (say, a ball or a rocket) thrown vertically at velocity v from the surface of a planet? Assuming a constant acceleration of gravity, g, every burgeoning physicist knows the answer: x(t) = x(0) + vt - frac12gt^2. However, what happens if g is not constant? Specifically, g is inversely proportional to the distant from the center of the planet. If v is large and the projectile travels a large fraction of the radius of the planet, the assumption of constant gravity does not hold anymore. However, unless v is large compared to the escape velocity, the correction is usually small. After simplifications and change of variables to dimensionless, the problem becomes","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"$","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"\\ddot{x}(t) = -\\frac{1}{(1 + \\epsilon x(t))^2}   \\,, $","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"with the initial conditions x(0) = 0, and dotx(0) = 1. Note that for epsilon = 0, this equation transforms back to the standard one. Let's start with defining the variables","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"n = 2\n@variables ϵ t y[0:n](t) ∂∂y[0:n]","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"4-element Vector{Any}:\n ϵ\n t\n  Symbolics.Num[y₀(t), y₁(t), y₂(t)]\n  Symbolics.Num[∂∂y₀, ∂∂y₁, ∂∂y₂]","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"Next, we define x.","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"x = def_taylor(ϵ, y[2:end], y[1])","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"y₀(t) + ϵ*y₁(t) + y₂(t)*(ϵ^2)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"We need the second derivative of x. It may seem that we can do this using Differential(t); however, this operation needs to wait for a few steps because we need to manipulate the differentials as separate variables. Instead, we define dummy variables ∂∂y as the placeholder for the second derivatives and define","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"∂∂x = def_taylor(ϵ, ∂∂y[2:end], ∂∂y[1])","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"∂∂y₀ + ϵ*∂∂y₁ + ∂∂y₂*(ϵ^2)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"as the second derivative of x. After rearrangement, our governing equation is ddotx(t)(1 + epsilon x(t))^-2 + 1 = 0, or","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"eq = ∂∂x * (1 + ϵ*x)^2 + 1","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"1 + (∂∂y₀ + ϵ*∂∂y₁ + ∂∂y₂*(ϵ^2))*((1 + ϵ*(y₀(t) + ϵ*y₁(t) + y₂(t)*(ϵ^2)))^2\n)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"The next two steps are the same as the ones for algebraic equations (note that we pass 0:n to collect_powers because the zeroth order term is needed here)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"eqs = collect_powers(eq, ϵ, 0:n)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"3-element Vector{Any}:\n                                                     1 + ∂∂y₀\n                                1 + ∂∂y₀ + ∂∂y₁ + 2∂∂y₀*y₀(t)\n 1 + ∂∂y₀ + ∂∂y₂ + ∂∂y₀*(y₀(t)^2) + 2∂∂y₀*y₁(t) + 2∂∂y₁*y₀(t)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"and,","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"vals = solve_coef(eqs, ∂∂y)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"Dict{Any, Any} with 3 entries:\n  ∂∂y₁ => 2.0y₀(t)\n  ∂∂y₂ => 2.0y₁(t) - (3.0(y₀(t)^2))\n  ∂∂y₀ => -1.0","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"Our system of ODEs is forming. Now is the time to convert ∂∂s to the correct Symbolics.jl form by substitution:","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"D = Differential(t)\nsubs = Dict(∂∂y[i] => D(D(y[i])) for i in eachindex(y))\neqs = [substitute(first(v), subs) ~ substitute(last(v), subs) for v in vals]","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"3-element Vector{Symbolics.Equation}:\n Differential(t)(Differential(t)(y₁(t))) ~ 2.0y₀(t)\n Differential(t)(Differential(t)(y₂(t))) ~ 2.0y₁(t) - (3.0(y₀(t)^2))\n Differential(t)(Differential(t)(y₀(t))) ~ -1.0","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"We are nearly there! From this point on, the rest is standard ODE solving procedures. Potentially we can use a symbolic ODE solver to find a closed form solution to this problem. However, Symbolics.jl currently does not support this functionality. Instead, we solve the problem numerically. We form an ODESystem, lower the order (convert second derivatives to first), generate an ODEProblem (after passing the correct initial conditions), and, finally, solve it.","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"using ModelingToolkit, DifferentialEquations\n\nsys = ODESystem(eqs, t)\nsys = ode_order_lowering(sys)\nstates(sys)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"6-element Vector{Any}:\n y₁ˍt(t)\n y₂ˍt(t)\n y₀ˍt(t)\n y₁(t)\n y₂(t)\n y₀(t)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"# the initial conditions\n# everything is zero except the initial velocity\nu0 = zeros(2n+2)\nu0[3] = 1.0   # y₀ˍt\n\nprob = ODEProblem(sys, u0, (0, 3.0))\nsol = solve(prob; dtmax=0.01)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"retcode: Success\nInterpolation: automatic order switching interpolation\nt: 302-element Vector{Float64}:\n 0.0\n 0.0009990005004983772\n 0.010989005505482149\n 0.020989005505482147\n 0.03098900550548215\n 0.04098900550548215\n 0.05098900550548215\n 0.060989005505482155\n 0.07098900550548215\n 0.08098900550548215\n ⋮\n 2.920989005505464\n 2.930989005505464\n 2.9409890055054637\n 2.9509890055054635\n 2.9609890055054633\n 2.970989005505463\n 2.980989005505463\n 2.9909890055054627\n 3.0\nu: 302-element Vector{Vector{Float64}}:\n [0.0, 0.0, 1.0, 0.0, 0.0, 0.0]\n [9.976696651635089e-7, -9.96091672587352e-10, 0.9990009994995016, 3.322518\n3183212947e-10, -2.488196097577267e-13, 0.0009985014994983792]\n [0.00012031590433746151, -1.313675024660254e-6, 0.9890109944945178, 4.4112\n24493041101e-7, -3.6163136458534604e-9, 0.010928626384482389]\n [0.00043745619814322776, -9.069307488622044e-6, 0.9790109944945178, 3.0659\n81129291793e-6, -4.777432914805544e-8, 0.02076873632942756]\n [0.0009503986908478969, -2.891919290301644e-5, 0.9690109944945178, 9.84292\n0408498354e-6, -2.253405719858556e-7, 0.030508846274372736]\n [0.0016571433824514696, -6.62992778592017e-5, 0.9590109944945178, 2.271996\n227591275e-5, -6.846158733026939e-7, 0.04014895621931791]\n [0.0025556902729539453, -0.0001264323265297471, 0.9490109944945178, 4.3625\n12872052407e-5, -1.6271927847283168e-6, 0.04968906616426308]\n [0.0036440393623553254, -0.0002143301206684335, 0.9390109944945177, 7.4466\n44173132131e-5, -3.3058347541908906e-6, 0.05912917610920825]\n [0.004920190650655609, -0.0003347956596102526, 0.9290109944945177, 0.00011\n713192329729352, -6.022377301729108e-6, 0.06846928605415342]\n [0.006382144137854795, -0.0004924253602714071, 0.9190109944945177, 0.00017\n348959540742975, -1.0125651195304294e-5, 0.0777093959990986]\n ⋮\n [0.22471192394104525, 2.8247253103418704, -1.9209890055054843, 2.240961476\n3951557, 1.8060647625748494, -1.3450993796364734]\n [0.1976175041144319, 2.814507114834879, -1.9309890055054844, 2.24307344453\n3601, 1.8342621940922712, -1.3643592696915283]\n [0.17013688648671746, 2.8027476697776446, -1.9409890055054844, 2.244912539\n151441, 1.8623497674202474, -1.3837191597465832]\n [0.14226807105790193, 2.789410746307444, -1.9509890055054844, 2.2464748882\n70665, 1.8903118892738933, -1.403179049801638]\n [0.11400905782798529, 2.7744596885439723, -1.9609890055054844, 2.247756599\n913262, 1.9181326019464422, -1.422738939856693]\n [0.08535784679696758, 2.757857411389343, -1.9709890055054844, 2.2487537621\n01221, 1.94579557902807, -1.4423988299117478]\n [0.05631243796484875, 2.7395663983280887, -1.9809890055054844, 2.249462442\n856531, 1.9732841211027194, -1.4621587199668027]\n [0.026870831331628833, 2.7195486992271602, -1.9909890055054844, 2.24987869\n0201181, 2.000581151422923, -1.4820186100218575]\n [-6.521976042861373e-14, 2.6999999999999384, -2.0000000000000218, 2.249999\n999999993, 2.024999999999945, -1.5000000000000422]","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"Finally, we calculate the solution to the problem as a function of ϵ by substituting the solution to the ODE system back into the defining equation for x. Note that 𝜀 is a number, compared to ϵ, which is a symbolic variable.","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"X = 𝜀 -> sum([𝜀^(i-1) * sol[y[i]] for i in eachindex(y)])","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"#16 (generic function with 1 method)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"Using X, we can plot the trajectory for a range of 𝜀s.","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"using Plots\n\nplot(sol.t, hcat([X(𝜀) for 𝜀 = 0.0:0.1:0.5]...))","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"(Image: )","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"As expected, as 𝜀 becomes larger (meaning the gravity is less with altitude), the object goes higher and stays up for a longer duration. Of course, we could have solved the problem directly using as ODE solver. One of the benefits of the perturbation method is that we need to run the ODE solver only once and then can just calculate the answer for different values of 𝜀; whereas, if we had used the direct method, we would need to run the solver once for each value of 𝜀.","category":"page"},{"location":"perturbation/02-perturbation_differential/#A-Weakly-Nonlinear-Oscillator","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"A Weakly Nonlinear Oscillator","text":"","category":"section"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"For the next example, we have chosen a simple example from a very important class of problems, the nonlinear oscillators. As we will see, perturbation theory has difficulty providing a good solution to this problem, but the process is instructive. This example closely follows the chapter 7.6 of Nonlinear Dynamics and Chaos by Steven Strogatz.","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"The goal is to solve ddotx + 2epsilondotx + x = 0, where the dot signifies time-derivatives and the initial conditions are x(0) = 0 and dotx(0) = 1. If epsilon = 0, the problem reduces to the simple linear harmonic oscillator with the exact solution x(t) = sin(t). We follow the same steps as the previous example.","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"n = 2\n@variables ϵ t y[0:n](t) ∂y[0:n] ∂∂y[0:n]\nx = def_taylor(ϵ, y[2:end], y[1])\n∂x = def_taylor(ϵ, ∂y[2:end], ∂y[1])\n∂∂x = def_taylor(ϵ, ∂∂y[2:end], ∂∂y[1])","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"∂∂y₀ + ϵ*∂∂y₁ + ∂∂y₂*(ϵ^2)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"This time we also need the first derivative terms. Continuing,","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"eq = ∂∂x + 2*ϵ*∂x + x\neqs = collect_powers(eq, ϵ, 0:n)\nvals = solve_coef(eqs, ∂∂y)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"Dict{Any, Any} with 3 entries:\n  ∂∂y₁ => -2.0∂y₀ - y₁(t)\n  ∂∂y₂ => -2.0∂y₁ - y₂(t)\n  ∂∂y₀ => -y₀(t)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"Next, we need to replace ∂s and ∂∂s with their Symbolics.jl counterparts:","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"D = Differential(t)\nsubs1 = Dict(∂y[i] => D(y[i]) for i in eachindex(y))\nsubs2 = Dict(∂∂y[i] => D(D(y[i])) for i in eachindex(y))\nsubs = subs1 ∪ subs2\neqs = [substitute(first(v), subs) ~ substitute(last(v), subs) for v in vals]","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"3-element Vector{Symbolics.Equation}:\n Differential(t)(Differential(t)(y₁(t))) ~ -y₁(t) - (2.0Differential(t)(y₀(\nt)))\n Differential(t)(Differential(t)(y₂(t))) ~ -y₂(t) - (2.0Differential(t)(y₁(\nt)))\n Differential(t)(Differential(t)(y₀(t))) ~ -y₀(t)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"We continue with converting 'eqs' to an ODEProblem, solving it, and finally plot the results against the exact solution to the original problem, which is x(t epsilon) = (1 - epsilon)^-12 e^-epsilon t sin((1- epsilon^2)^12t),","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"sys = ODESystem(eqs, t)\nsys = ode_order_lowering(sys)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"Model ##ODESystem#8559 with 6 equations\nStates (6):\n  y₁ˍt(t)\n  y₂ˍt(t)\n  y₀ˍt(t)\n  y₁(t)\n⋮\nParameters (0):","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"# the initial conditions\nu0 = zeros(2n+2)\nu0[3] = 1.0   # y₀ˍt\n\nprob = ODEProblem(sys, u0, (0, 50.0))\nsol = solve(prob; dtmax=0.01)\n\nX = 𝜀 -> sum([𝜀^(i-1) * sol[y[i]] for i in eachindex(y)])\nT = sol.t\nY = 𝜀 -> exp.(-𝜀*T) .* sin.(sqrt(1 - 𝜀^2)*T) / sqrt(1 - 𝜀^2)    # exact solution\n\nplot(sol.t, [Y(0.1), X(0.1)])","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"(Image: )","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"The figure is similar to Figure 7.6.2 in Nonlinear Dynamics and Chaos. The two curves fit well for the first couple of cycles, but then the perturbation method curve diverges from the true solution. The main reason is that the problem has two or more time-scales that introduce secular terms in the solution. One solution is to explicitly account for the two time scales and use an analytic method called two-timing.","category":"page"},{"location":"perturbation/02-perturbation_differential/#Appendix","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Appendix","text":"","category":"section"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"tutorials/perturbation\",\"02-perturbation_differential.jmd\")","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"Computer Information:","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"Julia Version 1.6.2\nCommit 1b93d53fc4 (2021-07-14 15:36 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, znver2)\nEnvironment:\n  JULIA_DEPOT_PATH = /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n  JULIA_NUM_THREADS = 16\n","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"Package Information:","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"      Status `/var/lib/buildkite-agent/builds/2-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/perturbation/Project.toml`\n  [0c46a032] DifferentialEquations v6.17.1\n  [961ee093] ModelingToolkit v5.17.3\n  [91a5bcdd] Plots v1.15.2\n  [30cb0354] SciMLTutorials v0.9.0\n  [d1185830] SymbolicUtils v0.11.2\n  [0c5d862f] Symbolics v0.1.25","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"And the full manifest:","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"      Status `/var/lib/buildkite-agent/builds/2-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/perturbation/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.16.0\n  [1520ce14] AbstractTrees v0.3.4\n  [79e6a3ab] Adapt v3.3.0\n  [ec485272] ArnoldiMethod v0.1.0\n  [4fba245c] ArrayInterface v3.1.15\n  [4c555306] ArrayLayouts v0.7.0\n  [aae01518] BandedMatrices v0.16.9\n  [764a87c0] BoundaryValueDiffEq v2.7.1\n  [fa961155] CEnum v0.4.1\n  [00ebfdb7] CSTParser v2.5.0\n  [d360d2e6] ChainRulesCore v0.9.44\n  [b630d9fa] CheapThreads v0.2.5\n  [35d6a980] ColorSchemes v3.12.1\n  [3da002f7] ColorTypes v0.11.0\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [a80b9123] CommonMark v0.8.1\n  [38540f10] CommonSolve v0.2.0\n  [bbf7d656] CommonSubexpressions v0.3.0\n  [34da2185] Compat v3.30.0\n  [8f4d0f93] Conda v1.5.2\n  [187b0558] ConstructionBase v1.2.1\n  [d38c429a] Contour v0.5.7\n  [a8cc5b0e] Crayons v4.0.4\n  [9a962f9c] DataAPI v1.6.0\n  [864edb3b] DataStructures v0.18.9\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [bcd4f6db] DelayDiffEq v5.31.0\n  [2b5f629d] DiffEqBase v6.62.2\n  [459566f4] DiffEqCallbacks v2.16.1\n  [5a0ffddc] DiffEqFinancial v2.4.0\n  [c894b116] DiffEqJump v6.14.2\n  [77a26b50] DiffEqNoiseProcess v5.7.3\n  [055956cb] DiffEqPhysics v3.9.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.0.2\n  [0c46a032] DifferentialEquations v6.17.1\n  [c619ae07] DimensionalPlotRecipes v1.2.0\n  [b4f34e82] Distances v0.10.3\n  [31c24e10] Distributions v0.24.18\n  [ffbed154] DocStringExtensions v0.8.4\n  [e30172f5] Documenter v0.26.3\n  [d4d017d3] ExponentialUtilities v1.8.4\n  [e2ba6199] ExprTools v0.1.3\n  [c87230d0] FFMPEG v0.4.0\n  [7034ab61] FastBroadcast v0.1.8\n  [9aa1b823] FastClosures v0.3.2\n  [1a297f60] FillArrays v0.11.7\n  [6a86dc24] FiniteDiff v2.8.0\n  [53c48c17] FixedPointNumbers v0.8.4\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.18\n  [069b7b12] FunctionWrappers v1.1.2\n  [28b8d3ca] GR v0.57.4\n  [5c1252a2] GeometryBasics v0.3.12\n  [42e2da0e] Grisu v1.0.2\n  [cd3eb016] HTTP v0.9.9\n  [eafb193a] Highlights v0.4.5\n  [0e44f5e4] Hwloc v2.0.0\n  [7073ff75] IJulia v1.23.2\n  [b5f81e59] IOCapture v0.1.1\n  [615f187c] IfElse v0.1.0\n  [d25df0c9] Inflate v0.1.2\n  [83e8ac13] IniFile v0.5.0\n  [c8e1da08] IterTools v1.3.0\n  [42fd0dbc] IterativeSolvers v0.9.1\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.3.0\n  [682c06a0] JSON v0.21.1\n  [98e50ef6] JuliaFormatter v0.13.7\n  [b964fa9f] LaTeXStrings v1.2.1\n  [2ee39098] LabelledArrays v1.6.1\n  [23fbe1c1] Latexify v0.15.5\n  [093fc24a] LightGraphs v1.3.5\n  [d3d80556] LineSearches v7.1.1\n  [2ab3a3ac] LogExpFunctions v0.2.4\n  [bdcacae8] LoopVectorization v0.12.23\n  [1914dd2f] MacroTools v0.5.6\n  [739be429] MbedTLS v1.0.3\n  [442fdcdd] Measures v0.3.1\n  [e1d29d7a] Missings v1.0.0\n  [961ee093] ModelingToolkit v5.17.3\n  [46d2c3a1] MuladdMacro v0.2.2\n  [f9640e96] MultiScaleArrays v1.8.1\n  [ffc61752] Mustache v1.0.10\n  [d41bc354] NLSolversBase v7.8.0\n  [2774e3e8] NLsolve v4.5.1\n  [77ba4419] NaNMath v0.3.5\n  [8913a72c] NonlinearSolve v0.3.8\n  [6fe1bfb0] OffsetArrays v1.9.0\n  [429524aa] Optim v1.3.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [90014a1f] PDMats v0.11.0\n  [65888b18] ParameterizedFunctions v5.10.0\n  [d96e819e] Parameters v0.12.2\n  [69de0a69] Parsers v1.1.0\n  [ccf2f8ad] PlotThemes v2.0.1\n  [995b91a9] PlotUtils v1.0.10\n  [91a5bcdd] Plots v1.15.2\n  [e409e4f3] PoissonRandom v0.4.0\n  [f517fe37] Polyester v0.3.1\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [21216c6a] Preferences v1.2.2\n  [1fd47b50] QuadGK v2.4.1\n  [74087812] Random123 v1.3.1\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.4.0\n  [3cdcf5f2] RecipesBase v1.1.1\n  [01d81517] RecipesPipeline v0.3.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [f2c3362d] RecursiveFactorization v0.1.12\n  [189a3867] Reexport v1.0.0\n  [ae029012] Requires v1.1.3\n  [ae5879a3] ResettableStacks v1.1.0\n  [79098fc4] Rmath v0.7.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.2\n  [476501e8] SLEEFPirates v0.6.20\n  [1bc83da4] SafeTestsets v0.0.1\n  [0bca4576] SciMLBase v1.13.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [6c6a2e73] Scratch v1.0.3\n  [efcf1570] Setfield v0.7.0\n  [992d4aef] Showoff v1.0.3\n  [699a6c99] SimpleTraits v0.9.3\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.0\n  [47a9eef4] SparseDiffTools v1.13.2\n  [276daf66] SpecialFunctions v1.4.1\n  [aedffcd0] Static v0.2.4\n  [90137ffa] StaticArrays v1.2.0\n  [82ae8749] StatsAPI v1.0.0\n  [2913bbd2] StatsBase v0.33.8\n  [4c63d2b9] StatsFuns v0.9.8\n  [9672c7b4] SteadyStateDiffEq v1.6.2\n  [789caeaf] StochasticDiffEq v6.34.1\n  [7792a7ef] StrideArraysCore v0.1.11\n  [09ab397b] StructArrays v0.5.1\n  [c3572dad] Sundials v4.4.3\n  [d1185830] SymbolicUtils v0.11.2\n  [0c5d862f] Symbolics v0.1.25\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.4.2\n  [8290d209] ThreadingUtilities v0.4.4\n  [a759f4b9] TimerOutputs v0.5.9\n  [0796e94c] Tokenize v0.5.16\n  [a2a6695c] TreeViews v0.3.0\n  [5c2747f8] URIs v1.3.0\n  [3a884ed6] UnPack v1.0.2\n  [1986cc42] Unitful v1.7.0\n  [3d5dd08c] VectorizationBase v0.20.11\n  [81def892] VersionParsing v1.2.0\n  [19fa3120] VertexSafeGraphs v0.1.2\n  [44d3d7a6] Weave v0.10.8\n  [ddb6d928] YAML v0.4.6\n  [c2297ded] ZMQ v1.2.1\n  [700de1a5] ZygoteRules v0.2.1\n  [6e34b625] Bzip2_jll v1.0.6+5\n  [83423d85] Cairo_jll v1.16.0+6\n  [5ae413db] EarCut_jll v2.1.5+1\n  [2e619515] Expat_jll v2.2.10+0\n  [b22a6f82] FFMPEG_jll v4.3.1+4\n  [a3f928ae] Fontconfig_jll v2.13.1+14\n  [d7e528f0] FreeType2_jll v2.10.1+5\n  [559328eb] FriBidi_jll v1.0.5+6\n  [0656b61e] GLFW_jll v3.3.4+0\n  [d2c73de3] GR_jll v0.57.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.1+0\n  [e33a78d0] Hwloc_jll v2.4.1+0\n  [aacddb02] JpegTurbo_jll v2.0.1+3\n  [c1c5ebd0] LAME_jll v3.100.0+3\n  [dd4b983a] LZO_jll v2.10.1+0\n  [dd192d2f] LibVPX_jll v1.9.0+1\n  [e9f186c6] Libffi_jll v3.2.2+0\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+0\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.1.0+2\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [e7412a2a] Ogg_jll v1.3.4+2\n  [458c3c95] OpenSSL_jll v1.1.1+6\n  [efe28fd5] OpenSpecFun_jll v0.5.4+0\n  [91d4177d] Opus_jll v1.3.1+3\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.2+0\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.0+1\n  [a2964d1f] Wayland_jll v1.17.0+4\n  [2381bf8a] Wayland_protocols_jll v1.18.0+4\n  [02c8fc9c] XML2_jll v2.9.12+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.2+6\n  [3161d3a3] Zstd_jll v1.5.0+0\n  [0ac62f75] libass_jll v0.14.0+4\n  [f638f0a6] libfdk_aac_jll v0.1.6+4\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.6+6\n  [1270edf5] x264_jll v2020.7.14+2\n  [dfaa095f] x265_jll v3.0.0+3\n  [d8fb68d0] xkbcommon_jll v0.9.1+5\n  [0dad84c5] ArgTools\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [b27032c2] LibCURL\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions\n  [44cfe95a] Pkg\n  [de0858da] Printf\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML\n  [a4e569a6] Tar\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll\n  [deac9b47] LibCURL_jll\n  [29816b5a] LibSSH2_jll\n  [c8ffd9c3] MbedTLS_jll\n  [14a3606d] MozillaCACerts_jll\n  [4536629a] OpenBLAS_jll\n  [bea87d4a] SuiteSparse_jll\n  [83775a58] Zlib_jll\n  [8e850ede] nghttp2_jll\n  [3f19e933] p7zip_jll","category":"page"},{"location":"type_handling/02-uncertainties/#Numbers-with-Uncertainties","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"","category":"section"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"The result of a measurement should be given as a number with an attached uncertainties, besides the physical unit, and all operations performed involving the result of the measurement should propagate the uncertainty, taking care of correlation between quantities.","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"There is a Julia package for dealing with numbers with uncertainties: Measurements.jl.  Thanks to Julia's features, DifferentialEquations.jl easily works together with Measurements.jl out-of-the-box.","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"This notebook will cover some of the examples from the tutorial about classical Physics.","category":"page"},{"location":"type_handling/02-uncertainties/#Caveat-about-Measurement-type","page":"Numbers with Uncertainties","title":"Caveat about Measurement type","text":"","category":"section"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"Before going on with the tutorial, we must point up a subtlety of Measurements.jl that you should be aware of:","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"\nusing Measurements\n\n5.23 ± 0.14 === 5.23 ± 0.14","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"false","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"\n(5.23± 0.14) - (5.23 ± 0.14)","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"0.0 ± 0.2","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"\n(5.23 ± 0.14) / (5.23 ± 0.14)","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"1.0 ± 0.038","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"The two numbers above, even though have the same nominal value and the same uncertainties, are actually two different measurements that only by chance share the same figures and their difference and their ratio have a non-zero uncertainty.  It is common in physics to get very similar, or even equal, results for a repeated measurement, but the two measurements are not the same thing.","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"Instead, if you have one measurement and want to perform some operations involving it, you have to assign it to a variable:","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"\nx = 5.23 ± 0.14\nx === x","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"true","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"\nx - x","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"0.0 ± 0.0","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"\nx / x","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"1.0 ± 0.0","category":"page"},{"location":"type_handling/02-uncertainties/#Radioactive-Decay-of-Carbon-14","page":"Numbers with Uncertainties","title":"Radioactive Decay of Carbon-14","text":"","category":"section"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"The rate of decay of carbon-14 is governed by a first order linear ordinary differential equation","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"fracmathrmdu(t)mathrmdt = -fracu(t)tau","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"where tau is the mean lifetime of carbon-14, which is related to the half-life t_12 = (5730 pm 40) years by the relation tau = t_12ln(2).","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"\nusing DifferentialEquations, Measurements, Plots\n\n# Half-life and mean lifetime of radiocarbon, in years\nt_12 = 5730 ± 40\nτ = t_12 / log(2)\n\n#Setup\nu₀ = 1 ± 0\ntspan = (0.0, 10000.0)\n\n#Define the problem\nradioactivedecay(u,p,t) = - u / τ\n\n#Pass to solver\nprob = ODEProblem(radioactivedecay, u₀, tspan)\nsol = solve(prob, Tsit5(), reltol = 1e-8)\n\n# Analytic solution\nu = exp.(- sol.t / τ)\n\nplot(sol.t, sol.u, label = \"Numerical\", xlabel = \"Years\", ylabel = \"Fraction of Carbon-14\")\nplot!(sol.t, u, label = \"Analytic\")","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"(Image: )","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"The two curves are perfectly superimposed, indicating that the numerical solution matches the analytic one.  We can check that also the uncertainties are correctly propagated in the numerical solution:","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"\nprintln(\"Quantity of carbon-14 after \",  sol.t[11], \" years:\")\nprintln(\"Numerical: \", sol[11])\nprintln(\"Analytic:  \", u[11])","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"Quantity of carbon-14 after 5207.541347908455 years:\nNumerical: 0.5326 ± 0.0023\nAnalytic:  0.5326 ± 0.0023","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"Both the value of the numerical solution and its uncertainty match the analytic solution within the requested tolerance.  We can also note that close to 5730 years after the beginning of the decay (half-life of the radioisotope), the fraction of carbon-14 that survived is about 0.5.","category":"page"},{"location":"type_handling/02-uncertainties/#Simple-pendulum","page":"Numbers with Uncertainties","title":"Simple pendulum","text":"","category":"section"},{"location":"type_handling/02-uncertainties/#Small-angles-approximation","page":"Numbers with Uncertainties","title":"Small angles approximation","text":"","category":"section"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"The next problem we are going to study is the simple pendulum in the approximation of small angles.  We address this simplified case because there exists an easy analytic solution to compare.","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"The differential equation we want to solve is","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"ddottheta + fracgL theta = 0","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"where g = (979 pm 002)mathrmmmathrms^2 is the gravitational acceleration measured where the experiment is carried out, and L = (100 pm 001)mathrmm is the length of the pendulum.","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"When you set up the problem for DifferentialEquations.jl remember to define the measurements as variables, as seen above.","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"\nusing DifferentialEquations, Measurements, Plots\n\ng = 9.79 ± 0.02; # Gravitational constants\nL = 1.00 ± 0.01; # Length of the pendulum\n\n#Initial Conditions\nu₀ = [0 ± 0, π / 60 ± 0.01] # Initial speed and initial angle\ntspan = (0.0, 6.3)\n\n#Define the problem\nfunction simplependulum(du,u,p,t)\n    θ  = u[1]\n    dθ = u[2]\n    du[1] = dθ\n    du[2] = -(g/L)*θ\nend\n\n#Pass to solvers\nprob = ODEProblem(simplependulum, u₀, tspan)\nsol = solve(prob, Tsit5(), reltol = 1e-6)\n\n# Analytic solution\nu = u₀[2] .* cos.(sqrt(g / L) .* sol.t)\n\nplot(sol.t, getindex.(sol.u, 2), label = \"Numerical\")\nplot!(sol.t, u, label = \"Analytic\")","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"(Image: )","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"Also in this case there is a perfect superimposition between the two curves, including their uncertainties.","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"We can also have a look at the difference between the two solutions:","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"\nplot(sol.t, getindex.(sol.u, 2) .- u, label = \"\")","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"(Image: )","category":"page"},{"location":"type_handling/02-uncertainties/#Arbitrary-amplitude","page":"Numbers with Uncertainties","title":"Arbitrary amplitude","text":"","category":"section"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"Now that we know how to solve differential equations involving numbers with uncertainties we can solve the simple pendulum problem without any approximation.  This time the differential equation to solve is the following:","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"ddottheta + fracgL sin(theta) = 0","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"\ng = 9.79 ± 0.02; # Gravitational constants\nL = 1.00 ± 0.01; # Length of the pendulum\n\n#Initial Conditions\nu₀ = [0 ± 0, π / 3 ± 0.02] # Initial speed and initial angle\ntspan = (0.0, 6.3)\n\n#Define the problem\nfunction simplependulum(du,u,p,t)\n    θ  = u[1]\n    dθ = u[2]\n    du[1] = dθ\n    du[2] = -(g/L) * sin(θ)\nend\n\n#Pass to solvers\nprob = ODEProblem(simplependulum, u₀, tspan)\nsol = solve(prob, Tsit5(), reltol = 1e-6)\n\nplot(sol.t, getindex.(sol.u, 2), label = \"Numerical\")","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"(Image: )","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"We note that in this case the period of the oscillations is not constant.","category":"page"},{"location":"type_handling/02-uncertainties/#Appendix","page":"Numbers with Uncertainties","title":"Appendix","text":"","category":"section"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"This tutorial is part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl.  For more information on doing scientific machine learning (SciML) with open source software, check out https://sciml.ai/.","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"type_handling\",\"02-uncertainties.jmd\")","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"Computer Information:","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"Julia Version 1.4.2\nCommit 44fa15b150* (2020-05-23 18:35 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Core(TM) i7-9700K CPU @ 3.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-8.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_LOAD_PATH = /builds/JuliaGPU/DiffEqTutorials.jl:\n  JULIA_DEPOT_PATH = /builds/JuliaGPU/DiffEqTutorials.jl/.julia\n  JULIA_CUDA_MEMORY_LIMIT = 2147483648\n  JULIA_NUM_THREADS = 8\n","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"Package Information:","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"Status `/builds/JuliaGPU/DiffEqTutorials.jl/tutorials/type_handling/Project.toml`\n[7e558dbc-694d-5a72-987c-6f4ebed21442] ArbNumerics 1.2.1\n[55939f99-70c6-5e9b-8bb0-5071ed7d61fd] DecFP 1.0.0\n[abce61dc-4473-55a0-ba07-351d65e31d42] Decimals 0.4.1\n[0c46a032-eb83-5123-abaf-570d42b7fbaa] DifferentialEquations 6.15.0\n[497a8b3b-efae-58df-a0af-a86822472b78] DoubleFloats 1.1.13\n[eff96d63-e80a-5855-80a2-b1b0885c5ab7] Measurements 2.2.1\n[1dea7af3-3e70-54e6-95c3-0bf5283fa5ed] OrdinaryDiffEq 5.42.5\n[91a5bcdd-55d7-5caf-9e0b-520d859cae80] Plots 1.6.1\n[1986cc42-f94f-5a68-af5c-568840ba703d] Unitful 1.4.0","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/#Optimizing-DiffEq-Code","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"","category":"section"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"In this notebook we will walk through some of the main tools for optimizing your code in order to efficiently solve DifferentialEquations.jl. User-side optimizations are important because, for sufficiently difficult problems, most of the time will be spent inside of your f function, the function you are trying to solve. \"Efficient\" integrators are those that reduce the required number of f calls to hit the error tolerance. The main ideas for optimizing your DiffEq code, or any Julia function, are the following:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Make it non-allocating\nUse StaticArrays for small arrays\nUse broadcast fusion\nMake it type-stable\nReduce redundant calculations\nMake use of BLAS calls\nOptimize algorithm choice","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"We'll discuss these strategies in the context of small and large systems. Let's start with small systems.","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/#Optimizing-Small-Systems-(100-DEs)","page":"Optimizing DiffEq Code","title":"Optimizing Small Systems (<100 DEs)","text":"","category":"section"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Let's take the classic Lorenz system from before. Let's start by naively writing the system in its out-of-place form:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"function lorenz(u,p,t)\n dx = 10.0*(u[2]-u[1])\n dy = u[1]*(28.0-u[3]) - u[2]\n dz = u[1]*u[2] - (8/3)*u[3]\n [dx,dy,dz]\nend","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"lorenz (generic function with 1 method)","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Here, lorenz returns an object, [dx,dy,dz], which is created within the body of lorenz.","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"This is a common code pattern from high-level languages like MATLAB, SciPy, or R's deSolve. However, the issue with this form is that it allocates a vector, [dx,dy,dz], at each step. Let's benchmark the solution process with this choice of function:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"using DifferentialEquations, BenchmarkTools\nu0 = [1.0;0.0;0.0]\ntspan = (0.0,100.0)\nprob = ODEProblem(lorenz,u0,tspan)\n@benchmark solve(prob,Tsit5())","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  10.81 MiB\n  allocs estimate:  100152\n  --------------\n  minimum time:     3.728 ms (0.00% GC)\n  median time:      3.907 ms (0.00% GC)\n  mean time:        5.229 ms (16.67% GC)\n  maximum time:     12.230 ms (48.68% GC)\n  --------------\n  samples:          954\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"The BenchmarkTools.jl package's @benchmark runs the code multiple times to get an accurate measurement. The minimum time is the time it takes when your OS and other background processes aren't getting in the way. Notice that in this case it takes about 5ms to solve and allocates around 11.11 MiB. However, if we were to use this inside of a real user code we'd see a lot of time spent doing garbage collection (GC) to clean up all of the arrays we made. Even if we turn off saving we have these allocations.","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"@benchmark solve(prob,Tsit5(),save_everystep=false)","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  9.47 MiB\n  allocs estimate:  88645\n  --------------\n  minimum time:     3.258 ms (0.00% GC)\n  median time:      3.403 ms (0.00% GC)\n  mean time:        4.713 ms (15.87% GC)\n  maximum time:     11.250 ms (51.35% GC)\n  --------------\n  samples:          1058\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"The problem of course is that arrays are created every time our derivative function is called. This function is called multiple times per step and is thus the main source of memory usage. To fix this, we can use the in-place form to ***make our code non-allocating***:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"function lorenz!(du,u,p,t)\n du[1] = 10.0*(u[2]-u[1])\n du[2] = u[1]*(28.0-u[3]) - u[2]\n du[3] = u[1]*u[2] - (8/3)*u[3]\nend","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"lorenz! (generic function with 1 method)","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Here, instead of creating an array each time, we utilized the cache array du. When the inplace form is used, DifferentialEquations.jl takes a different internal route that minimizes the internal allocations as well. When we benchmark this function, we will see quite a difference.","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"u0 = [1.0;0.0;0.0]\ntspan = (0.0,100.0)\nprob = ODEProblem(lorenz!,u0,tspan)\n@benchmark solve(prob,Tsit5())","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  1.37 MiB\n  allocs estimate:  11752\n  --------------\n  minimum time:     785.371 μs (0.00% GC)\n  median time:      812.961 μs (0.00% GC)\n  mean time:        985.900 μs (10.69% GC)\n  maximum time:     7.160 ms (84.01% GC)\n  --------------\n  samples:          5035\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"@benchmark solve(prob,Tsit5(),save_everystep=false)","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  6.70 KiB\n  allocs estimate:  47\n  --------------\n  minimum time:     347.186 μs (0.00% GC)\n  median time:      365.176 μs (0.00% GC)\n  mean time:        366.737 μs (0.19% GC)\n  maximum time:     7.273 ms (93.58% GC)\n  --------------\n  samples:          10000\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"There is a 4x time difference just from that change! Notice there are still some allocations and this is due to the construction of the integration cache. But this doesn't scale with the problem size:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"tspan = (0.0,500.0) # 5x longer than before\nprob = ODEProblem(lorenz!,u0,tspan)\n@benchmark solve(prob,Tsit5(),save_everystep=false)","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  6.70 KiB\n  allocs estimate:  47\n  --------------\n  minimum time:     1.741 ms (0.00% GC)\n  median time:      1.823 ms (0.00% GC)\n  mean time:        1.826 ms (0.00% GC)\n  maximum time:     4.381 ms (0.00% GC)\n  --------------\n  samples:          2734\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"since that's all just setup allocations.","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/#But-if-the-system-is-small-we-can-optimize-even-more.","page":"Optimizing DiffEq Code","title":"But if the system is small we can optimize even more.","text":"","category":"section"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Allocations are only expensive if they are \"heap allocations\". For a more in-depth definition of heap allocations, there are a lot of sources online. But a good working definition is that heap allocations are variable-sized slabs of memory which have to be pointed to, and this pointer indirection costs time. Additionally, the heap has to be managed and the garbage controllers has to actively keep track of what's on the heap.","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"However, there's an alternative to heap allocations, known as stack allocations. The stack is statically-sized (known at compile time) and thus its accesses are quick. Additionally, the exact block of memory is known in advance by the compiler, and thus re-using the memory is cheap. This means that allocating on the stack has essentially no cost!","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Arrays have to be heap allocated because their size (and thus the amount of memory they take up) is determined at runtime. But there are structures in Julia which are stack-allocated. structs for example are stack-allocated \"value-type\"s. Tuples are a stack-allocated collection. The most useful data structure for DiffEq though is the StaticArray from the package StaticArrays.jl. These arrays have their length determined at compile-time. They are created using macros attached to normal array expressions, for example:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"using StaticArrays\nA = @SVector [2.0,3.0,5.0]","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n 2.0\n 3.0\n 5.0","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Notice that the 3 after SVector gives the size of the SVector. It cannot be changed. Additionally, SVectors are immutable, so we have to create a new SVector to change values. But remember, we don't have to worry about allocations because this data structure is stack-allocated. SArrays have a lot of extra optimizations as well: they have fast matrix multiplication, fast QR factorizations, etc. which directly make use of the information about the size of the array. Thus, when possible they should be used.","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Unfortunately static arrays can only be used for sufficiently small arrays. After a certain size, they are forced to heap allocate after some instructions and their compile time balloons. Thus static arrays shouldn't be used if your system has more than 100 variables. Additionally, only the native Julia algorithms can fully utilize static arrays.","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Let's ***optimize lorenz using static arrays***. Note that in this case, we want to use the out-of-place allocating form, but this time we want to output a static array:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"function lorenz_static(u,p,t)\n dx = 10.0*(u[2]-u[1])\n dy = u[1]*(28.0-u[3]) - u[2]\n dz = u[1]*u[2] - (8/3)*u[3]\n @SVector [dx,dy,dz]\nend","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"lorenz_static (generic function with 1 method)","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"To make the solver internally use static arrays, we simply give it a static array as the initial condition:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"u0 = @SVector [1.0,0.0,0.0]\ntspan = (0.0,100.0)\nprob = ODEProblem(lorenz_static,u0,tspan)\n@benchmark solve(prob,Tsit5())","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  446.73 KiB\n  allocs estimate:  1314\n  --------------\n  minimum time:     312.937 μs (0.00% GC)\n  median time:      321.726 μs (0.00% GC)\n  mean time:        362.289 μs (6.87% GC)\n  maximum time:     4.703 ms (90.25% GC)\n  --------------\n  samples:          10000\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"@benchmark solve(prob,Tsit5(),save_everystep=false)","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  3.69 KiB\n  allocs estimate:  22\n  --------------\n  minimum time:     195.928 μs (0.00% GC)\n  median time:      200.417 μs (0.00% GC)\n  mean time:        201.350 μs (0.00% GC)\n  maximum time:     2.360 ms (0.00% GC)\n  --------------\n  samples:          10000\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"And that's pretty much all there is to it. With static arrays you don't have to worry about allocating, so use operations like * and don't worry about fusing operations (discussed in the next section). Do \"the vectorized code\" of R/MATLAB/Python and your code in this case will be fast, or directly use the numbers/values.","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/#Exercise-1","page":"Optimizing DiffEq Code","title":"Exercise 1","text":"","category":"section"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Implement the out-of-place array, in-place array, and out-of-place static array forms for the Henon-Heiles System and time the results.","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/#Optimizing-Large-Systems","page":"Optimizing DiffEq Code","title":"Optimizing Large Systems","text":"","category":"section"},{"location":"introduction/03-optimizing_diffeq_code/#Interlude:-Managing-Allocations-with-Broadcast-Fusion","page":"Optimizing DiffEq Code","title":"Interlude: Managing Allocations with Broadcast Fusion","text":"","category":"section"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"When your system is sufficiently large, or you have to make use of a non-native Julia algorithm, you have to make use of Arrays. In order to use arrays in the most efficient manner, you need to be careful about temporary allocations. Vectorized calculations naturally have plenty of temporary array allocations. This is because a vectorized calculation outputs a vector. Thus:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"A = rand(1000,1000); B = rand(1000,1000); C = rand(1000,1000)\ntest(A,B,C) = A + B + C\n@benchmark test(A,B,C)","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  7.63 MiB\n  allocs estimate:  2\n  --------------\n  minimum time:     1.138 ms (0.00% GC)\n  median time:      1.199 ms (0.00% GC)\n  mean time:        1.422 ms (15.68% GC)\n  maximum time:     4.236 ms (68.83% GC)\n  --------------\n  samples:          3416\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"That expression A + B + C creates 2 arrays. It first creates one for the output of A + B, then uses that result array to + C to get the final result. 2 arrays! We don't want that! The first thing to do to fix this is to use broadcast fusion. Broadcast fusion puts expressions together. For example, instead of doing the + operations separately, if we were to add them all at the same time, then we would only have a single array that's created. For example:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"test2(A,B,C) = map((a,b,c)->a+b+c,A,B,C)\n@benchmark test2(A,B,C)","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  7.63 MiB\n  allocs estimate:  2\n  --------------\n  minimum time:     1.115 ms (0.00% GC)\n  median time:      1.270 ms (0.00% GC)\n  mean time:        1.499 ms (14.94% GC)\n  maximum time:     11.002 ms (87.22% GC)\n  --------------\n  samples:          3246\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Puts the whole expression into a single function call, and thus only one array is required to store output. This is the same as writing the loop:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"function test3(A,B,C)\n    D = similar(A)\n    @inbounds for i in eachindex(A)\n        D[i] = A[i] + B[i] + C[i]\n    end\n    D\nend\n@benchmark test3(A,B,C)","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  7.63 MiB\n  allocs estimate:  2\n  --------------\n  minimum time:     1.128 ms (0.00% GC)\n  median time:      1.189 ms (0.00% GC)\n  mean time:        1.413 ms (15.80% GC)\n  maximum time:     8.981 ms (85.54% GC)\n  --------------\n  samples:          3438\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"However, Julia's broadcast is syntactic sugar for this. If multiple expressions have a ., then it will put those vectorized operations together. Thus:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"test4(A,B,C) = A .+ B .+ C\n@benchmark test4(A,B,C)","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  7.63 MiB\n  allocs estimate:  2\n  --------------\n  minimum time:     1.146 ms (0.00% GC)\n  median time:      1.218 ms (0.00% GC)\n  mean time:        1.446 ms (15.51% GC)\n  maximum time:     8.415 ms (0.00% GC)\n  --------------\n  samples:          3364\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"is a version with only 1 array created (the output). Note that .s can be used with function calls as well:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"sin.(A) .+ sin.(B)","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"1000×1000 Matrix{Float64}:\n 1.34331   0.762758  0.516568  1.14551   …  0.452744  1.47316   0.878211\n 0.887864  0.661277  1.404     1.0328       0.645155  0.100469  1.00796\n 1.27274   0.299205  1.03128   1.35565      0.930027  1.19628   1.20852\n 0.704528  1.32344   0.680136  0.517934     1.49058   0.859923  0.246656\n 1.1416    1.35703   0.254302  0.875622     0.701284  0.781185  0.582443\n 0.992836  1.13285   1.24947   0.146146  …  0.352273  0.931487  1.47139\n 0.11975   1.42053   1.37657   1.24092      0.891272  1.38122   0.908705\n 1.52352   1.21047   0.893324  0.706818     1.15031   0.533913  0.534156\n 0.711121  0.263302  1.0779    1.14109      1.13201   0.901775  0.718739\n 0.775379  1.31568   0.444018  0.961753     1.06965   1.2666    0.90849\n ⋮                                       ⋱                      \n 0.769563  1.08549   1.12781   1.11182      0.564123  1.1887    0.791183\n 1.57574   1.27012   0.696321  0.555074     1.5779    1.21551   0.425096\n 0.867393  0.274273  0.948071  1.09895      1.52311   0.990938  0.628522\n 1.12536   0.544798  1.05153   1.12808      1.00095   1.09818   1.10201\n 0.828727  0.404128  0.132428  1.2397    …  0.886239  0.572485  0.658861\n 0.823358  0.726641  0.913932  0.598602     0.629525  1.08699   0.847764\n 0.880183  1.19847   0.061579  0.693321     0.707012  1.00697   0.816413\n 0.819904  0.618589  0.748232  0.746615     1.44275   1.21592   0.672592\n 0.742035  1.20365   1.28885   0.187538     1.07021   1.04767   1.26743","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Also, the @. macro applys a dot to every operator:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"test5(A,B,C) = @. A + B + C #only one array allocated\n@benchmark test5(A,B,C)","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  7.63 MiB\n  allocs estimate:  2\n  --------------\n  minimum time:     1.140 ms (0.00% GC)\n  median time:      1.200 ms (0.00% GC)\n  mean time:        1.424 ms (15.65% GC)\n  maximum time:     4.192 ms (68.98% GC)\n  --------------\n  samples:          3414\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Using these tools we can get rid of our intermediate array allocations for many vectorized function calls. But we are still allocating the output array. To get rid of that allocation, we can instead use mutation. Mutating broadcast is done via .=. For example, if we pre-allocate the output:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"D = zeros(1000,1000);","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Then we can keep re-using this cache for subsequent calculations. The mutating broadcasting form is:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"test6!(D,A,B,C) = D .= A .+ B .+ C #only one array allocated\n@benchmark test6!(D,A,B,C)","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  0 bytes\n  allocs estimate:  0\n  --------------\n  minimum time:     1.145 ms (0.00% GC)\n  median time:      1.157 ms (0.00% GC)\n  mean time:        1.165 ms (0.00% GC)\n  maximum time:     3.190 ms (0.00% GC)\n  --------------\n  samples:          4147\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"If we use @. before the =, then it will turn it into .=:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"test7!(D,A,B,C) = @. D = A + B + C #only one array allocated\n@benchmark test7!(D,A,B,C)","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  0 bytes\n  allocs estimate:  0\n  --------------\n  minimum time:     1.123 ms (0.00% GC)\n  median time:      1.134 ms (0.00% GC)\n  mean time:        1.141 ms (0.00% GC)\n  maximum time:     3.392 ms (0.00% GC)\n  --------------\n  samples:          4233\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Notice that in this case, there is no \"output\", and instead the values inside of D are what are changed (like with the DiffEq inplace function). Many Julia functions have a mutating form which is denoted with a !. For example, the mutating form of the map is map!:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"test8!(D,A,B,C) = map!((a,b,c)->a+b+c,D,A,B,C)\n@benchmark test8!(D,A,B,C)","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  0 bytes\n  allocs estimate:  0\n  --------------\n  minimum time:     2.347 ms (0.00% GC)\n  median time:      2.377 ms (0.00% GC)\n  mean time:        2.383 ms (0.00% GC)\n  maximum time:     4.366 ms (0.00% GC)\n  --------------\n  samples:          2063\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Some operations require using an alternate mutating form in order to be fast. For example, matrix multiplication via * allocates a temporary:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"@benchmark A*B","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  7.63 MiB\n  allocs estimate:  2\n  --------------\n  minimum time:     9.192 ms (0.00% GC)\n  median time:      9.343 ms (0.00% GC)\n  mean time:        9.989 ms (2.82% GC)\n  maximum time:     18.813 ms (25.64% GC)\n  --------------\n  samples:          501\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Instead, we can use the mutating form mul! into a cache array to avoid allocating the output:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"using LinearAlgebra\n@benchmark mul!(D,A,B) # same as D = A * B","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  0 bytes\n  allocs estimate:  0\n  --------------\n  minimum time:     9.313 ms (0.00% GC)\n  median time:      9.366 ms (0.00% GC)\n  mean time:        9.525 ms (0.00% GC)\n  maximum time:     21.216 ms (0.00% GC)\n  --------------\n  samples:          525\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"For repeated calculations this reduced allocation can stop GC cycles and thus lead to more efficient code. Additionally, ***we can fuse together higher level linear algebra operations using BLAS***. The package SugarBLAS.jl makes it easy to write higher level operations like alpha*B*A + beta*C as mutating BLAS calls.","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/#Example-Optimization:-Gierer-Meinhardt-Reaction-Diffusion-PDE-Discretization","page":"Optimizing DiffEq Code","title":"Example Optimization: Gierer-Meinhardt Reaction-Diffusion PDE Discretization","text":"","category":"section"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Let's optimize the solution of a Reaction-Diffusion PDE's discretization. In its discretized form, this is the ODE:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"$","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"\\begin{align} du &= D1 (Ay u + u Ax) + \\frac{au^2}{v} + \\bar{u} - \\alpha u\\\ndv &= D2 (Ay v + v Ax) + a u^2 + \\beta v \\end{align} $","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"where u, v, and A are matrices. Here, we will use the simplified version where A is the tridiagonal stencil 1-21, i.e. it's the 2D discretization of the LaPlacian. The native code would be something along the lines of:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"# Generate the constants\np = (1.0,1.0,1.0,10.0,0.001,100.0) # a,α,ubar,β,D1,D2\nN = 100\nAx = Array(Tridiagonal([1.0 for i in 1:N-1],[-2.0 for i in 1:N],[1.0 for i in 1:N-1]))\nAy = copy(Ax)\nAx[2,1] = 2.0\nAx[end-1,end] = 2.0\nAy[1,2] = 2.0\nAy[end,end-1] = 2.0\n\nfunction basic_version!(dr,r,p,t)\n  a,α,ubar,β,D1,D2 = p\n  u = r[:,:,1]\n  v = r[:,:,2]\n  Du = D1*(Ay*u + u*Ax)\n  Dv = D2*(Ay*v + v*Ax)\n  dr[:,:,1] = Du .+ a.*u.*u./v .+ ubar .- α*u\n  dr[:,:,2] = Dv .+ a.*u.*u .- β*v\nend\n\na,α,ubar,β,D1,D2 = p\nuss = (ubar+β)/α\nvss = (a/β)*uss^2\nr0 = zeros(100,100,2)\nr0[:,:,1] .= uss.+0.1.*rand.()\nr0[:,:,2] .= vss\n\nprob = ODEProblem(basic_version!,r0,(0.0,0.1),p)","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"ODEProblem with uType Array{Float64, 3} and tType Float64. In-place: true\ntimespan: (0.0, 0.1)\nu0: 100×100×2 Array{Float64, 3}:\n[:, :, 1] =\n 11.066   11.036   11.0879  11.0733  …  11.0377  11.0773  11.0246  11.0735\n 11.0147  11.0852  11.0314  11.0503     11.011   11.0504  11.0223  11.0679\n 11.0337  11.0496  11.0141  11.0437     11.0616  11.0537  11.0128  11.0428\n 11.0167  11.0055  11.0946  11.0375     11.0311  11.0771  11.073   11.078\n 11.0526  11.0928  11.0816  11.0847     11.0057  11.0473  11.0008  11.0012\n 11.0113  11.0845  11.0288  11.0351  …  11.0337  11.0183  11.0239  11.0181\n 11.0693  11.016   11.0544  11.0635     11.0796  11.0773  11.0768  11.0885\n 11.0511  11.0516  11.0165  11.0833     11.0046  11.0971  11.0639  11.0997\n 11.0963  11.0673  11.0013  11.0048     11.0139  11.0188  11.0508  11.086\n 11.0422  11.0614  11.061   11.0318     11.0064  11.0784  11.0148  11.0942\n  ⋮                                  ⋱                             \n 11.0096  11.0678  11.0847  11.0398     11.0443  11.0149  11.0261  11.0418\n 11.0184  11.0058  11.0037  11.0106     11.0196  11.0904  11.0798  11.0139\n 11.0185  11.0074  11.0758  11.0568     11.0241  11.0392  11.0773  11.0703\n 11.0672  11.0217  11.0259  11.0541     11.0808  11.0687  11.0951  11.0331\n 11.0222  11.0713  11.0352  11.0457  …  11.0102  11.029   11.0562  11.0674\n 11.0153  11.0747  11.0055  11.0142     11.0467  11.0209  11.0961  11.0823\n 11.0603  11.0474  11.0326  11.0155     11.0045  11.0399  11.0227  11.0493\n 11.0114  11.0786  11.0273  11.0614     11.0262  11.0093  11.0394  11.0125\n 11.0424  11.0886  11.0729  11.0865     11.0377  11.0256  11.0856  11.0925\n\n[:, :, 2] =\n 12.1  12.1  12.1  12.1  12.1  12.1  …  12.1  12.1  12.1  12.1  12.1  12.1\n 12.1  12.1  12.1  12.1  12.1  12.1     12.1  12.1  12.1  12.1  12.1  12.1\n 12.1  12.1  12.1  12.1  12.1  12.1     12.1  12.1  12.1  12.1  12.1  12.1\n 12.1  12.1  12.1  12.1  12.1  12.1     12.1  12.1  12.1  12.1  12.1  12.1\n 12.1  12.1  12.1  12.1  12.1  12.1     12.1  12.1  12.1  12.1  12.1  12.1\n 12.1  12.1  12.1  12.1  12.1  12.1  …  12.1  12.1  12.1  12.1  12.1  12.1\n 12.1  12.1  12.1  12.1  12.1  12.1     12.1  12.1  12.1  12.1  12.1  12.1\n 12.1  12.1  12.1  12.1  12.1  12.1     12.1  12.1  12.1  12.1  12.1  12.1\n 12.1  12.1  12.1  12.1  12.1  12.1     12.1  12.1  12.1  12.1  12.1  12.1\n 12.1  12.1  12.1  12.1  12.1  12.1     12.1  12.1  12.1  12.1  12.1  12.1\n  ⋮                             ⋮    ⋱         ⋮                      \n 12.1  12.1  12.1  12.1  12.1  12.1     12.1  12.1  12.1  12.1  12.1  12.1\n 12.1  12.1  12.1  12.1  12.1  12.1     12.1  12.1  12.1  12.1  12.1  12.1\n 12.1  12.1  12.1  12.1  12.1  12.1     12.1  12.1  12.1  12.1  12.1  12.1\n 12.1  12.1  12.1  12.1  12.1  12.1     12.1  12.1  12.1  12.1  12.1  12.1\n 12.1  12.1  12.1  12.1  12.1  12.1  …  12.1  12.1  12.1  12.1  12.1  12.1\n 12.1  12.1  12.1  12.1  12.1  12.1     12.1  12.1  12.1  12.1  12.1  12.1\n 12.1  12.1  12.1  12.1  12.1  12.1     12.1  12.1  12.1  12.1  12.1  12.1\n 12.1  12.1  12.1  12.1  12.1  12.1     12.1  12.1  12.1  12.1  12.1  12.1\n 12.1  12.1  12.1  12.1  12.1  12.1     12.1  12.1  12.1  12.1  12.1  12.1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"In this version we have encoded our initial condition to be a 3-dimensional array, with u[:,:,1] being the A part and u[:,:,2] being the B part.","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"@benchmark solve(prob,Tsit5())","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  194.54 MiB\n  allocs estimate:  7647\n  --------------\n  minimum time:     62.835 ms (5.73% GC)\n  median time:      70.834 ms (10.02% GC)\n  mean time:        73.276 ms (8.79% GC)\n  maximum time:     113.199 ms (6.45% GC)\n  --------------\n  samples:          69\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"While this version isn't very efficient,","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/#We-recommend-writing-the-\"high-level\"-code-first,-and-iteratively-optimizing-it!","page":"Optimizing DiffEq Code","title":"We recommend writing the \"high-level\" code first, and iteratively optimizing it!","text":"","category":"section"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"The first thing that we can do is get rid of the slicing allocations. The operation r[:,:,1] creates a temporary array instead of a \"view\", i.e. a pointer to the already existing memory. To make it a view, add @view. Note that we have to be careful with views because they point to the same memory, and thus changing a view changes the original values:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"A = rand(4)\n@show A\nB = @view A[1:3]\nB[2] = 2\n@show A","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"A = [0.24287911998530531, 0.5383392449792268, 0.3043387397954649, 0.0664138\n1936585988]\nA = [0.24287911998530531, 2.0, 0.3043387397954649, 0.06641381936585988]\n4-element Vector{Float64}:\n 0.24287911998530531\n 2.0\n 0.3043387397954649\n 0.06641381936585988","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Notice that changing B changed A. This is something to be careful of, but at the same time we want to use this since we want to modify the output dr. Additionally, the last statement is a purely element-wise operation, and thus we can make use of broadcast fusion there. Let's rewrite basic_version! to ***avoid slicing allocations*** and to ***use broadcast fusion***:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"function gm2!(dr,r,p,t)\n  a,α,ubar,β,D1,D2 = p\n  u = @view r[:,:,1]\n  v = @view r[:,:,2]\n  du = @view dr[:,:,1]\n  dv = @view dr[:,:,2]\n  Du = D1*(Ay*u + u*Ax)\n  Dv = D2*(Ay*v + v*Ax)\n  @. du = Du + a.*u.*u./v + ubar - α*u\n  @. dv = Dv + a.*u.*u - β*v\nend\nprob = ODEProblem(gm2!,r0,(0.0,0.1),p)\n@benchmark solve(prob,Tsit5())","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  124.66 MiB\n  allocs estimate:  6117\n  --------------\n  minimum time:     52.371 ms (7.11% GC)\n  median time:      56.736 ms (6.57% GC)\n  mean time:        57.383 ms (8.07% GC)\n  maximum time:     69.332 ms (16.41% GC)\n  --------------\n  samples:          88\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Now, most of the allocations are taking place in Du = D1*(Ay*u + u*Ax) since those operations are vectorized and not mutating. We should instead replace the matrix multiplications with mul!. When doing so, we will need to have cache variables to write into. This looks like:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Ayu = zeros(N,N)\nuAx = zeros(N,N)\nDu = zeros(N,N)\nAyv = zeros(N,N)\nvAx = zeros(N,N)\nDv = zeros(N,N)\nfunction gm3!(dr,r,p,t)\n  a,α,ubar,β,D1,D2 = p\n  u = @view r[:,:,1]\n  v = @view r[:,:,2]\n  du = @view dr[:,:,1]\n  dv = @view dr[:,:,2]\n  mul!(Ayu,Ay,u)\n  mul!(uAx,u,Ax)\n  mul!(Ayv,Ay,v)\n  mul!(vAx,v,Ax)\n  @. Du = D1*(Ayu + uAx)\n  @. Dv = D2*(Ayv + vAx)\n  @. du = Du + a*u*u./v + ubar - α*u\n  @. dv = Dv + a*u*u - β*v\nend\nprob = ODEProblem(gm3!,r0,(0.0,0.1),p)\n@benchmark solve(prob,Tsit5())","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  31.22 MiB\n  allocs estimate:  4893\n  --------------\n  minimum time:     51.395 ms (0.00% GC)\n  median time:      54.027 ms (0.00% GC)\n  mean time:        54.783 ms (2.02% GC)\n  maximum time:     63.103 ms (6.32% GC)\n  --------------\n  samples:          92\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"But our temporary variables are global variables. We need to either declare the caches as const or localize them. We can localize them by adding them to the parameters, p. It's easier for the compiler to reason about local variables than global variables. ***Localizing variables helps to ensure type stability***.","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"p = (1.0,1.0,1.0,10.0,0.001,100.0,Ayu,uAx,Du,Ayv,vAx,Dv) # a,α,ubar,β,D1,D2\nfunction gm4!(dr,r,p,t)\n  a,α,ubar,β,D1,D2,Ayu,uAx,Du,Ayv,vAx,Dv = p\n  u = @view r[:,:,1]\n  v = @view r[:,:,2]\n  du = @view dr[:,:,1]\n  dv = @view dr[:,:,2]\n  mul!(Ayu,Ay,u)\n  mul!(uAx,u,Ax)\n  mul!(Ayv,Ay,v)\n  mul!(vAx,v,Ax)\n  @. Du = D1*(Ayu + uAx)\n  @. Dv = D2*(Ayv + vAx)\n  @. du = Du + a*u*u./v + ubar - α*u\n  @. dv = Dv + a*u*u - β*v\nend\nprob = ODEProblem(gm4!,r0,(0.0,0.1),p)\n@benchmark solve(prob,Tsit5())","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  30.88 MiB\n  allocs estimate:  1068\n  --------------\n  minimum time:     51.350 ms (0.00% GC)\n  median time:      57.205 ms (0.00% GC)\n  mean time:        57.765 ms (1.79% GC)\n  maximum time:     67.415 ms (5.40% GC)\n  --------------\n  samples:          87\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"We could then use the BLAS gemmv to optimize the matrix multiplications some more, but instead let's devectorize the stencil.","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"p = (1.0,1.0,1.0,10.0,0.001,100.0,N)\nfunction fast_gm!(du,u,p,t)\n  a,α,ubar,β,D1,D2,N = p\n\n  @inbounds for j in 2:N-1, i in 2:N-1\n    du[i,j,1] = D1*(u[i-1,j,1] + u[i+1,j,1] + u[i,j+1,1] + u[i,j-1,1] - 4u[i,j,1]) +\n              a*u[i,j,1]^2/u[i,j,2] + ubar - α*u[i,j,1]\n  end\n\n  @inbounds for j in 2:N-1, i in 2:N-1\n    du[i,j,2] = D2*(u[i-1,j,2] + u[i+1,j,2] + u[i,j+1,2] + u[i,j-1,2] - 4u[i,j,2]) +\n            a*u[i,j,1]^2 - β*u[i,j,2]\n  end\n\n  @inbounds for j in 2:N-1\n    i = 1\n    du[1,j,1] = D1*(2u[i+1,j,1] + u[i,j+1,1] + u[i,j-1,1] - 4u[i,j,1]) +\n            a*u[i,j,1]^2/u[i,j,2] + ubar - α*u[i,j,1]\n  end\n  @inbounds for j in 2:N-1\n    i = 1\n    du[1,j,2] = D2*(2u[i+1,j,2] + u[i,j+1,2] + u[i,j-1,2] - 4u[i,j,2]) +\n            a*u[i,j,1]^2 - β*u[i,j,2]\n  end\n  @inbounds for j in 2:N-1\n    i = N\n    du[end,j,1] = D1*(2u[i-1,j,1] + u[i,j+1,1] + u[i,j-1,1] - 4u[i,j,1]) +\n           a*u[i,j,1]^2/u[i,j,2] + ubar - α*u[i,j,1]\n  end\n  @inbounds for j in 2:N-1\n    i = N\n    du[end,j,2] = D2*(2u[i-1,j,2] + u[i,j+1,2] + u[i,j-1,2] - 4u[i,j,2]) +\n           a*u[i,j,1]^2 - β*u[i,j,2]\n  end\n\n  @inbounds for i in 2:N-1\n    j = 1\n    du[i,1,1] = D1*(u[i-1,j,1] + u[i+1,j,1] + 2u[i,j+1,1] - 4u[i,j,1]) +\n              a*u[i,j,1]^2/u[i,j,2] + ubar - α*u[i,j,1]\n  end\n  @inbounds for i in 2:N-1\n    j = 1\n    du[i,1,2] = D2*(u[i-1,j,2] + u[i+1,j,2] + 2u[i,j+1,2] - 4u[i,j,2]) +\n              a*u[i,j,1]^2 - β*u[i,j,2]\n  end\n  @inbounds for i in 2:N-1\n    j = N\n    du[i,end,1] = D1*(u[i-1,j,1] + u[i+1,j,1] + 2u[i,j-1,1] - 4u[i,j,1]) +\n             a*u[i,j,1]^2/u[i,j,2] + ubar - α*u[i,j,1]\n  end\n  @inbounds for i in 2:N-1\n    j = N\n    du[i,end,2] = D2*(u[i-1,j,2] + u[i+1,j,2] + 2u[i,j-1,2] - 4u[i,j,2]) +\n             a*u[i,j,1]^2 - β*u[i,j,2]\n  end\n\n  @inbounds begin\n    i = 1; j = 1\n    du[1,1,1] = D1*(2u[i+1,j,1] + 2u[i,j+1,1] - 4u[i,j,1]) +\n              a*u[i,j,1]^2/u[i,j,2] + ubar - α*u[i,j,1]\n    du[1,1,2] = D2*(2u[i+1,j,2] + 2u[i,j+1,2] - 4u[i,j,2]) +\n              a*u[i,j,1]^2 - β*u[i,j,2]\n\n    i = 1; j = N\n    du[1,N,1] = D1*(2u[i+1,j,1] + 2u[i,j-1,1] - 4u[i,j,1]) +\n             a*u[i,j,1]^2/u[i,j,2] + ubar - α*u[i,j,1]\n    du[1,N,2] = D2*(2u[i+1,j,2] + 2u[i,j-1,2] - 4u[i,j,2]) +\n             a*u[i,j,1]^2 - β*u[i,j,2]\n\n    i = N; j = 1\n    du[N,1,1] = D1*(2u[i-1,j,1] + 2u[i,j+1,1] - 4u[i,j,1]) +\n             a*u[i,j,1]^2/u[i,j,2] + ubar - α*u[i,j,1]\n    du[N,1,2] = D2*(2u[i-1,j,2] + 2u[i,j+1,2] - 4u[i,j,2]) +\n             a*u[i,j,1]^2 - β*u[i,j,2]\n\n    i = N; j = N\n    du[end,end,1] = D1*(2u[i-1,j,1] + 2u[i,j-1,1] - 4u[i,j,1]) +\n             a*u[i,j,1]^2/u[i,j,2] + ubar - α*u[i,j,1]\n    du[end,end,2] = D2*(2u[i-1,j,2] + 2u[i,j-1,2] - 4u[i,j,2]) +\n             a*u[i,j,1]^2 - β*u[i,j,2]\n   end\nend\nprob = ODEProblem(fast_gm!,r0,(0.0,0.1),p)\n@benchmark solve(prob,Tsit5())","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  30.85 MiB\n  allocs estimate:  456\n  --------------\n  minimum time:     7.015 ms (0.00% GC)\n  median time:      7.198 ms (0.00% GC)\n  mean time:        8.208 ms (12.33% GC)\n  maximum time:     10.895 ms (31.64% GC)\n  --------------\n  samples:          607\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Lastly, we can do other things like multithread the main loops, but these optimizations get the last 2x-3x out. The main optimizations which apply everywhere are the ones we just performed (though the last one only works if your matrix is a stencil. This is known as a matrix-free implementation of the PDE discretization).","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"This gets us to about 8x faster than our original MATLAB/SciPy/R vectorized style code!","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"The last thing to do is then ***optimize our algorithm choice***. We have been using Tsit5() as our test algorithm, but in reality this problem is a stiff PDE discretization and thus one recommendation is to use CVODE_BDF(). However, instead of using the default dense Jacobian, we should make use of the sparse Jacobian afforded by the problem. The Jacobian is the matrix fracdf_idr_j, where r is read by the linear index (i.e. down columns). But since the u variables depend on the v, the band size here is large, and thus this will not do well with a Banded Jacobian solver. Instead, we utilize sparse Jacobian algorithms. CVODE_BDF allows us to use a sparse Newton-Krylov solver by setting linear_solver = :GMRES (see the solver documentation, and thus we can solve this problem efficiently. Let's see how this scales as we increase the integration time.","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"prob = ODEProblem(fast_gm!,r0,(0.0,10.0),p)\n@benchmark solve(prob,Tsit5())","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  2.76 GiB\n  allocs estimate:  39336\n  --------------\n  minimum time:     1.060 s (38.81% GC)\n  median time:      1.343 s (44.84% GC)\n  mean time:        1.351 s (44.13% GC)\n  maximum time:     1.659 s (47.77% GC)\n  --------------\n  samples:          4\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"using Sundials\n@benchmark solve(prob,CVODE_BDF(linear_solver=:GMRES))","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  118.40 MiB\n  allocs estimate:  19431\n  --------------\n  minimum time:     634.366 ms (0.00% GC)\n  median time:      639.884 ms (0.60% GC)\n  mean time:        639.731 ms (0.60% GC)\n  maximum time:     643.339 ms (1.22% GC)\n  --------------\n  samples:          8\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"prob = ODEProblem(fast_gm!,r0,(0.0,100.0),p)\n# Will go out of memory if we don't turn off `save_everystep`!\n@benchmark solve(prob,Tsit5(),save_everystep=false)","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  2.91 MiB\n  allocs estimate:  67\n  --------------\n  minimum time:     4.270 s (0.00% GC)\n  median time:      4.279 s (0.00% GC)\n  mean time:        4.279 s (0.00% GC)\n  maximum time:     4.289 s (0.00% GC)\n  --------------\n  samples:          2\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"@benchmark solve(prob,CVODE_BDF(linear_solver=:GMRES))","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  323.21 MiB\n  allocs estimate:  55863\n  --------------\n  minimum time:     1.891 s (0.00% GC)\n  median time:      1.919 s (1.83% GC)\n  mean time:        1.961 s (3.81% GC)\n  maximum time:     2.074 s (9.12% GC)\n  --------------\n  samples:          3\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Now let's check the allocation growth.","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"@benchmark solve(prob,CVODE_BDF(linear_solver=:GMRES),save_everystep=false)","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  3.61 MiB\n  allocs estimate:  46772\n  --------------\n  minimum time:     1.847 s (0.00% GC)\n  median time:      1.848 s (0.00% GC)\n  mean time:        1.848 s (0.00% GC)\n  maximum time:     1.849 s (0.00% GC)\n  --------------\n  samples:          3\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"prob = ODEProblem(fast_gm!,r0,(0.0,500.0),p)\n@benchmark solve(prob,CVODE_BDF(linear_solver=:GMRES),save_everystep=false)","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"BenchmarkTools.Trial: \n  memory estimate:  5.03 MiB\n  allocs estimate:  71189\n  --------------\n  minimum time:     2.814 s (0.00% GC)\n  median time:      2.816 s (0.00% GC)\n  mean time:        2.816 s (0.00% GC)\n  maximum time:     2.819 s (0.00% GC)\n  --------------\n  samples:          2\n  evals/sample:     1","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Notice that we've elimated almost all allocations, allowing the code to grow without hitting garbage collection and slowing down.","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Why is CVODE_BDF doing well? What's happening is that, because the problem is stiff, the number of steps required by the explicit Runge-Kutta method grows rapidly, whereas CVODE_BDF is taking large steps. Additionally, the GMRES linear solver form is quite an efficient way to solve the implicit system in this case. This is problem-dependent, and in many cases using a Krylov method effectively requires a preconditioner, so you need to play around with testing other algorithms and linear solvers to find out what works best with your problem.","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/#Conclusion","page":"Optimizing DiffEq Code","title":"Conclusion","text":"","category":"section"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Julia gives you the tools to optimize the solver \"all the way\", but you need to make use of it. The main thing to avoid is temporary allocations. For small systems, this is effectively done via static arrays. For large systems, this is done via in-place operations and cache arrays. Either way, the resulting solution can be immensely sped up over vectorized formulations by using these principles.","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/#Appendix","page":"Optimizing DiffEq Code","title":"Appendix","text":"","category":"section"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"tutorials/introduction\",\"03-optimizing_diffeq_code.jmd\")","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Computer Information:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Julia Version 1.6.1\nCommit 6aaedecc44 (2021-04-23 05:59 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, znver2)\nEnvironment:\n  JULIA_DEPOT_PATH = /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n  JULIA_NUM_THREADS = 16\n","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"Package Information:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"      Status `/var/lib/buildkite-agent/builds/6-amdci4-julia-csail-mit-edu/julialang/scimltutorials/tutorials/introduction/Project.toml`\n  [6e4b80f9] BenchmarkTools v1.0.0\n  [0c46a032] DifferentialEquations v6.17.1\n  [65888b18] ParameterizedFunctions v5.10.0\n  [91a5bcdd] Plots v1.15.2\n  [30cb0354] SciMLTutorials v0.9.0\n  [90137ffa] StaticArrays v1.2.0\n  [c3572dad] Sundials v4.4.3\n  [37e2e46d] LinearAlgebra","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"And the full manifest:","category":"page"},{"location":"introduction/03-optimizing_diffeq_code/","page":"Optimizing DiffEq Code","title":"Optimizing DiffEq Code","text":"      Status `/var/lib/buildkite-agent/builds/6-amdci4-julia-csail-mit-edu/julialang/scimltutorials/tutorials/introduction/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.16.0\n  [1520ce14] AbstractTrees v0.3.4\n  [79e6a3ab] Adapt v3.3.0\n  [ec485272] ArnoldiMethod v0.1.0\n  [4fba245c] ArrayInterface v3.1.15\n  [4c555306] ArrayLayouts v0.7.0\n  [aae01518] BandedMatrices v0.16.9\n  [6e4b80f9] BenchmarkTools v1.0.0\n  [764a87c0] BoundaryValueDiffEq v2.7.1\n  [fa961155] CEnum v0.4.1\n  [d360d2e6] ChainRulesCore v0.9.44\n  [b630d9fa] CheapThreads v0.2.5\n  [35d6a980] ColorSchemes v3.12.1\n  [3da002f7] ColorTypes v0.11.0\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [38540f10] CommonSolve v0.2.0\n  [bbf7d656] CommonSubexpressions v0.3.0\n  [34da2185] Compat v3.30.0\n  [8f4d0f93] Conda v1.5.2\n  [187b0558] ConstructionBase v1.2.1\n  [d38c429a] Contour v0.5.7\n  [9a962f9c] DataAPI v1.6.0\n  [864edb3b] DataStructures v0.18.9\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [bcd4f6db] DelayDiffEq v5.31.0\n  [2b5f629d] DiffEqBase v6.62.2\n  [459566f4] DiffEqCallbacks v2.16.1\n  [5a0ffddc] DiffEqFinancial v2.4.0\n  [c894b116] DiffEqJump v6.14.2\n  [77a26b50] DiffEqNoiseProcess v5.7.3\n  [055956cb] DiffEqPhysics v3.9.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.0.2\n  [0c46a032] DifferentialEquations v6.17.1\n  [c619ae07] DimensionalPlotRecipes v1.2.0\n  [b4f34e82] Distances v0.10.3\n  [31c24e10] Distributions v0.24.18\n  [ffbed154] DocStringExtensions v0.8.4\n  [d4d017d3] ExponentialUtilities v1.8.4\n  [e2ba6199] ExprTools v0.1.3\n  [c87230d0] FFMPEG v0.4.0\n  [7034ab61] FastBroadcast v0.1.8\n  [9aa1b823] FastClosures v0.3.2\n  [1a297f60] FillArrays v0.11.7\n  [6a86dc24] FiniteDiff v2.8.0\n  [53c48c17] FixedPointNumbers v0.8.4\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.18\n  [069b7b12] FunctionWrappers v1.1.2\n  [28b8d3ca] GR v0.57.4\n  [5c1252a2] GeometryBasics v0.3.12\n  [42e2da0e] Grisu v1.0.2\n  [cd3eb016] HTTP v0.9.9\n  [eafb193a] Highlights v0.4.5\n  [0e44f5e4] Hwloc v2.0.0\n  [7073ff75] IJulia v1.23.2\n  [615f187c] IfElse v0.1.0\n  [d25df0c9] Inflate v0.1.2\n  [83e8ac13] IniFile v0.5.0\n  [c8e1da08] IterTools v1.3.0\n  [42fd0dbc] IterativeSolvers v0.9.1\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.3.0\n  [682c06a0] JSON v0.21.1\n  [b964fa9f] LaTeXStrings v1.2.1\n  [2ee39098] LabelledArrays v1.6.1\n  [23fbe1c1] Latexify v0.15.5\n  [093fc24a] LightGraphs v1.3.5\n  [d3d80556] LineSearches v7.1.1\n  [2ab3a3ac] LogExpFunctions v0.2.4\n  [bdcacae8] LoopVectorization v0.12.23\n  [1914dd2f] MacroTools v0.5.6\n  [739be429] MbedTLS v1.0.3\n  [442fdcdd] Measures v0.3.1\n  [e1d29d7a] Missings v1.0.0\n  [961ee093] ModelingToolkit v5.16.0\n  [46d2c3a1] MuladdMacro v0.2.2\n  [f9640e96] MultiScaleArrays v1.8.1\n  [ffc61752] Mustache v1.0.10\n  [d41bc354] NLSolversBase v7.8.0\n  [2774e3e8] NLsolve v4.5.1\n  [77ba4419] NaNMath v0.3.5\n  [8913a72c] NonlinearSolve v0.3.8\n  [6fe1bfb0] OffsetArrays v1.9.0\n  [429524aa] Optim v1.3.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [90014a1f] PDMats v0.11.0\n  [65888b18] ParameterizedFunctions v5.10.0\n  [d96e819e] Parameters v0.12.2\n  [69de0a69] Parsers v1.1.0\n  [ccf2f8ad] PlotThemes v2.0.1\n  [995b91a9] PlotUtils v1.0.10\n  [91a5bcdd] Plots v1.15.2\n  [e409e4f3] PoissonRandom v0.4.0\n  [f517fe37] Polyester v0.3.1\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [21216c6a] Preferences v1.2.2\n  [1fd47b50] QuadGK v2.4.1\n  [74087812] Random123 v1.3.1\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.4.0\n  [3cdcf5f2] RecipesBase v1.1.1\n  [01d81517] RecipesPipeline v0.3.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [f2c3362d] RecursiveFactorization v0.1.12\n  [189a3867] Reexport v1.0.0\n  [ae029012] Requires v1.1.3\n  [ae5879a3] ResettableStacks v1.1.0\n  [79098fc4] Rmath v0.7.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.2\n  [476501e8] SLEEFPirates v0.6.20\n  [1bc83da4] SafeTestsets v0.0.1\n  [0bca4576] SciMLBase v1.13.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [6c6a2e73] Scratch v1.0.3\n  [efcf1570] Setfield v0.7.0\n  [992d4aef] Showoff v1.0.3\n  [699a6c99] SimpleTraits v0.9.3\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.0\n  [47a9eef4] SparseDiffTools v1.13.2\n  [276daf66] SpecialFunctions v1.4.1\n  [aedffcd0] Static v0.2.4\n  [90137ffa] StaticArrays v1.2.0\n  [82ae8749] StatsAPI v1.0.0\n  [2913bbd2] StatsBase v0.33.8\n  [4c63d2b9] StatsFuns v0.9.8\n  [9672c7b4] SteadyStateDiffEq v1.6.2\n  [789caeaf] StochasticDiffEq v6.34.1\n  [7792a7ef] StrideArraysCore v0.1.11\n  [09ab397b] StructArrays v0.5.1\n  [c3572dad] Sundials v4.4.3\n  [d1185830] SymbolicUtils v0.11.2\n  [0c5d862f] Symbolics v0.1.25\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.4.2\n  [8290d209] ThreadingUtilities v0.4.4\n  [a759f4b9] TimerOutputs v0.5.9\n  [a2a6695c] TreeViews v0.3.0\n  [5c2747f8] URIs v1.3.0\n  [3a884ed6] UnPack v1.0.2\n  [1986cc42] Unitful v1.7.0\n  [3d5dd08c] VectorizationBase v0.20.11\n  [81def892] VersionParsing v1.2.0\n  [19fa3120] VertexSafeGraphs v0.1.2\n  [44d3d7a6] Weave v0.10.8\n  [ddb6d928] YAML v0.4.6\n  [c2297ded] ZMQ v1.2.1\n  [700de1a5] ZygoteRules v0.2.1\n  [6e34b625] Bzip2_jll v1.0.6+5\n  [83423d85] Cairo_jll v1.16.0+6\n  [5ae413db] EarCut_jll v2.1.5+1\n  [2e619515] Expat_jll v2.2.10+0\n  [b22a6f82] FFMPEG_jll v4.3.1+4\n  [a3f928ae] Fontconfig_jll v2.13.1+14\n  [d7e528f0] FreeType2_jll v2.10.1+5\n  [559328eb] FriBidi_jll v1.0.5+6\n  [0656b61e] GLFW_jll v3.3.4+0\n  [d2c73de3] GR_jll v0.57.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.1+0\n  [e33a78d0] Hwloc_jll v2.4.1+0\n  [aacddb02] JpegTurbo_jll v2.0.1+3\n  [c1c5ebd0] LAME_jll v3.100.0+3\n  [dd4b983a] LZO_jll v2.10.1+0\n  [dd192d2f] LibVPX_jll v1.9.0+1\n  [e9f186c6] Libffi_jll v3.2.2+0\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+0\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.1.0+2\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [e7412a2a] Ogg_jll v1.3.4+2\n  [458c3c95] OpenSSL_jll v1.1.1+6\n  [efe28fd5] OpenSpecFun_jll v0.5.4+0\n  [91d4177d] Opus_jll v1.3.1+3\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.2+0\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.0+1\n  [a2964d1f] Wayland_jll v1.17.0+4\n  [2381bf8a] Wayland_protocols_jll v1.18.0+4\n  [02c8fc9c] XML2_jll v2.9.12+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.2+6\n  [3161d3a3] Zstd_jll v1.5.0+0\n  [0ac62f75] libass_jll v0.14.0+4\n  [f638f0a6] libfdk_aac_jll v0.1.6+4\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.6+6\n  [1270edf5] x264_jll v2020.7.14+2\n  [dfaa095f] x265_jll v3.0.0+3\n  [d8fb68d0] xkbcommon_jll v0.9.1+5\n  [0dad84c5] ArgTools\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [b27032c2] LibCURL\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions\n  [44cfe95a] Pkg\n  [de0858da] Printf\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML\n  [a4e569a6] Tar\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll\n  [deac9b47] LibCURL_jll\n  [29816b5a] LibSSH2_jll\n  [c8ffd9c3] MbedTLS_jll\n  [14a3606d] MozillaCACerts_jll\n  [4536629a] OpenBLAS_jll\n  [bea87d4a] SuiteSparse_jll\n  [83775a58] Zlib_jll\n  [8e850ede] nghttp2_jll\n  [3f19e933] p7zip_jll","category":"page"},{"location":"models/05-kepler_problem/#Kepler-Problem","page":"Kepler Problem","title":"Kepler Problem","text":"","category":"section"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"The Hamiltonian mathcal H and the angular momentum L for the Kepler problem are","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"mathcal H = frac12(dotq^2_1+dotq^2_2)-frac1sqrtq^2_1+q^2_2quad\nL = q_1dotq_2 - dotq_1q_2","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Also, we know that","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"displaystyle frac mathrm d boldsymbol pmathrm d t=-frac partial mathcal Hpartial boldsymbol qquad quad frac mathrm d boldsymbol qmathrm d t=+frac partial mathcal Hpartial boldsymbol p","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"using OrdinaryDiffEq, LinearAlgebra, ForwardDiff, Plots; gr()\nH(q,p) = norm(p)^2/2 - inv(norm(q))\nL(q,p) = q[1]*p[2] - p[1]*q[2]\n\npdot(dp,p,q,params,t) = ForwardDiff.gradient!(dp, q->-H(q, p), q)\nqdot(dq,p,q,params,t) = ForwardDiff.gradient!(dq, p-> H(q, p), p)\n\ninitial_position = [.4, 0]\ninitial_velocity = [0., 2.]\ninitial_cond = (initial_position, initial_velocity)\ninitial_first_integrals = (H(initial_cond...), L(initial_cond...))\ntspan = (0,20.)\nprob = DynamicalODEProblem(pdot, qdot, initial_velocity, initial_position, tspan)\nsol = solve(prob, KahanLi6(), dt=1//10);","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Let's plot the orbit and check the energy and angular momentum variation. We know that energy and angular momentum should be constant, and they are also called first integrals.","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"plot_orbit(sol) = plot(sol,vars=(3,4), lab=\"Orbit\", title=\"Kepler Problem Solution\")\n\nfunction plot_first_integrals(sol, H, L)\n    plot(initial_first_integrals[1].-map(u->H(u[2,:], u[1,:]), sol.u), lab=\"Energy variation\", title=\"First Integrals\")\n    plot!(initial_first_integrals[2].-map(u->L(u[2,:], u[1,:]), sol.u), lab=\"Angular momentum variation\")\nend\nanalysis_plot(sol, H, L) = plot(plot_orbit(sol), plot_first_integrals(sol, H, L))","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"analysis_plot (generic function with 1 method)","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"analysis_plot(sol, H, L)","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"(Image: )","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Let's try to use a Runge-Kutta-Nyström solver to solve this problem and check the first integrals' variation.","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"sol2 = solve(prob, DPRKN6())  # dt is not necessary, because unlike symplectic\n                              # integrators DPRKN6 is adaptive\n@show sol2.u |> length\nanalysis_plot(sol2, H, L)","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"sol2.u |> length = 91","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"(Image: )","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Let's then try to solve the same problem by the ERKN4 solver, which is specialized for sinusoid-like periodic function","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"sol3 = solve(prob, ERKN4()) # dt is not necessary, because unlike symplectic\n                            # integrators ERKN4 is adaptive\n@show sol3.u |> length\nanalysis_plot(sol3, H, L)","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"sol3.u |> length = 55","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"(Image: )","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"We can see that ERKN4 does a bad job for this problem, because this problem is not sinusoid-like.","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"One advantage of using DynamicalODEProblem is that it can implicitly convert the second order ODE problem to a normal system of first order ODEs, which is solvable for other ODE solvers. Let's use the Tsit5 solver for the next example.","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"sol4 = solve(prob, Tsit5())\n@show sol4.u |> length\nanalysis_plot(sol4, H, L)","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"sol4.u |> length = 57","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"(Image: )","category":"page"},{"location":"models/05-kepler_problem/#Note","page":"Kepler Problem","title":"Note","text":"","category":"section"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"There is drifting for all the solutions, and high order methods are drifting less because they are more accurate.","category":"page"},{"location":"models/05-kepler_problem/#Conclusion","page":"Kepler Problem","title":"Conclusion","text":"","category":"section"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Symplectic integrator does not conserve the energy completely at all time, but the energy can come back. In order to make sure that the energy fluctuation comes back eventually, symplectic integrator has to have a fixed time step. Despite the energy variation, symplectic integrator conserves the angular momentum perfectly.","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Both Runge-Kutta-Nyström and Runge-Kutta integrator do not conserve energy nor the angular momentum, and the first integrals do not tend to come back. An advantage Runge-Kutta-Nyström integrator over symplectic integrator is that RKN integrator can have adaptivity. An advantage Runge-Kutta-Nyström integrator over Runge-Kutta integrator is that RKN integrator has less function evaluation per step. The ERKN4 solver works best for sinusoid-like solutions.","category":"page"},{"location":"models/05-kepler_problem/#Manifold-Projection","page":"Kepler Problem","title":"Manifold Projection","text":"","category":"section"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"In this example, we know that energy and angular momentum should be conserved. We can achieve this through mainfold projection. As the name implies, it is a procedure to project the ODE solution to a manifold. Let's start with a base case, where mainfold projection isn't being used.","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"using DiffEqCallbacks\n\nplot_orbit2(sol) = plot(sol,vars=(1,2), lab=\"Orbit\", title=\"Kepler Problem Solution\")\n\nfunction plot_first_integrals2(sol, H, L)\n    plot(initial_first_integrals[1].-map(u->H(u[1:2],u[3:4]), sol.u), lab=\"Energy variation\", title=\"First Integrals\")\n    plot!(initial_first_integrals[2].-map(u->L(u[1:2],u[3:4]), sol.u), lab=\"Angular momentum variation\")\nend\n\nanalysis_plot2(sol, H, L) = plot(plot_orbit2(sol), plot_first_integrals2(sol, H, L))\n\nfunction hamiltonian(du,u,params,t)\n    q, p = u[1:2], u[3:4]\n    qdot(@view(du[1:2]), p, q, params, t)\n    pdot(@view(du[3:4]), p, q, params, t)\nend\n\nprob2 = ODEProblem(hamiltonian, [initial_position; initial_velocity], tspan)\nsol_ = solve(prob2, RK4(), dt=1//5, adaptive=false)\nanalysis_plot2(sol_, H, L)","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"(Image: )","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"There is a significant fluctuation in the first integrals, when there is no mainfold projection.","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"function first_integrals_manifold(residual,u)\n    residual[1:2] .= initial_first_integrals[1] - H(u[1:2], u[3:4])\n    residual[3:4] .= initial_first_integrals[2] - L(u[1:2], u[3:4])\nend\n\ncb = ManifoldProjection(first_integrals_manifold)\nsol5 = solve(prob2, RK4(), dt=1//5, adaptive=false, callback=cb)\nanalysis_plot2(sol5, H, L)","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"(Image: )","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"We can see that thanks to the manifold projection, the first integrals' variation is very small, although we are using RK4 which is not symplectic. But wait, what if we only project to the energy conservation manifold?","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"function energy_manifold(residual,u)\n    residual[1:2] .= initial_first_integrals[1] - H(u[1:2], u[3:4])\n    residual[3:4] .= 0\nend\nenergy_cb = ManifoldProjection(energy_manifold)\nsol6 = solve(prob2, RK4(), dt=1//5, adaptive=false, callback=energy_cb)\nanalysis_plot2(sol6, H, L)","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"(Image: )","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"There is almost no energy variation but angular momentum varies quite bit. How about only project to the angular momentum conservation manifold?","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"function angular_manifold(residual,u)\n    residual[1:2] .= initial_first_integrals[2] - L(u[1:2], u[3:4])\n    residual[3:4] .= 0\nend\nangular_cb = ManifoldProjection(angular_manifold)\nsol7 = solve(prob2, RK4(), dt=1//5, adaptive=false, callback=angular_cb)\nanalysis_plot2(sol7, H, L)","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"(Image: )","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Again, we see what we expect.","category":"page"},{"location":"models/05-kepler_problem/#Appendix","page":"Kepler Problem","title":"Appendix","text":"","category":"section"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"tutorials/models\",\"05-kepler_problem.jmd\")","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Computer Information:","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Julia Version 1.6.2\nCommit 1b93d53fc4 (2021-07-14 15:36 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, znver2)\nEnvironment:\n  JULIA_DEPOT_PATH = /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n  JULIA_NUM_THREADS = 16\n","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Package Information:","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"      Status `/var/lib/buildkite-agent/builds/1-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/models/Project.toml`\n  [479239e8] Catalyst v6.12.1\n  [459566f4] DiffEqCallbacks v2.16.1\n  [f3b72e0c] DiffEqDevTools v2.27.2\n  [055956cb] DiffEqPhysics v3.9.0\n  [0c46a032] DifferentialEquations v6.17.1\n  [31c24e10] Distributions v0.24.18\n  [587475ba] Flux v0.12.1\n  [f6369f11] ForwardDiff v0.10.18\n  [23fbe1c1] Latexify v0.15.5\n  [961ee093] ModelingToolkit v5.17.3\n  [2774e3e8] NLsolve v4.5.1\n  [315f7962] NeuralPDE v3.10.1\n  [429524aa] Optim v1.3.0\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [91a5bcdd] Plots v1.15.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [789caeaf] StochasticDiffEq v6.34.1\n  [37e2e46d] LinearAlgebra\n  [2f01184e] SparseArrays","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"And the full manifest:","category":"page"},{"location":"models/05-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"      Status `/var/lib/buildkite-agent/builds/1-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/models/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.16.0\n  [621f4979] AbstractFFTs v1.0.1\n  [1520ce14] AbstractTrees v0.3.4\n  [79e6a3ab] Adapt v3.3.0\n  [ec485272] ArnoldiMethod v0.1.0\n  [4fba245c] ArrayInterface v3.1.15\n  [4c555306] ArrayLayouts v0.7.0\n  [13072b0f] AxisAlgorithms v1.0.0\n  [ab4f0b2a] BFloat16s v0.1.0\n  [aae01518] BandedMatrices v0.16.9\n  [764a87c0] BoundaryValueDiffEq v2.7.1\n  [fa961155] CEnum v0.4.1\n  [00ebfdb7] CSTParser v2.5.0\n  [052768ef] CUDA v2.6.3\n  [479239e8] Catalyst v6.12.1\n  [082447d4] ChainRules v0.7.65\n  [d360d2e6] ChainRulesCore v0.9.44\n  [b630d9fa] CheapThreads v0.2.5\n  [944b1d66] CodecZlib v0.7.0\n  [35d6a980] ColorSchemes v3.12.1\n  [3da002f7] ColorTypes v0.11.0\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [a80b9123] CommonMark v0.8.1\n  [38540f10] CommonSolve v0.2.0\n  [bbf7d656] CommonSubexpressions v0.3.0\n  [34da2185] Compat v3.30.0\n  [8f4d0f93] Conda v1.5.2\n  [88cd18e8] ConsoleProgressMonitor v0.1.2\n  [187b0558] ConstructionBase v1.2.1\n  [d38c429a] Contour v0.5.7\n  [a8cc5b0e] Crayons v4.0.4\n  [8a292aeb] Cuba v2.2.0\n  [667455a9] Cubature v1.5.1\n  [9a962f9c] DataAPI v1.6.0\n  [82cc6244] DataInterpolations v3.3.1\n  [864edb3b] DataStructures v0.18.9\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [bcd4f6db] DelayDiffEq v5.31.0\n  [2b5f629d] DiffEqBase v6.62.2\n  [459566f4] DiffEqCallbacks v2.16.1\n  [f3b72e0c] DiffEqDevTools v2.27.2\n  [5a0ffddc] DiffEqFinancial v2.4.0\n  [aae7a2af] DiffEqFlux v1.37.0\n  [c894b116] DiffEqJump v6.14.2\n  [77a26b50] DiffEqNoiseProcess v5.7.3\n  [055956cb] DiffEqPhysics v3.9.0\n  [41bf760c] DiffEqSensitivity v6.45.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.0.2\n  [0c46a032] DifferentialEquations v6.17.1\n  [c619ae07] DimensionalPlotRecipes v1.2.0\n  [b4f34e82] Distances v0.10.3\n  [31c24e10] Distributions v0.24.18\n  [ced4e74d] DistributionsAD v0.6.26\n  [ffbed154] DocStringExtensions v0.8.4\n  [e30172f5] Documenter v0.26.3\n  [d4d017d3] ExponentialUtilities v1.8.4\n  [e2ba6199] ExprTools v0.1.3\n  [c87230d0] FFMPEG v0.4.0\n  [7a1cc6ca] FFTW v1.4.1\n  [7034ab61] FastBroadcast v0.1.8\n  [9aa1b823] FastClosures v0.3.2\n  [1a297f60] FillArrays v0.11.7\n  [6a86dc24] FiniteDiff v2.8.0\n  [53c48c17] FixedPointNumbers v0.8.4\n  [587475ba] Flux v0.12.1\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.18\n  [069b7b12] FunctionWrappers v1.1.2\n  [d9f16b24] Functors v0.2.1\n  [0c68f7d7] GPUArrays v6.4.1\n  [61eb1bfa] GPUCompiler v0.10.0\n  [28b8d3ca] GR v0.57.4\n  [a75be94c] GalacticOptim v1.2.0\n  [5c1252a2] GeometryBasics v0.3.12\n  [af5da776] GlobalSensitivity v1.0.0\n  [42e2da0e] Grisu v1.0.2\n  [19dc6840] HCubature v1.5.0\n  [cd3eb016] HTTP v0.9.9\n  [eafb193a] Highlights v0.4.5\n  [0e44f5e4] Hwloc v2.0.0\n  [7073ff75] IJulia v1.23.2\n  [b5f81e59] IOCapture v0.1.1\n  [7869d1d1] IRTools v0.4.2\n  [615f187c] IfElse v0.1.0\n  [d25df0c9] Inflate v0.1.2\n  [83e8ac13] IniFile v0.5.0\n  [a98d9a8b] Interpolations v0.13.2\n  [c8e1da08] IterTools v1.3.0\n  [42fd0dbc] IterativeSolvers v0.9.1\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.3.0\n  [682c06a0] JSON v0.21.1\n  [98e50ef6] JuliaFormatter v0.13.7\n  [e5e0dc1b] Juno v0.8.4\n  [5ab0869b] KernelDensity v0.6.3\n  [929cbde3] LLVM v3.7.1\n  [b964fa9f] LaTeXStrings v1.2.1\n  [2ee39098] LabelledArrays v1.6.1\n  [23fbe1c1] Latexify v0.15.5\n  [a5e1c1ea] LatinHypercubeSampling v1.8.0\n  [73f95e8e] LatticeRules v0.0.1\n  [1d6d02ad] LeftChildRightSiblingTrees v0.1.2\n  [093fc24a] LightGraphs v1.3.5\n  [d3d80556] LineSearches v7.1.1\n  [2ab3a3ac] LogExpFunctions v0.2.4\n  [e6f89c97] LoggingExtras v0.4.6\n  [bdcacae8] LoopVectorization v0.12.23\n  [1914dd2f] MacroTools v0.5.6\n  [739be429] MbedTLS v1.0.3\n  [442fdcdd] Measures v0.3.1\n  [e89f7d12] Media v0.5.0\n  [c03570c3] Memoize v0.4.4\n  [e1d29d7a] Missings v1.0.0\n  [961ee093] ModelingToolkit v5.17.3\n  [4886b29c] MonteCarloIntegration v0.0.2\n  [46d2c3a1] MuladdMacro v0.2.2\n  [f9640e96] MultiScaleArrays v1.8.1\n  [ffc61752] Mustache v1.0.10\n  [d41bc354] NLSolversBase v7.8.0\n  [2774e3e8] NLsolve v4.5.1\n  [872c559c] NNlib v0.7.19\n  [77ba4419] NaNMath v0.3.5\n  [315f7962] NeuralPDE v3.10.1\n  [8913a72c] NonlinearSolve v0.3.8\n  [6fe1bfb0] OffsetArrays v1.9.0\n  [429524aa] Optim v1.3.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [90014a1f] PDMats v0.11.0\n  [65888b18] ParameterizedFunctions v5.10.0\n  [d96e819e] Parameters v0.12.2\n  [69de0a69] Parsers v1.1.0\n  [ccf2f8ad] PlotThemes v2.0.1\n  [995b91a9] PlotUtils v1.0.10\n  [91a5bcdd] Plots v1.15.2\n  [e409e4f3] PoissonRandom v0.4.0\n  [f517fe37] Polyester v0.3.1\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [21216c6a] Preferences v1.2.2\n  [33c8b6b6] ProgressLogging v0.1.4\n  [92933f4c] ProgressMeter v1.6.2\n  [1fd47b50] QuadGK v2.4.1\n  [67601950] Quadrature v1.8.1\n  [8a4e6c94] QuasiMonteCarlo v0.2.2\n  [74087812] Random123 v1.3.1\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.4.0\n  [c84ed2f1] Ratios v0.4.0\n  [3cdcf5f2] RecipesBase v1.1.1\n  [01d81517] RecipesPipeline v0.3.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [f2c3362d] RecursiveFactorization v0.1.12\n  [189a3867] Reexport v1.0.0\n  [ae029012] Requires v1.1.3\n  [ae5879a3] ResettableStacks v1.1.0\n  [37e2e3b7] ReverseDiff v1.9.0\n  [79098fc4] Rmath v0.7.0\n  [47965b36] RootedTrees v1.0.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.2\n  [476501e8] SLEEFPirates v0.6.20\n  [1bc83da4] SafeTestsets v0.0.1\n  [0bca4576] SciMLBase v1.13.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [6c6a2e73] Scratch v1.0.3\n  [efcf1570] Setfield v0.7.0\n  [992d4aef] Showoff v1.0.3\n  [699a6c99] SimpleTraits v0.9.3\n  [ed01d8cd] Sobol v1.5.0\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.0\n  [47a9eef4] SparseDiffTools v1.13.2\n  [276daf66] SpecialFunctions v1.4.1\n  [860ef19b] StableRNGs v1.0.0\n  [aedffcd0] Static v0.2.4\n  [90137ffa] StaticArrays v1.2.0\n  [82ae8749] StatsAPI v1.0.0\n  [2913bbd2] StatsBase v0.33.8\n  [4c63d2b9] StatsFuns v0.9.8\n  [9672c7b4] SteadyStateDiffEq v1.6.2\n  [789caeaf] StochasticDiffEq v6.34.1\n  [7792a7ef] StrideArraysCore v0.1.11\n  [09ab397b] StructArrays v0.5.1\n  [c3572dad] Sundials v4.4.3\n  [d1185830] SymbolicUtils v0.11.2\n  [0c5d862f] Symbolics v0.1.25\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.4.2\n  [5d786b92] TerminalLoggers v0.1.3\n  [8290d209] ThreadingUtilities v0.4.4\n  [a759f4b9] TimerOutputs v0.5.9\n  [0796e94c] Tokenize v0.5.16\n  [9f7883ad] Tracker v0.2.16\n  [3bb67fe8] TranscodingStreams v0.9.5\n  [592b5752] Trapz v2.0.2\n  [a2a6695c] TreeViews v0.3.0\n  [5c2747f8] URIs v1.3.0\n  [3a884ed6] UnPack v1.0.2\n  [1986cc42] Unitful v1.7.0\n  [3d5dd08c] VectorizationBase v0.20.11\n  [81def892] VersionParsing v1.2.0\n  [19fa3120] VertexSafeGraphs v0.1.2\n  [44d3d7a6] Weave v0.10.8\n  [efce3f68] WoodburyMatrices v0.5.3\n  [ddb6d928] YAML v0.4.6\n  [c2297ded] ZMQ v1.2.1\n  [a5390f91] ZipFile v0.9.3\n  [e88e6eb3] Zygote v0.6.11\n  [700de1a5] ZygoteRules v0.2.1\n  [6e34b625] Bzip2_jll v1.0.6+5\n  [83423d85] Cairo_jll v1.16.0+6\n  [3bed1096] Cuba_jll v4.2.1+0\n  [7bc98958] Cubature_jll v1.0.4+0\n  [5ae413db] EarCut_jll v2.1.5+1\n  [2e619515] Expat_jll v2.2.10+0\n  [b22a6f82] FFMPEG_jll v4.3.1+4\n  [f5851436] FFTW_jll v3.3.9+7\n  [a3f928ae] Fontconfig_jll v2.13.1+14\n  [d7e528f0] FreeType2_jll v2.10.1+5\n  [559328eb] FriBidi_jll v1.0.5+6\n  [0656b61e] GLFW_jll v3.3.4+0\n  [d2c73de3] GR_jll v0.57.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.1+0\n  [e33a78d0] Hwloc_jll v2.4.1+0\n  [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2\n  [aacddb02] JpegTurbo_jll v2.0.1+3\n  [c1c5ebd0] LAME_jll v3.100.0+3\n  [dd4b983a] LZO_jll v2.10.1+0\n  [dd192d2f] LibVPX_jll v1.9.0+1\n  [e9f186c6] Libffi_jll v3.2.2+0\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+0\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.1.0+2\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [856f044c] MKL_jll v2021.1.1+1\n  [e7412a2a] Ogg_jll v1.3.4+2\n  [458c3c95] OpenSSL_jll v1.1.1+6\n  [efe28fd5] OpenSpecFun_jll v0.5.4+0\n  [91d4177d] Opus_jll v1.3.1+3\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.2+0\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.0+1\n  [a2964d1f] Wayland_jll v1.17.0+4\n  [2381bf8a] Wayland_protocols_jll v1.18.0+4\n  [02c8fc9c] XML2_jll v2.9.12+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.2+6\n  [3161d3a3] Zstd_jll v1.5.0+0\n  [0ac62f75] libass_jll v0.14.0+4\n  [f638f0a6] libfdk_aac_jll v0.1.6+4\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.6+6\n  [1270edf5] x264_jll v2020.7.14+2\n  [dfaa095f] x265_jll v3.0.0+3\n  [d8fb68d0] xkbcommon_jll v0.9.1+5\n  [0dad84c5] ArgTools\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [4af54fe1] LazyArtifacts\n  [b27032c2] LibCURL\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions\n  [44cfe95a] Pkg\n  [de0858da] Printf\n  [9abbd945] Profile\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML\n  [a4e569a6] Tar\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll\n  [deac9b47] LibCURL_jll\n  [29816b5a] LibSSH2_jll\n  [c8ffd9c3] MbedTLS_jll\n  [14a3606d] MozillaCACerts_jll\n  [4536629a] OpenBLAS_jll\n  [bea87d4a] SuiteSparse_jll\n  [83775a58] Zlib_jll\n  [8e850ede] nghttp2_jll\n  [3f19e933] p7zip_jll","category":"page"},{"location":"#SciMLTutorials.jl:-Tutorials-for-Scientific-Machine-Learning-and-Differential-Equations","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning and Differential Equations","text":"","category":"section"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","text":"(Image: Build status)","category":"page"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","text":"(Image: Join the chat at https://gitter.im/JuliaDiffEq/Lobby)","category":"page"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","text":"SciMLTutorials.jl holds PDFs, webpages, and interactive Jupyter notebooks showing how to utilize the software in the SciML Scientific Machine Learning ecosystem. This set of tutorials was made to complement the documentation and the devdocs by providing practical examples of the concepts. For more details, please consult the docs.","category":"page"},{"location":"#Interactive-Notebooks","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","title":"Interactive Notebooks","text":"","category":"section"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","text":"To run the tutorials interactively via Jupyter notebooks, install the package and open the tutorials like:","category":"page"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","text":"using Pkg\npkg\"add https://github.com/SciML/SciMLTutorials.jl\"\nusing SciMLTutorials\nSciMLTutorials.open_notebooks()","category":"page"},{"location":"#Video-Tutorial","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","title":"Video Tutorial","text":"","category":"section"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","text":"(Image: Video Tutorial)","category":"page"},{"location":"#Table-of-Contents","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","text":"Introduction\nIntroduction to DifferentialEquations.jl through ODEs\nDetecting Stiffness and Choosing an ODE Algorithm\nOptimizing your DiffEq Code\nCallbacks and Event Handling\nFormatting Plots\nExercise Sheets\nDifferentialEquations.jl Workshop Exercises\nDifferentialEquations.jl Workshop Exercise Solutions\nModeling Examples\nClassical Physics Models\nConditional Dosing Example\nDiffEqBiological Tutorial I: Introduction\nDiffEqBiological Tutorial II: Network Properties API\nDiffEqBiological Tutorial III: Steady-States and Bifurcations\nTutorial on using spatial SSAs in DiffEqJump\nKepler Problem Orbit\nSpiking Neural Systems\nAdvanced ODE Features\nFeagin's Order 10, 12, and 14 Methods\nFinding Maxima and Minima of DiffEq Solutions\nModel Inference\nBayesian Inference of Pendulum Parameters\nMonte Carlo Parameter Estimation from Data\nType Handling\nSolving Equations with Julia-Defined Types\nNumbers with Uncertainties\nUnit Check Arithmetic via Unitful.jl\nDiffEqUncertainty\nAn Intro to Expectations via DiffEqUncertainty.jl\nOptimization Under Uncertainty with DiffEqUncertainty.jl\nGPU-Accelerated Data-Driven Bayesian Uncertainty Quantification with Koopman Operators\nAdvanced\nA 2D Cardiac Electrophysiology Model (CUDA-accelerated PDE solver)\nSolving Stiff Equations\nSolving the heat equation with diffusion-implicit time-stepping\nKolmogorov Backward Equations\nPerturbation Theory\nMixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations\nMixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","category":"page"},{"location":"#Contributing","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","title":"Contributing","text":"","category":"section"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","text":"First of all, make sure that your current directory is SciMLTutorials. All of the files are generated from the Weave.jl files in the tutorials folder. To run the generation process, do for example:","category":"page"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","text":"using Pkg, SciMLTutorials\ncd(joinpath(dirname(pathof(SciMLTutorials)), \"..\"))\nPkg.pkg\"activate .\"\nPkg.pkg\"instantiate\"\nSciMLTutorials.weave_file(\"introduction\",\"01-ode_introduction.jmd\")","category":"page"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","text":"To generate all of the notebooks, do:","category":"page"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","text":"SciMLTutorials.weave_all()","category":"page"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science","text":"If you add new tutorials which require new packages, simply updating your local environment will change the project and manifest files. When this occurs, the updated environment files should be included in the PR.","category":"page"}]
}

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DiffEqBiological Tutorial II: Network Properties API · The SciML Tutorials</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://tutorials.sciml.ai/stable/models/04-diffeqbio_II_networkproperties/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">The SciML Tutorials</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science</a></li><li><span class="tocitem">DiffEqUncertainty</span><ul><li><a class="tocitem" href="../../DiffEqUncertainty/01-expectation_introduction/">An Intro to Expectations via DiffEqUncertainty.jl</a></li><li><a class="tocitem" href="../../DiffEqUncertainty/02-AD_and_optimization/">Optimization Under Uncertainty with DiffEqUncertainty.jl</a></li></ul></li><li><span class="tocitem">advanced</span><ul><li><a class="tocitem" href="../../advanced/01-beeler_reuter/">An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model</a></li><li><a class="tocitem" href="../../advanced/02-advanced_ODE_solving/">Solving Stiff Equations</a></li><li><a class="tocitem" href="../../advanced/03-kolmogorov_equations/">Kolmogorov Backward Equations</a></li><li><a class="tocitem" href="../../advanced/04-diffusion_implicit_heat_equation/">Solving the heat equation with diffusion-implicit time-stepping</a></li></ul></li><li><span class="tocitem">exercises</span><ul><li><a class="tocitem" href="../../exercises/01-workshop_exercises/">SciML Workshop Exercises</a></li><li><a class="tocitem" href="../../exercises/02-workshop_solutions/">SciML Workshop Exercise Solutions</a></li></ul></li><li><span class="tocitem">introduction</span><ul><li><a class="tocitem" href="../../introduction/01-ode_introduction/">An Intro to DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../introduction/02-choosing_algs/">Choosing an ODE Algorithm</a></li><li><a class="tocitem" href="../../introduction/03-optimizing_diffeq_code/">Optimizing DiffEq Code</a></li><li><a class="tocitem" href="../../introduction/04-callbacks_and_events/">Callbacks and Events</a></li><li><a class="tocitem" href="../../introduction/05-formatting_plots/">Formatting Plots</a></li></ul></li><li><span class="tocitem">jumps</span><ul><li><a class="tocitem" href="../../jumps/spatial/">Ilin</a></li></ul></li><li><span class="tocitem">model_inference</span><ul><li><a class="tocitem" href="../../model_inference/01-pendulum_bayesian_inference/">Bayesian Inference on a Pendulum using DiffEqBayes.jl</a></li><li><a class="tocitem" href="../../model_inference/02-monte_carlo_parameter_estim/">Monte Carlo Parameter Estimation From Data</a></li></ul></li><li><span class="tocitem">models</span><ul><li><a class="tocitem" href="../01-classical_physics/">Classical Physics Models</a></li><li><a class="tocitem" href="../02-conditional_dosing/">Conditional Dosing Pharmacometric Example</a></li><li><a class="tocitem" href="../03-diffeqbio_I_introduction/">DiffEqBiological Tutorial I: Introduction</a></li><li class="is-active"><a class="tocitem" href>DiffEqBiological Tutorial II: Network Properties API</a><ul class="internal"><li><a class="tocitem" href="#Network-Properties"><span>Network Properties</span></a></li><li><a class="tocitem" href="#Incremental-Construction-of-Networks"><span>Incremental Construction of Networks</span></a></li><li><a class="tocitem" href="#Extending-Incrementally-Generated-Networks-to-Include-ODEs,-SDEs-or-Jumps"><span>Extending Incrementally Generated Networks to Include ODEs, SDEs or Jumps</span></a></li><li><a class="tocitem" href="#Example-of-Generating-a-Network-Programmatically"><span>Example of Generating a Network Programmatically</span></a></li><li><a class="tocitem" href="#Getting-Help"><span>Getting Help</span></a></li></ul></li><li><a class="tocitem" href="../04b-diffeqbio_III_steadystates/">DiffEqBiological Tutorial III: Steady-States and Bifurcations</a></li><li><a class="tocitem" href="../05-kepler_problem/">Kepler Problem</a></li><li><a class="tocitem" href="../06-pendulum_bayesian_inference/">Bayesian Inference on a Pendulum</a></li><li><a class="tocitem" href="../07-outer_solar_system/">The Outer Solar System</a></li><li><a class="tocitem" href="../08-spiking_neural_systems/">Spiking Neural Systems</a></li></ul></li><li><span class="tocitem">ode_extras</span><ul><li><a class="tocitem" href="../../ode_extras/01-ModelingToolkit/">ModelingToolkit.jl, An IR and Compiler for Scientific Models</a></li><li><a class="tocitem" href="../../ode_extras/02-feagin/">Feagin&#39;s Order 10, 12, and 14 Methods</a></li><li><a class="tocitem" href="../../ode_extras/03-ode_minmax/">Finding Maxima and Minima of DiffEq Solutions</a></li></ul></li><li><span class="tocitem">perturbation</span><ul><li><a class="tocitem" href="../../perturbation/01-perturbation_algebraic/">Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations</a></li><li><a class="tocitem" href="../../perturbation/02-perturbation_differential/">Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations</a></li></ul></li><li><span class="tocitem">type_handling</span><ul><li><a class="tocitem" href="../../type_handling/02-uncertainties/">Numbers with Uncertainties</a></li><li><a class="tocitem" href="../../type_handling/03-unitful/">Unit Checked Arithmetic via Unitful.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">models</a></li><li class="is-active"><a href>DiffEqBiological Tutorial II: Network Properties API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DiffEqBiological Tutorial II: Network Properties API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/SciMLTutorialsOutput/blob/main/docs/src/models/04-diffeqbio_II_networkproperties.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DiffEqBiological-Tutorial-II:-Network-Properties-API"><a class="docs-heading-anchor" href="#DiffEqBiological-Tutorial-II:-Network-Properties-API">DiffEqBiological Tutorial II: Network Properties API</a><a id="DiffEqBiological-Tutorial-II:-Network-Properties-API-1"></a><a class="docs-heading-anchor-permalink" href="#DiffEqBiological-Tutorial-II:-Network-Properties-API" title="Permalink"></a></h1><p>The <a href="https://docs.sciml.ai/dev/apis/diffeqbio">DiffEqBiological API</a> provides a collection of functions for easily accessing network properties, and for incrementally building and extending a network. In this tutorial we&#39;ll go through the API, and then illustrate how to programmatically construct a network.</p><p>We&#39;ll illustrate the API using a toggle-switch like network that contains a variety of different reaction types:</p><pre><code class="language-julia hljs">using DifferentialEquations, DiffEqBiological, Latexify, Plots
fmt = :svg
pyplot(fmt=fmt)
rn = @reaction_network begin
    hillr(D₂,α,K,n), ∅ --&gt; m₁
    hillr(D₁,α,K,n), ∅ --&gt; m₂
    (δ,γ), m₁ ↔ ∅
    (δ,γ), m₂ ↔ ∅
    β, m₁ --&gt; m₁ + P₁
    β, m₂ --&gt; m₂ + P₂
    μ, P₁ --&gt; ∅
    μ, P₂ --&gt; ∅
    (k₊,k₋), 2P₁ ↔ D₁
    (k₊,k₋), 2P₂ ↔ D₂
    (k₊,k₋), P₁+P₂ ↔ T
end α K n δ γ β μ k₊ k₋;</code></pre><pre><code class="nohighlight hljs">Error: ArgumentError: Package DiffEqBiological not found in current path:
- Run `import Pkg; Pkg.add(&quot;DiffEqBiological&quot;)` to install the DiffEqBiolog
ical package.</code></pre><p>This corresponds to the chemical reaction network given by</p><pre><code class="language-julia hljs">latexify(rn; env=:chemical)</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: latexify not defined</code></pre><hr/><h2 id="Network-Properties"><a class="docs-heading-anchor" href="#Network-Properties">Network Properties</a><a id="Network-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Network-Properties" title="Permalink"></a></h2><p><a href="https://docs.sciml.ai/latest/apis/diffeqbio/#Basic-properties-1">Basic properties</a> of the generated network include the <code>speciesmap</code> and <code>paramsmap</code> functions we examined in the last tutorial, along with the corresponding <code>species</code> and <code>params</code> functions:</p><pre><code class="language-julia hljs">species(rn)</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: species not defined</code></pre><pre><code class="language-julia hljs">params(rn)</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: params not defined</code></pre><p>The numbers of species, parameters and reactions can be accessed using <code>numspecies(rn)</code>, <code>numparams(rn)</code> and <code>numreactions(rn)</code>.</p><p>A number of functions are available to access <a href="https://docs.sciml.ai/latest/apis/diffeqbio/#Reaction-Properties-1">properties of reactions</a> within the generated network, including <code>substrates</code>, <code>products</code>, <code>dependents</code>, <code>ismassaction</code>, <code>substratestoich</code>, <code>substratesymstoich</code>, <code>productstoich</code>, <code>productsymstoich</code>, and <code>netstoich</code>. Each of these functions takes two arguments, the reaction network <code>rn</code> and the index of the reaction to query information about. For example, to find the substrate symbols and their corresponding stoichiometries for the 11th reaction, <code>2P₁ --&gt; D₁</code>, we would use</p><pre><code class="language-julia hljs">substratesymstoich(rn, 11)</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: substratesymstoich not defined</code></pre><p>Broadcasting works on all these functions, allowing the construction of a vector holding the queried information across all reactions, i.e.</p><pre><code class="language-julia hljs">substratesymstoich.(rn, 1:numreactions(rn))</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: numreactions not defined</code></pre><p>To see the net stoichiometries for all reactions we would use</p><pre><code class="language-julia hljs">netstoich.(rn, 1:numreactions(rn))</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: numreactions not defined</code></pre><p>Here the first integer in each pair corresponds to the index of the species (with symbol <code>species(rn)[index]</code>). The second integer corresponds to the net stoichiometric coefficient of the species within the reaction. <code>substratestoich</code> and <code>productstoich</code> are defined similarly.</p><p>Several functions are also provided that calculate different types of <a href="https://docs.sciml.ai/latest/apis/diffeqbio/#Dependency-Graphs-1">dependency graphs</a>. These include <code>rxtospecies_depgraph</code>, which provides a mapping from reaction index to the indices of species whose population changes when the reaction occurs:</p><pre><code class="language-julia hljs">rxtospecies_depgraph(rn)</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: rxtospecies_depgraph not defined</code></pre><p>Here the last row indicates that the species with indices <code>[3,4,7]</code> will change values when the reaction <code>T --&gt; P₁ + P₂</code> occurs. To confirm these are the correct species we can look at</p><pre><code class="language-julia hljs">species(rn)[[3,4,7]]</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: species not defined</code></pre><p>The <code>speciestorx_depgraph</code> similarly provides a mapping from species to reactions for which their <em>rate laws</em> depend on that species. These correspond to all reactions for which the given species is in the <code>dependent</code> set of the reaction. We can verify this for the first species, <code>m₁</code>:</p><pre><code class="language-julia hljs">speciestorx_depgraph(rn)[1]</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: speciestorx_depgraph not defined</code></pre><pre><code class="language-julia hljs">findall(depset -&gt; in(:m₁, depset), dependents.(rn, 1:numreactions(rn)))</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: numreactions not defined</code></pre><p>Finally, <code>rxtorx_depgraph</code> provides a mapping that shows when a given reaction occurs, which other reactions have rate laws that involve species whose value would have changed:</p><pre><code class="language-julia hljs">rxtorx_depgraph(rn)</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: rxtorx_depgraph not defined</code></pre><h4 id="Note-on-Using-Network-Property-API-Functions"><a class="docs-heading-anchor" href="#Note-on-Using-Network-Property-API-Functions">Note on Using Network Property API Functions</a><a id="Note-on-Using-Network-Property-API-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Note-on-Using-Network-Property-API-Functions" title="Permalink"></a></h4><p>Many basic network query and reaction property functions are simply accessors, returning information that is already stored within the generated <code>reaction_network</code>. For these functions, modifying the returned data structures may lead to inconsistent internal state within the network. As such, they should be used for accessing, but not modifying, network properties. The <a href="https://docs.sciml.ai/dev/apis/diffeqbio">API documentation</a> indicates which functions return newly allocated data structures and which return data stored within the <code>reaction_network</code>.</p><hr/><h2 id="Incremental-Construction-of-Networks"><a class="docs-heading-anchor" href="#Incremental-Construction-of-Networks">Incremental Construction of Networks</a><a id="Incremental-Construction-of-Networks-1"></a><a class="docs-heading-anchor-permalink" href="#Incremental-Construction-of-Networks" title="Permalink"></a></h2><p>The <code>@reaction_network</code> macro is monolithic, in that it not only constructs and stores basic network properties such as the reaction stoichiometries, but also generates <strong>everything</strong> needed to immediately solve ODE, SDE and jump models using the network. This includes Jacobian functions, noise functions, and jump functions for each reaction. While this allows for a compact interface to the DifferentialEquations.jl solvers, it can also be computationally expensive for large networks, where a user may only wish to solve one type of problem and/or have fine-grained control over what is generated. In addition, some types of reaction network structures are more amenable to being constructed programmatically, as opposed to writing out all reactions by hand within one macro. For these reasons DiffEqBiological provides two additional macros that only <em>initially</em> setup basic reaction network properties, and which can be extended through a programmatic interface: <code>@min_reaction_network</code> and <code>@empty_reaction_network</code>. We now give an introduction to constructing these more minimal network representations, and how they can be programmatically extended. See also the relevant <a href="https://docs.sciml.ai/latest/apis/diffeqbio/#Reaction-Network-Generation-Macros-1">API section</a>.</p><p>The <code>@min_reaction_network</code> macro works identically to the <code>@reaction_network</code> macro, but the generated network will only be complete with respect to its representation of chemical network properties (i.e. species, parameters and reactions). No ODE, SDE or jump models are generated during the macro call. It can subsequently be extended with the addition of new species, parameters or reactions. The <code>@empty_reaction_network</code> allocates an empty network structure that can also be extended using the programmatic interface. For example, consider a partial version of the toggle-switch like network we defined above:</p><pre><code class="language-julia hljs">rnmin = @min_reaction_network begin
    (δ,γ), m₁ ↔ ∅
    (δ,γ), m₂ ↔ ∅
    β, m₁ --&gt; m₁ + P₁
    β, m₂ --&gt; m₂ + P₂
    μ, P₁ --&gt; ∅
    μ, P₂ --&gt; ∅
end δ γ β μ;</code></pre><pre><code class="nohighlight hljs">Error: LoadError: UndefVarError: @min_reaction_network not defined
in expression starting at /var/lib/buildkite-agent/builds/1-amdci4-julia-cs
ail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/models/04-diffeqbio_I
I_networkproperties.jmd:2</code></pre><p>Here we have left out the first two, and last three, reactions from the original <code>reaction_network</code>. To expand the network until it is functionally equivalent to the original model we add back in the missing species, parameters, and <em>finally</em> the missing reactions. Note, it is required that species and parameters be defined before any reactions using them are added. The necessary network extension functions are given by <code>addspecies!</code>, <code>addparam!</code> and <code>addreaction!</code>, and described in the <a href="https://docs.sciml.ai/latest/apis/diffeqbio/#Functions-to-Add-Species,-Parameters-and-Reactions-to-a-Network-1">API</a>. To complete <code>rnmin</code> we first add the relevant species:</p><pre><code class="language-julia hljs">addspecies!(rnmin, :D₁)
addspecies!(rnmin, :D₂)
addspecies!(rnmin, :T)</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: addspecies! not defined</code></pre><p>Next we add the needed parameters</p><pre><code class="language-julia hljs">addparam!(rnmin, :α)
addparam!(rnmin, :K)
addparam!(rnmin, :n)
addparam!(rnmin, :k₊)
addparam!(rnmin, :k₋)</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: addparam! not defined</code></pre><p>Note, both <code>addspecies!</code> and <code>addparam!</code> also accept strings encoding the variable names (which are then converted to <code>Symbol</code>s internally).</p><p>We are now ready to add the missing reactions. The API provides two forms of the <code>addreaction!</code> function, one takes expressions analogous to what one would write in the macro:</p><pre><code class="language-julia hljs">addreaction!(rnmin, :(hillr(D₁,α,K,n)), :(∅ --&gt; m₂))
addreaction!(rnmin, :((k₊,k₋)), :(2P₂ ↔ D₂))
addreaction!(rnmin, :k₊, :(2P₁ --&gt; D₁))
addreaction!(rnmin, :k₋, :(D₁ --&gt; 2P₁))</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: addreaction! not defined</code></pre><p>The rate can be an expression or symbol as above, but can also just be a numeric value. The second form of <code>addreaction!</code> takes tuples of <code>Pair{Symbol,Int}</code> that encode the stoichiometric coefficients of substrates and reactants:</p><pre><code class="language-julia hljs"># signature is addreaction!(rnmin, paramexpr, substratestoich, productstoich)
addreaction!(rnmin, :(hillr(D₂,α,K,n)), (), (:m₁ =&gt; 1,))
addreaction!(rnmin, :k₊, (:P₁=&gt;1, :P₂=&gt;1), (:T=&gt;1,))
addreaction!(rnmin, :k₋, (:T=&gt;1,), (:P₁=&gt;1, :P₂=&gt;1))</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: addreaction! not defined</code></pre><p>Let&#39;s check that <code>rn</code> and <code>rnmin</code> have the same set of species:</p><pre><code class="language-julia hljs">setdiff(species(rn), species(rnmin))</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: species not defined</code></pre><p>the same set of params:</p><pre><code class="language-julia hljs">setdiff(params(rn), params(rnmin))</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: params not defined</code></pre><p>and the final reaction has the same substrates, reactions, and rate expression:</p><pre><code class="language-julia hljs">rxidx = numreactions(rn)
setdiff(substrates(rn, rxidx), substrates(rnmin, rxidx))</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: numreactions not defined</code></pre><pre><code class="language-julia hljs">setdiff(products(rn, rxidx), products(rnmin, rxidx))</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: products not defined</code></pre><pre><code class="language-julia hljs">rateexpr(rn, rxidx) == rateexpr(rnmin, rxidx)</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: rateexpr not defined</code></pre><hr/><h2 id="Extending-Incrementally-Generated-Networks-to-Include-ODEs,-SDEs-or-Jumps"><a class="docs-heading-anchor" href="#Extending-Incrementally-Generated-Networks-to-Include-ODEs,-SDEs-or-Jumps">Extending Incrementally Generated Networks to Include ODEs, SDEs or Jumps</a><a id="Extending-Incrementally-Generated-Networks-to-Include-ODEs,-SDEs-or-Jumps-1"></a><a class="docs-heading-anchor-permalink" href="#Extending-Incrementally-Generated-Networks-to-Include-ODEs,-SDEs-or-Jumps" title="Permalink"></a></h2><p>Once a network generated from <code>@min_reaction_network</code> or <code>@empty_reaction_network</code> has had all the associated species, parameters and reactions filled in, corresponding ODE, SDE or jump models can be constructed. The relevant API functions are <code>addodes!</code>, <code>addsdes!</code> and <code>addjumps!</code>. One benefit to contructing models with these functions is that they offer more fine-grained control over what actually gets constructed. For example, <code>addodes!</code> has the optional keyword argument, <code>build_jac</code>, which if set to <code>false</code> will disable construction of symbolic Jacobians and functions for evaluating Jacobians. For large networks this can give a significant speed-up in the time required for constructing an ODE model. Each function and its associated keyword arguments are described in the API section, <a href="https://docs.sciml.ai/latest/apis/diffeqbio/#Functions-to-Add-ODEs,-SDEs-or-Jumps-to-a-Network-1">Functions to add ODEs, SDEs or Jumps to a Network</a>.</p><p>Let&#39;s extend <code>rnmin</code> to include the needed functions for use in ODE solvers:</p><pre><code class="language-julia hljs">addodes!(rnmin)</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: addodes! not defined</code></pre><p>The <a href="https://docs.sciml.ai/latest/apis/diffeqbio/#Generated-Functions-for-Models-1">Generated Functions for Models</a> section of the API shows what functions have been generated. For ODEs these include <code>oderhsfun(rnmin)</code>, which returns a function of the form <code>f(du,u,p,t)</code> which evaluates the ODEs (i.e. the time derivatives of <code>u</code>) within <code>du</code>. For each generated function, the corresponding expressions from which it was generated can be retrieved using accessors from the <a href="https://docs.sciml.ai/latest/apis/diffeqbio/#Generated-Expressions-1">Generated Expressions</a> section of the API. The equations within <code>du</code> can be retrieved using the <code>odeexprs(rnmin)</code> function. For example:</p><pre><code class="language-julia hljs">odeexprs(rnmin)</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: odeexprs not defined</code></pre><p>Using Latexify we can see the ODEs themselves to compare with these expressions:</p><pre><code class="language-julia hljs">latexify(rnmin)</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: latexify not defined</code></pre><p>For ODEs two other functions are generated by <code>addodes!</code>. <code>jacfun(rnmin)</code> will return the generated Jacobian evaluation function, <code>fjac(dJ,u,p,t)</code>, which given the current solution <code>u</code> evaluates the Jacobian within <code>dJ</code>. <code>jacobianexprs(rnmin)</code> gives the corresponding matrix of expressions, which can be used with Latexify to see the Jacobian:</p><pre><code class="language-julia hljs">latexify(jacobianexprs(rnmin))</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: jacobianexprs not defined</code></pre><p><code>addodes!</code> also generates a function that evaluates the Jacobian of the ODE derivative functions with respect to the parameters. <code>paramjacfun(rnmin)</code> then returns the generated function. It has the form <code>fpjac(dPJ,u,p,t)</code>, which given the current solution <code>u</code> evaluates the Jacobian matrix with respect to parameters <code>p</code> within <code>dPJ</code>. For use in DifferentialEquations.jl solvers, an <a href="https://docs.sciml.ai/dev/features/performance_overloads"><code>ODEFunction</code></a> representation of the ODEs is available from <code>odefun(rnmin)</code>.</p><p><code>addsdes!</code> and <code>addjumps!</code> work similarly to complete the network for use in StochasticDiffEq and DiffEqJump solvers.</p><h4 id="Note-on-Using-Generated-Function-and-Expression-API-Functions"><a class="docs-heading-anchor" href="#Note-on-Using-Generated-Function-and-Expression-API-Functions">Note on Using Generated Function and Expression API Functions</a><a id="Note-on-Using-Generated-Function-and-Expression-API-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Note-on-Using-Generated-Function-and-Expression-API-Functions" title="Permalink"></a></h4><p>The generated functions and expressions accessible through the API require first calling the appropriate <code>addodes!</code>, <code>addsdes</code> or <code>addjumps</code> function. These are responsible for actually constructing the underlying functions and expressions. The API accessors simply return already constructed functions and expressions that are stored within the <code>reaction_network</code> structure.</p><hr/><h2 id="Example-of-Generating-a-Network-Programmatically"><a class="docs-heading-anchor" href="#Example-of-Generating-a-Network-Programmatically">Example of Generating a Network Programmatically</a><a id="Example-of-Generating-a-Network-Programmatically-1"></a><a class="docs-heading-anchor-permalink" href="#Example-of-Generating-a-Network-Programmatically" title="Permalink"></a></h2><p>For a user directly typing in a reaction network, it is generally easier to use the <code>@min_reaction_network</code> or <code>@reaction_network</code> macros to fully specify reactions. However, for large, structured networks it can be much easier to generate the network programmatically. For very large networks, with tens of thousands of reactions, the form of <code>addreaction!</code> that uses stoichiometric coefficients should be preferred as it offers substantially better performance. To put together everything we&#39;ve seen, let&#39;s generate the network corresponding to a 1D continuous time random walk, approximating the diffusion of molecules within an interval.</p><p>The basic &quot;reaction&quot; network we wish to study is</p>$<p>u<em>1 \leftrightarrows u</em>2 \leftrightarrows u<em>3 \cdots \leftrightarrows u</em>{N} $</p><p>for <span>$N$</span> lattice sites on <span>$[0,1]$</span>. For <span>$h = 1/N$</span> the lattice spacing, we&#39;ll assume the rate molecules hop from their current site to any particular neighbor is just <span>$h^{-2}$</span>. We can interpret this hopping process as a collection of <span>$2N-2$</span> &quot;reactions&quot;, with the form <span>$u_i \to u_j$</span> for <span>$j=i+1$</span> or <span>$j=i-1$</span>. We construct the corresponding reaction network as follows. First we set values for the basic parameters:</p><pre><code class="language-julia hljs">N = 64
h = 1 / N</code></pre><pre><code class="nohighlight hljs">0.015625</code></pre><p>then we create an empty network, and add each species</p><pre><code class="language-julia hljs">rn = @empty_reaction_network

for i = 1:N
    addspecies!(rn, Symbol(:u, i))
end</code></pre><pre><code class="nohighlight hljs">Error: LoadError: UndefVarError: @empty_reaction_network not defined
in expression starting at /var/lib/buildkite-agent/builds/1-amdci4-julia-cs
ail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/models/04-diffeqbio_I
I_networkproperties.jmd:2</code></pre><p>We next add one parameter <code>β</code>, which we will set equal to the hopping rate of molecules, <span>$h^{-2}$</span>:</p><pre><code class="language-julia hljs">addparam!(rn, :β)</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: addparam! not defined</code></pre><p>Finally, we add in the <span>$2N-2$</span> possible hopping reactions:</p><pre><code class="language-julia hljs">for i = 1:N
    (i &lt; N) &amp;&amp; addreaction!(rn, :β, (Symbol(:u,i)=&gt;1,), (Symbol(:u,i+1)=&gt;1,))
    (i &gt; 1) &amp;&amp; addreaction!(rn, :β, (Symbol(:u,i)=&gt;1,), (Symbol(:u,i-1)=&gt;1,))
end</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: addreaction! not defined</code></pre><p>Let&#39;s first construct an ODE model for the network</p><pre><code class="language-julia hljs">addodes!(rn)</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: addodes! not defined</code></pre><p>We now need to specify the initial condition, parameter vector and time interval to solve on. We start with 10000 molecules placed at the center of the domain, and setup an <code>ODEProblem</code> to solve:</p><pre><code class="language-julia hljs">u₀ = zeros(N)
u₀[div(N,2)] = 10000
p = [1/(h*h)]
tspan = (0.,.01)
oprob = ODEProblem(rn, u₀, tspan, p)</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: rn not defined</code></pre><p>We are now ready to solve the problem and plot the solution. Since we have essentially generated a method of lines discretization of the diffusion equation with a discontinuous initial condition, we&#39;ll use an A-L stable implicit ODE solver, <code>Rodas5</code>, and plot the solution at a few times:</p><pre><code class="language-julia hljs">sol = solve(oprob, Rodas5())
times = [0., .0001, .001, .01]
plt = plot()
for time in times
    plot!(plt, 1:N, sol(time), fmt=fmt, xlabel=&quot;i&quot;, ylabel=&quot;uᵢ&quot;, label=string(&quot;t = &quot;, time), lw=3)
end
plot(plt, ylims=(0.,10000.))</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: oprob not defined</code></pre><p>Here we see the characteristic diffusion of molecules from the center of the domain, resulting in a shortening and widening of the solution as <span>$t$</span> increases.</p><p>Let&#39;s now look at a stochastic chemical kinetics jump process version of the model, where β gives the probability per time each molecule can hop from its current lattice site to an individual neighboring site. We first add in the jumps, disabling <code>regular_jumps</code> since they are not needed, and using the <code>minimal_jumps</code> flag to construct a minimal representation of the needed jumps. We then construct a <code>JumpProblem</code>, and use the Composition-Rejection Direct method, <code>DirectCR</code>, to simulate the process of the molecules hopping about on the lattice:</p><pre><code class="language-julia hljs">addjumps!(rn, build_regular_jumps=false, minimal_jumps=true)

# make the initial condition integer valued
u₀ = zeros(Int, N)
u₀[div(N,2)] = 10000

# setup and solve the problem
dprob = DiscreteProblem(rn, u₀, tspan, p)
jprob = JumpProblem(dprob, DirectCR(), rn, save_positions=(false,false))
jsol = solve(jprob, SSAStepper(), saveat=times)</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: addjumps! not defined</code></pre><p>We can now plot bar graphs showing the locations of the molecules at the same set of times we examined the ODE solution. For comparison, we also plot the corresponding ODE solutions (red lines) that we found:</p><pre><code class="language-julia hljs">times = [0., .0001, .001, .01]
plts = []
for i = 1:4
    b = bar(1:N, jsol[i], legend=false, fmt=fmt, xlabel=&quot;i&quot;, ylabel=&quot;uᵢ&quot;, title=string(&quot;t = &quot;, times[i]))
    plot!(b,sol(times[i]))
    push!(plts,b)
end
plot(plts...)</code></pre><pre><code class="nohighlight hljs">Error: UndefVarError: jsol not defined</code></pre><p>Similar to the ODE solutions, we see that the molecules spread out and become more and more well-mixed throughout the domain as <span>$t$</span> increases. The simulation results are noisy due to the finite numbers of molecules present in the stochsatic simulation, but since the number of molecules is large they agree well with the ODE solution at each time.</p><hr/><h2 id="Getting-Help"><a class="docs-heading-anchor" href="#Getting-Help">Getting Help</a><a id="Getting-Help-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-Help" title="Permalink"></a></h2><p>Have a question related to DiffEqBiological or this tutorial? Feel free to ask in the DifferentialEquations.jl <a href="https://gitter.im/JuliaDiffEq/Lobby">Gitter</a>. If you think you&#39;ve found a bug in DiffEqBiological, or would like to request/discuss new functionality, feel free to open an issue on <a href="https://github.com/JuliaDiffEq/DiffEqBiological.jl">Github</a> (but please check there is no related issue already open). If you&#39;ve found a bug in this tutorial, or have a suggestion, feel free to open an issue on the <a href="https://github.com/JuliaDiffEq/SciMLTutorials.jl">SciMLTutorials Github site</a>. Or, submit a pull request to SciMLTutorials updating the tutorial!</p><hr/><pre><code class="nohighlight hljs">Error: MethodError: no method matching tutorial_footer(::String, ::String; 
remove_homedir=true)
Closest candidates are:
  tutorial_footer(::Any, ::Any) at /var/lib/buildkite-agent/builds/1-amdci4
-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/src/SciMLTutorials.jl:
79 got unsupported keyword argument &quot;remove_homedir&quot;
  tutorial_footer(::Any) at /var/lib/buildkite-agent/builds/1-amdci4-julia-
csail-mit-edu/julialang/scimltutorials-dot-jl/src/SciMLTutorials.jl:79 got 
unsupported keyword argument &quot;remove_homedir&quot;</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../03-diffeqbio_I_introduction/">« DiffEqBiological Tutorial I: Introduction</a><a class="docs-footer-nextpage" href="../04b-diffeqbio_III_steadystates/">DiffEqBiological Tutorial III: Steady-States and Bifurcations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Saturday 13 August 2022 03:50">Saturday 13 August 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

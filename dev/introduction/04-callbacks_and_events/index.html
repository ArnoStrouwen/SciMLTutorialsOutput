<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Callbacks and Events · The SciML Tutorials</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://tutorials.sciml.ai/stable/introduction/04-callbacks_and_events/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">The SciML Tutorials</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science</a></li><li><span class="tocitem">DiffEqUncertainty</span><ul><li><a class="tocitem" href="../../DiffEqUncertainty/01-expectation_introduction/">An Intro to Expectations via DiffEqUncertainty.jl</a></li><li><a class="tocitem" href="../../DiffEqUncertainty/02-AD_and_optimization/">Optimization Under Uncertainty with DiffEqUncertainty.jl</a></li></ul></li><li><span class="tocitem">advanced</span><ul><li><a class="tocitem" href="../../advanced/01-beeler_reuter/">An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model</a></li><li><a class="tocitem" href="../../advanced/02-advanced_ODE_solving/">Solving Stiff Equations</a></li><li><a class="tocitem" href="../../advanced/03-kolmogorov_equations/">Kolmogorov Backward Equations</a></li><li><a class="tocitem" href="../../advanced/04-diffusion_implicit_heat_equation/">Solving the heat equation with diffusion-implicit time-stepping</a></li></ul></li><li><span class="tocitem">exercises</span><ul><li><a class="tocitem" href="../../exercises/01-workshop_exercises/">SciML Workshop Exercises</a></li><li><a class="tocitem" href="../../exercises/02-workshop_solutions/">SciML Workshop Exercise Solutions</a></li></ul></li><li><span class="tocitem">introduction</span><ul><li><a class="tocitem" href="../01-ode_introduction/">An Intro to DifferentialEquations.jl</a></li><li><a class="tocitem" href="../02-choosing_algs/">Choosing an ODE Algorithm</a></li><li><a class="tocitem" href="../03-optimizing_diffeq_code/">Optimizing DiffEq Code</a></li><li class="is-active"><a class="tocitem" href>Callbacks and Events</a><ul class="internal"><li><a class="tocitem" href="#Events-and-Continuous-Callbacks"><span>Events and Continuous Callbacks</span></a></li><li><a class="tocitem" href="#Discrete-Callbacks"><span>Discrete Callbacks</span></a></li><li><a class="tocitem" href="#Merging-Callbacks-with-Callback-Sets"><span>Merging Callbacks with Callback Sets</span></a></li><li><a class="tocitem" href="#Integration-Termination-and-Directional-Handling"><span>Integration Termination and Directional Handling</span></a></li><li><a class="tocitem" href="#Callback-Library"><span>Callback Library</span></a></li><li><a class="tocitem" href="#Appendix"><span>Appendix</span></a></li></ul></li><li><a class="tocitem" href="../05-formatting_plots/">Formatting Plots</a></li></ul></li><li><span class="tocitem">jumps</span><ul><li><a class="tocitem" href="../../jumps/spatial/">Ilin</a></li></ul></li><li><span class="tocitem">model_inference</span><ul><li><a class="tocitem" href="../../model_inference/01-pendulum_bayesian_inference/">Bayesian Inference on a Pendulum using DiffEqBayes.jl</a></li><li><a class="tocitem" href="../../model_inference/02-monte_carlo_parameter_estim/">Monte Carlo Parameter Estimation From Data</a></li></ul></li><li><span class="tocitem">models</span><ul><li><a class="tocitem" href="../../models/01-classical_physics/">Classical Physics Models</a></li><li><a class="tocitem" href="../../models/02-conditional_dosing/">Conditional Dosing Pharmacometric Example</a></li><li><a class="tocitem" href="../../models/03-diffeqbio_I_introduction/">DiffEqBiological Tutorial I: Introduction</a></li><li><a class="tocitem" href="../../models/04-diffeqbio_II_networkproperties/">DiffEqBiological Tutorial II: Network Properties API</a></li><li><a class="tocitem" href="../../models/04b-diffeqbio_III_steadystates/">DiffEqBiological Tutorial III: Steady-States and Bifurcations</a></li><li><a class="tocitem" href="../../models/05-kepler_problem/">Kepler Problem</a></li><li><a class="tocitem" href="../../models/07-outer_solar_system/">The Outer Solar System</a></li><li><a class="tocitem" href="../../models/08-spiking_neural_systems/">Spiking Neural Systems</a></li></ul></li><li><span class="tocitem">ode_extras</span><ul><li><a class="tocitem" href="../../ode_extras/01-ModelingToolkit/">ModelingToolkit.jl, An IR and Compiler for Scientific Models</a></li><li><a class="tocitem" href="../../ode_extras/02-feagin/">Feagin&#39;s Order 10, 12, and 14 Methods</a></li><li><a class="tocitem" href="../../ode_extras/03-ode_minmax/">Finding Maxima and Minima of DiffEq Solutions</a></li></ul></li><li><span class="tocitem">perturbation</span><ul><li><a class="tocitem" href="../../perturbation/01-perturbation_algebraic/">Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations</a></li><li><a class="tocitem" href="../../perturbation/02-perturbation_differential/">Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations</a></li></ul></li><li><span class="tocitem">type_handling</span><ul><li><a class="tocitem" href="../../type_handling/02-uncertainties/">Numbers with Uncertainties</a></li><li><a class="tocitem" href="../../type_handling/03-unitful/">Unit Checked Arithmetic via Unitful.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">introduction</a></li><li class="is-active"><a href>Callbacks and Events</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Callbacks and Events</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/SciMLTutorialsOutput/blob/main/docs/src/introduction/04-callbacks_and_events.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Callbacks-and-Events"><a class="docs-heading-anchor" href="#Callbacks-and-Events">Callbacks and Events</a><a id="Callbacks-and-Events-1"></a><a class="docs-heading-anchor-permalink" href="#Callbacks-and-Events" title="Permalink"></a></h1><p>In working with a differential equation, our system will evolve through many states. Particular states of the system may be of interest to us, and we say that an ***&quot;event&quot;*** is triggered when our system reaches these states. For example, events may include the moment when our system reaches a particular temperature or velocity. We ***handle*** these events with ***callbacks***, which tell us what to do once an event has been triggered.</p><p>These callbacks allow for a lot more than event handling, however. For example, we can use callbacks to achieve high-level behavior like exactly preserve conservation laws and save the trace of a matrix at pre-defined time points. This extra functionality allows us to use the callback system as a modding system for the DiffEq ecosystem&#39;s solvers.</p><p>This tutorial is an introduction to the callback and event handling system in DifferentialEquations.jl, documented in the <a href="https://docs.juliadiffeq.org/dev/features/callback_functions/">Event Handling and Callback Functions</a> page of the documentation. We will also introduce you to some of the most widely used callbacks in the <a href="https://docs.juliadiffeq.org/dev/features/callback_library/">Callback Library</a>, which is a library of pre-built mods.</p><h2 id="Events-and-Continuous-Callbacks"><a class="docs-heading-anchor" href="#Events-and-Continuous-Callbacks">Events and Continuous Callbacks</a><a id="Events-and-Continuous-Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Events-and-Continuous-Callbacks" title="Permalink"></a></h2><p>Event handling is done through continuous callbacks. Callbacks take a function, <code>condition</code>, which triggers an <code>affect!</code> when <code>condition == 0</code>. These callbacks are called &quot;continuous&quot; because they will utilize rootfinding on the interpolation to find the &quot;exact&quot; time point at which the condition takes place and apply the <code>affect!</code> at that time point.</p><p>***Let&#39;s use a bouncing ball as a simple system to explain events and callbacks.*** Let&#39;s take Newton&#39;s model of a ball falling towards the Earth&#39;s surface via a gravitational constant <code>g</code>. In this case, the velocity is changing via <code>-g</code>, and position is changing via the velocity. Therefore we receive the system of ODEs:</p><pre><code class="language-julia hljs">using DifferentialEquations, ParameterizedFunctions
ball! = @ode_def BallBounce begin
  dy =  v
  dv = -g
end g</code></pre><pre><code class="nohighlight hljs">(::Main.##WeaveSandBox#432.BallBounce{Main.##WeaveSandBox#432.var&quot;###Parame
terizedDiffEqFunction#452&quot;,Main.##WeaveSandBox#432.var&quot;###ParameterizedTGra
dFunction#453&quot;,Main.##WeaveSandBox#432.var&quot;###ParameterizedJacobianFunction
#454&quot;,Nothing,Nothing,ModelingToolkit.ODESystem}) (generic function with 1 
method)</code></pre><p>We want the callback to trigger when <code>y=0</code> since that&#39;s when the ball will hit the Earth&#39;s surface (our event). We do this with the condition:</p><pre><code class="language-julia hljs">function condition(u,t,integrator)
  u[1]
end</code></pre><pre><code class="nohighlight hljs">condition (generic function with 1 method)</code></pre><p>Recall that the <code>condition</code> will trigger when it evaluates to zero, and here it will evaluate to zero when <code>u[1] == 0</code>, which occurs when <code>v == 0</code>. <em>Now we have to say what we want the callback to do.</em> Callbacks make use of the <a href="https://docs.juliadiffeq.org/dev/basics/integrator/">Integrator Interface</a>. Instead of giving a full description, a quick and usable rundown is:</p><ul><li>Values are strored in <code>integrator.u</code></li><li>Times are stored in <code>integrator.t</code></li><li>The parameters are stored in <code>integrator.p</code></li><li><code>integrator(t)</code> performs an interpolation in the current interval between <code>integrator.tprev</code> and <code>integrator.t</code> (and allows extrapolation)</li><li>User-defined options (tolerances, etc.) are stored in <code>integrator.opts</code></li><li><code>integrator.sol</code> is the current solution object. Note that <code>integrator.sol.prob</code> is the current problem</li></ul><p>While there&#39;s a lot more on the integrator interface page, that&#39;s a working knowledge of what&#39;s there.</p><p>What we want to do with our <code>affect!</code> is to &quot;make the ball bounce&quot;. Mathematically speaking, the ball bounces when the sign of the velocity flips. As an added behavior, let&#39;s also use a small friction constant to dampen the ball&#39;s velocity. This way only a percentage of the velocity will be retained when the event is triggered and the callback is used.  We&#39;ll define this behavior in the <code>affect!</code> function:</p><pre><code class="language-julia hljs">function affect!(integrator)
    integrator.u[2] = -integrator.p[2] * integrator.u[2]
end</code></pre><pre><code class="nohighlight hljs">affect! (generic function with 1 method)</code></pre><p><code>integrator.u[2]</code> is the second value of our model, which is <code>v</code> or velocity, and <code>integrator.p[2]</code>, is our friction coefficient.</p><p>Therefore <code>affect!</code> can be read as follows: <code>affect!</code> will take the current value of velocity, and multiply it <code>-1</code> multiplied by our friction coefficient. Therefore the ball will change direction and its velocity will dampen when <code>affect!</code> is called.</p><p>Now let&#39;s build the <code>ContinuousCallback</code>:</p><pre><code class="language-julia hljs">bounce_cb = ContinuousCallback(condition,affect!)</code></pre><pre><code class="nohighlight hljs">DiffEqBase.ContinuousCallback{typeof(Main.##WeaveSandBox#432.condition),typ
eof(Main.##WeaveSandBox#432.affect!),typeof(Main.##WeaveSandBox#432.affect!
),typeof(DiffEqBase.INITIALIZE_DEFAULT),Float64,Int64,Nothing,Int64}(Main.#
#WeaveSandBox#432.condition, Main.##WeaveSandBox#432.affect!, Main.##WeaveS
andBox#432.affect!, DiffEqBase.INITIALIZE_DEFAULT, nothing, true, 10, Bool[
1, 1], 1, 2.220446049250313e-15, 0)</code></pre><p>Now let&#39;s make an <code>ODEProblem</code> which has our callback:</p><pre><code class="language-julia hljs">u0 = [50.0,0.0]
tspan = (0.0,15.0)
p = (9.8,0.9)
prob = ODEProblem(ball!,u0,tspan,p,callback=bounce_cb)</code></pre><pre><code class="nohighlight hljs">ODEProblem with uType Array{Float64,1} and tType Float64. In-place: true
timespan: (0.0, 15.0)
u0: [50.0, 0.0]</code></pre><p>Notice that we chose a friction constant of <code>0.9</code>. Now we can solve the problem and plot the solution as we normally would:</p><pre><code class="language-julia hljs">sol = solve(prob,Tsit5())
using Plots; gr()
plot(sol)</code></pre><p><img src="../figures/04-callbacks_and_events_6_1.png" alt/></p><p>and tada, the ball bounces! Notice that the <code>ContinuousCallback</code> is using the interpolation to apply the effect &quot;exactly&quot; when <code>v == 0</code>. This is crucial for model correctness, and thus when this property is needed a <code>ContinuousCallback</code> should be used.</p><h4 id="Exercise-1"><a class="docs-heading-anchor" href="#Exercise-1">Exercise 1</a><a id="Exercise-1-1"></a><a class="docs-heading-anchor-permalink" href="#Exercise-1" title="Permalink"></a></h4><p>In our example we used a constant coefficient of friction, but if we are bouncing the ball in the same place we may be smoothing the surface (say, squishing the grass), causing there to be less friction after each bounce. In this more advanced model, we want the friction coefficient at the next bounce to be <code>sqrt(friction)</code> from the previous bounce (since <code>friction &lt; 1</code>, <code>sqrt(friction) &gt; friction</code> and <code>sqrt(friction) &lt; 1</code>).</p><p>Hint: there are many ways to implement this. One way to do it is to make <code>p</code> a <code>Vector</code> and mutate the friction coefficient in the <code>affect!</code>.</p><h2 id="Discrete-Callbacks"><a class="docs-heading-anchor" href="#Discrete-Callbacks">Discrete Callbacks</a><a id="Discrete-Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Discrete-Callbacks" title="Permalink"></a></h2><p>A discrete callback checks a <code>condition</code> after every integration step and, if true, it will apply an <code>affect!</code>. For example, let&#39;s say that at time <code>t=2</code> we want to include that a kid kicked the ball, adding <code>20</code> to the current velocity. This kind of situation, where we want to add a specific behavior which does not require rootfinding, is a good candidate for a <code>DiscreteCallback</code>. In this case, the <code>condition</code> is a boolean for whether to apply the <code>affect!</code>, so:</p><pre><code class="language-julia hljs">function condition_kick(u,t,integrator)
    t == 2
end</code></pre><pre><code class="nohighlight hljs">condition_kick (generic function with 1 method)</code></pre><p>We want the kick to occur at <code>t=2</code>, so we check for that time point. When we are at this time point, we want to do:</p><pre><code class="language-julia hljs">function affect_kick!(integrator)
    integrator.u[2] += 50
end</code></pre><pre><code class="nohighlight hljs">affect_kick! (generic function with 1 method)</code></pre><p>Now we build the problem as before:</p><pre><code class="language-julia hljs">kick_cb = DiscreteCallback(condition_kick,affect_kick!)
u0 = [50.0,0.0]
tspan = (0.0,10.0)
p = (9.8,0.9)
prob = ODEProblem(ball!,u0,tspan,p,callback=kick_cb)</code></pre><pre><code class="nohighlight hljs">ODEProblem with uType Array{Float64,1} and tType Float64. In-place: true
timespan: (0.0, 10.0)
u0: [50.0, 0.0]</code></pre><p>Note that, since we are requiring our effect at exactly the time <code>t=2</code>, we need to tell the integration scheme to step at exactly <code>t=2</code> to apply this callback. This is done via the option <code>tstops</code>, which is like <code>saveat</code> but means &quot;stop at these values&quot;.</p><pre><code class="language-julia hljs">sol = solve(prob,Tsit5(),tstops=[2.0])
plot(sol)</code></pre><p><img src="../figures/04-callbacks_and_events_10_1.png" alt/></p><p>Note that this example could&#39;ve been done with a <code>ContinuousCallback</code> by checking the condition <code>t-2</code>.</p><h2 id="Merging-Callbacks-with-Callback-Sets"><a class="docs-heading-anchor" href="#Merging-Callbacks-with-Callback-Sets">Merging Callbacks with Callback Sets</a><a id="Merging-Callbacks-with-Callback-Sets-1"></a><a class="docs-heading-anchor-permalink" href="#Merging-Callbacks-with-Callback-Sets" title="Permalink"></a></h2><p>In some cases you may want to merge callbacks to build up more complex behavior. In our previous result, notice that the model is unphysical because the ball goes below zero! What we really need to do is add the bounce callback together with the kick. This can be achieved through the <code>CallbackSet</code>.</p><pre><code class="language-julia hljs">cb = CallbackSet(bounce_cb,kick_cb)</code></pre><pre><code class="nohighlight hljs">DiffEqBase.CallbackSet{Tuple{DiffEqBase.ContinuousCallback{typeof(Main.##We
aveSandBox#432.condition),typeof(Main.##WeaveSandBox#432.affect!),typeof(Ma
in.##WeaveSandBox#432.affect!),typeof(DiffEqBase.INITIALIZE_DEFAULT),Float6
4,Int64,Nothing,Int64}},Tuple{DiffEqBase.DiscreteCallback{typeof(Main.##Wea
veSandBox#432.condition_kick),typeof(Main.##WeaveSandBox#432.affect_kick!),
typeof(DiffEqBase.INITIALIZE_DEFAULT)}}}((DiffEqBase.ContinuousCallback{typ
eof(Main.##WeaveSandBox#432.condition),typeof(Main.##WeaveSandBox#432.affec
t!),typeof(Main.##WeaveSandBox#432.affect!),typeof(DiffEqBase.INITIALIZE_DE
FAULT),Float64,Int64,Nothing,Int64}(Main.##WeaveSandBox#432.condition, Main
.##WeaveSandBox#432.affect!, Main.##WeaveSandBox#432.affect!, DiffEqBase.IN
ITIALIZE_DEFAULT, nothing, true, 10, Bool[1, 1], 1, 2.220446049250313e-15, 
0),), (DiffEqBase.DiscreteCallback{typeof(Main.##WeaveSandBox#432.condition
_kick),typeof(Main.##WeaveSandBox#432.affect_kick!),typeof(DiffEqBase.INITI
ALIZE_DEFAULT)}(Main.##WeaveSandBox#432.condition_kick, Main.##WeaveSandBox
#432.affect_kick!, DiffEqBase.INITIALIZE_DEFAULT, Bool[1, 1]),))</code></pre><p>A <code>CallbackSet</code> merges their behavior together. The logic is as follows. In a given interval, if there are multiple continuous callbacks that would trigger, only the one that triggers at the earliest time is used. The time is pulled back to where that continuous callback is triggered, and then the <code>DiscreteCallback</code>s in the callback set are called in order.</p><pre><code class="language-julia hljs">u0 = [50.0,0.0]
tspan = (0.0,15.0)
p = (9.8,0.9)
prob = ODEProblem(ball!,u0,tspan,p,callback=cb)
sol = solve(prob,Tsit5(),tstops=[2.0])
plot(sol)</code></pre><p><img src="../figures/04-callbacks_and_events_12_1.png" alt/></p><p>Notice that we have now merged the behaviors. We can then nest this as deep as we like.</p><h4 id="Exercise-2"><a class="docs-heading-anchor" href="#Exercise-2">Exercise 2</a><a id="Exercise-2-1"></a><a class="docs-heading-anchor-permalink" href="#Exercise-2" title="Permalink"></a></h4><p>Add to the model a linear wind with resistance that changes the acceleration to <code>-g + k*v</code> after <code>t=10</code>. Do so by adding another parameter and allowing it to be zero until a specific time point where a third callback triggers the change.</p><h2 id="Integration-Termination-and-Directional-Handling"><a class="docs-heading-anchor" href="#Integration-Termination-and-Directional-Handling">Integration Termination and Directional Handling</a><a id="Integration-Termination-and-Directional-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-Termination-and-Directional-Handling" title="Permalink"></a></h2><p>Let&#39;s look at another model now: the model of the <a href="https://en.wikipedia.org/wiki/Harmonic_oscillator">Harmonic Oscillator</a>. We can write this as:</p><pre><code class="language-julia hljs">u0 = [1.,0.]
harmonic! = @ode_def HarmonicOscillator begin
   dv = -x
   dx = v
end
tspan = (0.0,10.0)
prob = ODEProblem(harmonic!,u0,tspan)
sol = solve(prob)
plot(sol)</code></pre><p><img src="../figures/04-callbacks_and_events_13_1.png" alt/></p><p>Let&#39;s instead stop the integration when a condition is met. From the <a href="https://docs.juliadiffeq.org/dev/basics/integrator/#stepping_controls-1">Integrator Interface stepping controls</a> we see that <code>terminate!(integrator)</code> will cause the integration to end. So our new <code>affect!</code> is simply:</p><pre><code class="language-julia hljs">function terminate_affect!(integrator)
    terminate!(integrator)
end</code></pre><pre><code class="nohighlight hljs">terminate_affect! (generic function with 1 method)</code></pre><p>Let&#39;s first stop the integration when the particle moves back to <code>x=0</code>. This means we want to use the condition:</p><pre><code class="language-julia hljs">function terminate_condition(u,t,integrator)
    u[2]
end
terminate_cb = ContinuousCallback(terminate_condition,terminate_affect!)</code></pre><pre><code class="nohighlight hljs">DiffEqBase.ContinuousCallback{typeof(Main.##WeaveSandBox#432.terminate_cond
ition),typeof(Main.##WeaveSandBox#432.terminate_affect!),typeof(Main.##Weav
eSandBox#432.terminate_affect!),typeof(DiffEqBase.INITIALIZE_DEFAULT),Float
64,Int64,Nothing,Int64}(Main.##WeaveSandBox#432.terminate_condition, Main.#
#WeaveSandBox#432.terminate_affect!, Main.##WeaveSandBox#432.terminate_affe
ct!, DiffEqBase.INITIALIZE_DEFAULT, nothing, true, 10, Bool[1, 1], 1, 2.220
446049250313e-15, 0)</code></pre><p>Note that instead of adding callbacks to the problem, we can also add them to the <code>solve</code> command. This will automatically form a <code>CallbackSet</code> with any problem-related callbacks and naturally allows you to distinguish between model features and integration controls.</p><pre><code class="language-julia hljs">sol = solve(prob,callback=terminate_cb)
plot(sol)</code></pre><p><img src="../figures/04-callbacks_and_events_16_1.png" alt/></p><p>Notice that the harmonic oscilator&#39;s true solution here is <code>sin</code> and <code>cosine</code>, and thus we would expect this return to zero to happen at <code>t=π</code>:</p><pre><code class="language-julia hljs">sol.t[end]</code></pre><pre><code class="nohighlight hljs">3.1415902497630053</code></pre><p>This is one way to approximate π! Lower tolerances and arbitrary precision numbers can make this more exact, but let&#39;s not look at that. Instead, what if we wanted to halt the integration after exactly one cycle? To do so we would need to ignore the first zero-crossing. Luckily in these types of scenarios there&#39;s usually a structure to the problem that can be exploited. Here, we only want to trigger the <code>affect!</code> when crossing from positive to negative, and not when crossing from negative to positive. In other words, we want our <code>affect!</code> to only occur on upcrossings.</p><p>If the <code>ContinuousCallback</code> constructor is given a single <code>affect!</code>, it will occur on both upcrossings and downcrossings. If there are two <code>affect!</code>s given, then the first is for upcrossings and the second is for downcrossings. An <code>affect!</code> can be ignored by using <code>nothing</code>. Together, the &quot;upcrossing-only&quot; version of the effect means that the first <code>affect!</code> is what we defined above and the second is <code>nothing</code>. Therefore we want:</p><pre><code class="language-julia hljs">terminate_upcrossing_cb = ContinuousCallback(terminate_condition,terminate_affect!,nothing)</code></pre><pre><code class="nohighlight hljs">DiffEqBase.ContinuousCallback{typeof(Main.##WeaveSandBox#432.terminate_cond
ition),typeof(Main.##WeaveSandBox#432.terminate_affect!),Nothing,typeof(Dif
fEqBase.INITIALIZE_DEFAULT),Float64,Int64,Nothing,Int64}(Main.##WeaveSandBo
x#432.terminate_condition, Main.##WeaveSandBox#432.terminate_affect!, nothi
ng, DiffEqBase.INITIALIZE_DEFAULT, nothing, true, 10, Bool[1, 1], 1, 2.2204
46049250313e-15, 0)</code></pre><p>Which gives us:</p><pre><code class="language-julia hljs">sol = solve(prob,callback=terminate_upcrossing_cb)
plot(sol)</code></pre><p><img src="../figures/04-callbacks_and_events_19_1.png" alt/></p><h2 id="Callback-Library"><a class="docs-heading-anchor" href="#Callback-Library">Callback Library</a><a id="Callback-Library-1"></a><a class="docs-heading-anchor-permalink" href="#Callback-Library" title="Permalink"></a></h2><p>As you can see, callbacks can be very useful and through <code>CallbackSets</code> we can merge together various behaviors. Because of this utility, there is a library of pre-built callbacks known as the <a href="http://docs.juliadiffeq.org/dev/features/callback_library/">Callback Library</a>. We will walk through a few examples where these callbacks can come in handy.</p><h3 id="Manifold-Projection"><a class="docs-heading-anchor" href="#Manifold-Projection">Manifold Projection</a><a id="Manifold-Projection-1"></a><a class="docs-heading-anchor-permalink" href="#Manifold-Projection" title="Permalink"></a></h3><p>One callback is the manifold projection callback. Essentially, you can define any manifold <code>g(sol)=0</code> which the solution must live on, and cause the integration to project to that manifold after every step. As an example, let&#39;s see what happens if we naively run the harmonic oscillator for a long time:</p><pre><code class="language-julia hljs">tspan = (0.0,10000.0)
prob = ODEProblem(harmonic!,u0,tspan)
sol = solve(prob)
gr(fmt=:png) # Make it a PNG instead of an SVG since there&#39;s a lot of points!
plot(sol,vars=(1,2))</code></pre><p><img src="../figures/04-callbacks_and_events_20_1.png" alt/></p><pre><code class="language-julia hljs">plot(sol,vars=(0,1),denseplot=false)</code></pre><p><img src="../figures/04-callbacks_and_events_21_1.png" alt/></p><p>Notice that what&#39;s going on is that the numerical solution is drifting from the true solution over this long time scale. This is because the integrator is not conserving energy.</p><pre><code class="language-julia hljs">plot(sol.t,[u[2]^2 + u[1]^2 for u in sol.u]) # Energy ~ x^2 + v^2</code></pre><p><img src="../figures/04-callbacks_and_events_22_1.png" alt/></p><p>Some integration techniques like <a href="https://docs.juliadiffeq.org/dev/solvers/dynamical_solve/#Symplectic-Integrators-1">symplectic integrators</a> are designed to mitigate this issue, but instead let&#39;s tackle the problem by enforcing conservation of energy. To do so, we define our manifold as the one where energy equals 1 (since that holds in the initial condition), that is:</p><pre><code class="language-julia hljs">function g(resid,u,p,t)
  resid[1] = u[2]^2 + u[1]^2 - 1
  resid[2] = 0
end</code></pre><pre><code class="nohighlight hljs">g (generic function with 1 method)</code></pre><p>Here the residual measures how far from our desired energy we are, and the number of conditions matches the size of our system (we ignored the second one by making the residual 0). Thus we define a <code>ManifoldProjection</code> callback and add that to the solver:</p><pre><code class="language-julia hljs">cb = ManifoldProjection(g)
sol = solve(prob,callback=cb)
plot(sol,vars=(1,2))</code></pre><p><img src="../figures/04-callbacks_and_events_24_1.png" alt/></p><pre><code class="language-julia hljs">plot(sol,vars=(0,1),denseplot=false)</code></pre><p><img src="../figures/04-callbacks_and_events_25_1.png" alt/></p><p>Now we have &quot;perfect&quot; energy conservation, where if it&#39;s ever violated too much the solution will get projected back to <code>energy=1</code>.</p><pre><code class="language-julia hljs">u1,u2 = sol[500]
u2^2 + u1^2</code></pre><pre><code class="nohighlight hljs">1.0000426288541124</code></pre><p>While choosing different integration schemes and using lower tolerances can achieve this effect as well, this can be a nice way to enforce physical constraints and is thus used in many disciplines like molecular dynamics. Another such domain constraining callback is the <a href="https://docs.juliadiffeq.org/dev/features/callback_library/#PositiveDomain-1"><code>PositiveCallback()</code></a> which can be used to enforce positivity of the variables.</p><h3 id="SavingCallback"><a class="docs-heading-anchor" href="#SavingCallback">SavingCallback</a><a id="SavingCallback-1"></a><a class="docs-heading-anchor-permalink" href="#SavingCallback" title="Permalink"></a></h3><p>The <code>SavingCallback</code> can be used to allow for special saving behavior. Let&#39;s take a linear ODE define on a system of 1000x1000 matrices:</p><pre><code class="language-julia hljs">prob = ODEProblem((du,u,p,t)-&gt;du.=u,rand(1000,1000),(0.0,1.0))</code></pre><pre><code class="nohighlight hljs">ODEProblem with uType Array{Float64,2} and tType Float64. In-place: true
timespan: (0.0, 1.0)
u0: [0.9879931455893609 0.8459514795879628 … 0.12437660939897444 0.60144899
7240285; 0.5075186459948859 0.5570664700161223 … 0.9830110970851273 0.93296
78540098196; … ; 0.6094372577262306 0.9886923913157719 … 0.6897194729548028
 0.9010207091690918; 0.4125617049501118 0.04365446235919235 … 0.16143622331
469043 0.29661794248884554]</code></pre><p>In fields like quantum mechanics you may only want to know specific properties of the solution such as the trace or the norm of the matrix. Saving all of the 1000x1000 matrices can be a costly way to get this information! Instead, we can use the <code>SavingCallback</code> to save the <code>trace</code> and <code>norm</code> at specified times. To do so, we first define our <code>SavedValues</code> cache. Our time is in terms of <code>Float64</code>, and we want to save tuples of <code>Float64</code>s (one for the <code>trace</code> and one for the <code>norm</code>), and thus we generate the cache as:</p><pre><code class="language-julia hljs">saved_values = SavedValues(Float64, Tuple{Float64,Float64})</code></pre><pre><code class="nohighlight hljs">SavedValues{tType=Float64, savevalType=Tuple{Float64,Float64}}
t:
Float64[]
saveval:
Tuple{Float64,Float64}[]</code></pre><p>Now we define the <code>SavingCallback</code> by giving it a function of <code>(u,p,t,integrator)</code> that returns the values to save, and the cache:</p><pre><code class="language-julia hljs">using LinearAlgebra
cb = SavingCallback((u,t,integrator)-&gt;(tr(u),norm(u)), saved_values)</code></pre><pre><code class="nohighlight hljs">DiffEqBase.DiscreteCallback{DiffEqCallbacks.var&quot;#30#31&quot;,DiffEqCallbacks.Sav
ingAffect{Main.##WeaveSandBox#432.var&quot;#17#18&quot;,Float64,Tuple{Float64,Float64
},DataStructures.BinaryHeap{Float64,DataStructures.LessThan},Array{Float64,
1}},typeof(DiffEqCallbacks.saving_initialize)}(DiffEqCallbacks.var&quot;#30#31&quot;(
), DiffEqCallbacks.SavingAffect{Main.##WeaveSandBox#432.var&quot;#17#18&quot;,Float64
,Tuple{Float64,Float64},DataStructures.BinaryHeap{Float64,DataStructures.Le
ssThan},Array{Float64,1}}(Main.##WeaveSandBox#432.var&quot;#17#18&quot;(), SavedValue
s{tType=Float64, savevalType=Tuple{Float64,Float64}}
t:
Float64[]
saveval:
Tuple{Float64,Float64}[], DataStructures.BinaryHeap{Float64,DataStructures.
LessThan}(DataStructures.LessThan(), Float64[]), Float64[], true, true, tru
e, 0), DiffEqCallbacks.saving_initialize, Bool[0, 0])</code></pre><p>Here we take <code>u</code> and save <code>(tr(u),norm(u))</code>. When we solve with this callback:</p><pre><code class="language-julia hljs">sol = solve(prob, Tsit5(), callback=cb, save_everystep=false, save_start=false, save_end = false) # Turn off normal saving</code></pre><pre><code class="nohighlight hljs">retcode: Success
Interpolation: 1st order linear
t: 0-element Array{Float64,1}
u: 0-element Array{Array{Float64,2},1}</code></pre><p>Our values are stored in our <code>saved_values</code> variable:</p><pre><code class="language-julia hljs">saved_values.t</code></pre><pre><code class="nohighlight hljs">5-element Array{Float64,1}:
 0.0
 0.10012909234078712
 0.34839012956458915
 0.6837368053160041
 1.0</code></pre><pre><code class="language-julia hljs">saved_values.saveval</code></pre><pre><code class="nohighlight hljs">5-element Array{Tuple{Float64,Float64},1}:
 (493.8130627293116, 577.574819350342)
 (545.8182923190569, 638.40130077138)
 (699.626875729263, 818.2992651684409)
 (978.375758562294, 1144.3302023748365)
 (1342.3230160768928, 1570.0110670126246)</code></pre><p>By default this happened only at the solver&#39;s steps. But the <code>SavingCallback</code> has similar controls as the integrator. For example, if we want to save at every <code>0.1</code> seconds, we do can so using <code>saveat</code>:</p><pre><code class="language-julia hljs">saved_values = SavedValues(Float64, Tuple{Float64,Float64}) # New cache
cb = SavingCallback((u,t,integrator)-&gt;(tr(u),norm(u)), saved_values, saveat = 0.0:0.1:1.0)
sol = solve(prob, Tsit5(), callback=cb, save_everystep=false, save_start=false, save_end = false) # Turn off normal saving</code></pre><pre><code class="nohighlight hljs">retcode: Success
Interpolation: 1st order linear
t: 0-element Array{Float64,1}
u: 0-element Array{Array{Float64,2},1}</code></pre><pre><code class="language-julia hljs">saved_values.t</code></pre><pre><code class="nohighlight hljs">11-element Array{Float64,1}:
 0.0
 0.1
 0.2
 0.3
 0.4
 0.5
 0.6
 0.7
 0.8
 0.9
 1.0</code></pre><pre><code class="language-julia hljs">saved_values.saveval</code></pre><pre><code class="nohighlight hljs">11-element Array{Tuple{Float64,Float64},1}:
 (493.8130627293116, 577.574819350342)
 (545.7478359058158, 638.3188933722616)
 (603.1446583851525, 705.4515026061309)
 (666.5778718850487, 779.6444099899865)
 (736.6826568938942, 861.6405368507976)
 (814.1600583919651, 952.2598411005755)
 (899.7857160671499, 1052.4095282922406)
 (994.4173917015307, 1163.0928558195844)
 (1099.001269598267, 1285.4165020376604)
 (1214.5837550613833, 1420.6043660290525)
 (1342.3230160768928, 1570.0110670126246)</code></pre><h4 id="Exercise-3"><a class="docs-heading-anchor" href="#Exercise-3">Exercise 3</a><a id="Exercise-3-1"></a><a class="docs-heading-anchor-permalink" href="#Exercise-3" title="Permalink"></a></h4><p>Go back to the Harmonic oscillator. Use the <code>SavingCallback</code> to save an array for the energy over time, and do this both with and without the <code>ManifoldProjection</code>. Plot the results to see the difference the projection makes.</p><h2 id="Appendix"><a class="docs-heading-anchor" href="#Appendix">Appendix</a><a id="Appendix-1"></a><a class="docs-heading-anchor-permalink" href="#Appendix" title="Permalink"></a></h2><p>This tutorial is part of the DiffEqTutorials.jl repository, found at: <a href="https://github.com/JuliaDiffEq/DiffEqTutorials.jl">https://github.com/JuliaDiffEq/DiffEqTutorials.jl</a></p><p>To locally run this tutorial, do the following commands:</p><pre><code class="nohighlight hljs">using DiffEqTutorials
DiffEqTutorials.weave_file(&quot;introduction&quot;,&quot;04-callbacks_and_events.jmd&quot;)</code></pre><p>Computer Information:</p><pre><code class="nohighlight hljs">Julia Version 1.4.2
Commit 44fa15b150* (2020-05-23 18:35 UTC)
Platform Info:
  OS: Linux (x86_64-pc-linux-gnu)
  CPU: Intel(R) Core(TM) i7-9700K CPU @ 3.60GHz
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-8.0.1 (ORCJIT, skylake)
Environment:
  JULIA_DEPOT_PATH = /builds/JuliaGPU/DiffEqTutorials.jl/.julia
  JULIA_CUDA_MEMORY_LIMIT = 536870912
  JULIA_PROJECT = @.
  JULIA_NUM_THREADS = 4
</code></pre><p>Package Information:</p><pre><code class="nohighlight hljs">Status `/builds/JuliaGPU/DiffEqTutorials.jl/tutorials/introduction/Project.toml`
[6e4b80f9-dd63-53aa-95a3-0cdb28fa8baf] BenchmarkTools 0.5.0
[0c46a032-eb83-5123-abaf-570d42b7fbaa] DifferentialEquations 6.14.0
[65888b18-ceab-5e60-b2b9-181511a3b968] ParameterizedFunctions 5.3.0
[91a5bcdd-55d7-5caf-9e0b-520d859cae80] Plots 1.4.3
[90137ffa-7385-5640-81b9-e52037218182] StaticArrays 0.12.3
[c3572dad-4567-51f8-b174-8c6c989267f4] Sundials 4.2.3
[37e2e46d-f89d-539d-b4ee-838fcccc9c8e] LinearAlgebra</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../03-optimizing_diffeq_code/">« Optimizing DiffEq Code</a><a class="docs-footer-nextpage" href="../05-formatting_plots/">Formatting Plots »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Saturday 13 August 2022 03:52">Saturday 13 August 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
